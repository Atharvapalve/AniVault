PROJECT EXPORT

PROJECT STRUCTURE:

ğŸ“ .github
  ğŸ“ workflows
    ğŸ“„ release.yml
ğŸ“ apps
  ğŸ“ desktop
    ğŸ“ out
      ğŸ“ main
        ğŸ“„ main.js
      ğŸ“ preload
        ğŸ“„ preload.mjs
    ğŸ“ src
      ğŸ“ main
        ğŸ“„ main.ts
        ğŸ“„ organizer.ts
        ğŸ“„ store.ts
        ğŸ“„ watcher.ts
      ğŸ“ preload
        ğŸ“„ preload.ts
      ğŸ“ renderer
        ğŸ“ components
          ğŸ“ settings
            ğŸ“„ ThemeSelector.tsx
          ğŸ“„ AnimeDetailsModal.tsx
          ğŸ“„ AnimeMatchModal.tsx
          ğŸ“„ AutoOrganizerPanel.tsx
          ğŸ“„ Discover.tsx
          ğŸ“„ HomeDashboard.tsx
          ğŸ“„ Layout.tsx
          ğŸ“„ Library.tsx
          ğŸ“„ LicenseSettings.tsx
          ğŸ“„ SearchBar.tsx
          ğŸ“„ Sidebar.tsx
          ğŸ“„ StatsDashboard.tsx
          ğŸ“„ TitleBar.tsx
          ğŸ“„ Toast.tsx
          ğŸ“„ TrendingNow.tsx
          ğŸ“„ WelcomeScreen.tsx
        ğŸ“ services
          ğŸ“„ anilist.service.ts
          ğŸ“„ auth.service.ts
          ğŸ“„ licensing.service.ts
          ğŸ“„ recommendation.service.ts
          ğŸ“„ stats.service.ts
          ğŸ“„ tracking.service.ts
        ğŸ“ store
          ğŸ“„ useStore.ts
        ğŸ“„ App.tsx
        ğŸ“„ index.css
        ğŸ“„ index.html
        ğŸ“„ main.tsx
        ğŸ“„ vite-env.d.ts
    ğŸ“„ electron-builder.yml
    ğŸ“„ electron.vite.config.ts
    ğŸ“„ package.json
    ğŸ“„ postcss.config.js
    ğŸ“„ tailwind.config.js
    ğŸ“„ tsconfig.json
  ğŸ“ extension
    ğŸ“ icons
    ğŸ“ scripts
      ğŸ“„ generate-icons.js
    ğŸ“ src
      ğŸ“ background
        ğŸ“„ background.ts
      ğŸ“ content
        ğŸ“„ adapters.ts
        ğŸ“„ content.ts
        ğŸ“„ video-tracker.ts
      ğŸ“ popup
        ğŸ“„ App.tsx
        ğŸ“„ index.css
        ğŸ“„ index.html
        ğŸ“„ main.tsx
        ğŸ“„ vite-env.d.ts
      ğŸ“„ types.ts
    ğŸ“„ .gitkeep
    ğŸ“„ manifest.json
    ğŸ“„ package.json
    ğŸ“„ postcss.config.js
    ğŸ“„ README.md
    ğŸ“„ tailwind.config.js
    ğŸ“„ tsconfig.json
    ğŸ“„ vite.config.ts
  ğŸ“ web
    ğŸ“ .astro
      ğŸ“„ settings.json
      ğŸ“„ types.d.ts
    ğŸ“ public
      ğŸ“„ favicon.svg
    ğŸ“ src
      ğŸ“ components
        ğŸ“„ Hero.tsx
      ğŸ“ layouts
        ğŸ“„ Layout.astro
      ğŸ“ pages
        ğŸ“„ index.astro
      ğŸ“ styles
        ğŸ“„ global.css
      ğŸ“„ env.d.ts
    ğŸ“„ astro.config.mjs
    ğŸ“„ package.json
    ğŸ“„ tailwind.config.mjs
    ğŸ“„ tsconfig.json
  ğŸ“ website
    ğŸ“ app
      ğŸ“„ globals.css
      ğŸ“„ layout.tsx
      ğŸ“„ page.tsx
    ğŸ“ components
      ğŸ“„ FAQ.tsx
      ğŸ“„ FeatureGrid.tsx
      ğŸ“„ Footer.tsx
      ğŸ“„ GlowCard.tsx
      ğŸ“„ Hero.tsx
      ğŸ“„ HowItWorks.tsx
      ğŸ“„ NavBar.tsx
      ğŸ“„ Pricing.tsx
      ğŸ“„ Screenshots.tsx
    ğŸ“„ .gitignore
    ğŸ“„ next-env.d.ts
    ğŸ“„ next.config.js
    ğŸ“„ package.json
    ğŸ“„ postcss.config.js
    ğŸ“„ tailwind.config.js
    ğŸ“„ tsconfig.json
ğŸ“ packages
  ğŸ“ shared
    ğŸ“ src
      ğŸ“„ extension.ts
      ğŸ“„ index.ts
    ğŸ“„ package.json
    ğŸ“„ tsconfig.json
  ğŸ“ ui
    ğŸ“ src
      ğŸ“ components
        ğŸ“„ button.tsx
        ğŸ“„ card.tsx
        ğŸ“„ input.tsx
      ğŸ“ lib
        ğŸ“„ utils.ts
      ğŸ“„ index.ts
    ğŸ“„ package.json
    ğŸ“„ postcss.config.js
    ğŸ“„ tailwind.config.js
    ğŸ“„ tsconfig.json
ğŸ“„ .gitignore
ğŸ“„ .npmrc
ğŸ“„ package.json
ğŸ“„ pnpm-workspace.yaml
ğŸ“„ project-export.txt
ğŸ“„ README.md
ğŸ“„ SETUP.md

FILES:

=== .github\workflows\release.yml ===

name: Build and Release Desktop

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  build:
    runs-on: windows-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Install Dependencies
        run: pnpm install

      - name: Build Desktop
        run: pnpm --filter apps/desktop run build

      - name: Sign artifacts (PowerShell)
        if: ${{ secrets.SIGNING_PFX && secrets.SIGNING_PASSWORD }}
        shell: pwsh
        run: |
          $pfx = "${{ secrets.SIGNING_PFX }}"
          $pwd = "${{ secrets.SIGNING_PASSWORD }}"
          $bytes = [System.Convert]::FromBase64String($pfx)
          $pfxPath = "$env:RUNNER_TEMP\codesign.pfx"
          [System.IO.File]::WriteAllBytes($pfxPath, $bytes)
          & "C:\Program Files (x86)\Windows Kits\10\bin\x64\signtool.exe" sign /f $pfxPath /p $pwd /tr http://timestamp.digicert.com /td sha256 /fd sha256 "apps/desktop/dist_electron/*.exe"

      - name: Create GitHub Release and upload artifacts
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ github.ref_name }}
          files: |
            apps/desktop/dist_electron/*.exe
            apps/desktop/dist_electron/*.nsis.*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}




========================================

=== .gitignore ===

# Dependencies
node_modules
.pnp
.pnp.js

# Testing
coverage

# Production
dist
build
out

# Misc
.DS_Store
*.pem
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Editor
.vscode/*
!.vscode/extensions.json
.idea
*.swp
*.swo
*~

# OS
Thumbs.db

# Electron
apps/desktop/dist-electron
apps/desktop/release

# Extension
apps/extension/dist
apps/extension/*.zip

# Astro
apps/web/.astro



========================================

=== .npmrc ===

shamefully-hoist=true
strict-peer-dependencies=false



========================================

=== apps\desktop\electron-builder.yml ===

appId: com.anivault.desktop
productName: AniVault
directories:
  buildResources: build
  output: release
files:
  - out/**
  - package.json
win:
  target:
    - nsis
  icon: build/icon.ico
nsis:
  oneClick: false
  allowToChangeInstallationDirectory: true
  createDesktopShortcut: true
  createStartMenuShortcut: true



========================================

=== apps\desktop\electron.vite.config.ts ===

import { defineConfig, externalizeDepsPlugin } from 'electron-vite'
import react from '@vitejs/plugin-react'
import path from 'path'
import tailwindcss from 'tailwindcss'
import autoprefixer from 'autoprefixer'

export default defineConfig({
  main: {
    plugins: [externalizeDepsPlugin()],
  },
  preload: {
    plugins: [externalizeDepsPlugin()],
  },
  renderer: {
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src/renderer'),
      },
    },
    plugins: [react()],
    css: {
      postcss: {
        plugins: [
          tailwindcss,
          autoprefixer,
        ],
      },
    },
  },
})



========================================

=== apps\desktop\out\main\main.js ===

import { BrowserWindow, app, ipcMain, shell, dialog } from "electron";
import path, { resolve, join } from "path";
import { createServer } from "http";
import pkg from "discord-rpc";
import Store from "electron-store";
import { exec } from "child_process";
import { promisify } from "util";
import { promises } from "fs";
import __cjs_mod__ from "node:module";
const __filename = import.meta.filename;
const __dirname = import.meta.dirname;
const require2 = __cjs_mod__.createRequire(import.meta.url);
const store = new Store({
  defaults: {
    accessToken: null,
    licenseKey: null,
    user: null
  }
});
const execAsync = promisify(exec);
function parseAnimeFilename(filename) {
  const nameWithoutExt = filename.replace(/\.[^.]*$/, "");
  const episodePatterns = [
    /[Ss](\d+)[Ee](\d+)/,
    // S01E01, S1E1
    /[Ee]p(?:isode)?\s*(\d+)/i,
    // Ep1, Episode 1, ep 1
    /[Ee](\d+)(?:\s|$|\[|\(|v)/,
    // E1, E01
    /\s-\s*(\d+)(?:\s|$|\[|\(|v)/,
    // - 1, - 01
    /\[(\d+)\](?:\s|$)/,
    // [1], [01]
    /\((\d+)\)(?:\s|$)/,
    // (1), (01)
    /\s(\d+)(?:\s|$|\[|\(|v)/
    // Space followed by number
  ];
  let episode = null;
  let title = nameWithoutExt;
  for (const pattern of episodePatterns) {
    const match = nameWithoutExt.match(pattern);
    if (match) {
      if (pattern.source.includes("[Ss]") && match[2]) {
        episode = parseInt(match[2], 10);
        title = nameWithoutExt.replace(pattern, "").trim();
      } else if (match[1]) {
        episode = parseInt(match[1], 10);
        title = nameWithoutExt.replace(pattern, "").trim();
      }
      if (episode && !isNaN(episode)) {
        break;
      }
    }
  }
  title = title.replace(/^\[.*?\]\s*/, "").replace(/\s*\[.*?\]\s*$/, "").replace(/\s*\(.*?\)\s*$/, "").replace(/\s*-\s*$/, "").replace(/\s+/g, " ").trim();
  if (episode && (!title || title.length < 2)) {
    title = nameWithoutExt.replace(/\[.*?\]/g, "").replace(/\(.*?\)/g, "").trim();
  }
  return {
    title: title || null,
    episode: episode && !isNaN(episode) ? episode : null
  };
}
const MEDIA_PLAYERS = [
  "vlc.exe",
  // VLC Media Player
  "mpv.exe",
  // MPV
  "mpc-hc.exe",
  // Media Player Classic - Home Cinema
  "mpc-be.exe",
  // Media Player Classic - Black Edition
  "potplayer.exe",
  // PotPlayer
  "kodi.exe",
  // Kodi
  "wmplayer.exe",
  // Windows Media Player (Legacy)
  "kmplayer.exe",
  // KMPlayer (New addition)
  "gom.exe",
  // GOM Player (New addition)
  "plex.exe",
  // Plex Media Player (New addition)
  "ffplay.exe"
  // FFmpeg Play (New addition)
];
let watcherInterval = null;
let lastDetectedEpisode = null;
async function getActiveWindows() {
  try {
    const { stdout, stderr } = await execAsync("tasklist /v /fo csv");
    if (!stdout || stdout.trim().length === 0) {
      if (process.env.NODE_ENV === "development") {
        console.log("[Watcher] tasklist returned no stdout", { stderr });
      }
      return [];
    }
    const windows = [];
    const lines = stdout.split("\n");
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      const parts = line.match(/"(.*?)"/g);
      if (parts && parts.length >= 9) {
        const processName = parts[0].replace(/"/g, "").toLowerCase();
        const windowTitle = parts[8].replace(/"/g, "").trim();
        if (!windowTitle || windowTitle === "N/A" || windowTitle.length === 0) {
          continue;
        }
        const isMediaPlayer = MEDIA_PLAYERS.some((player) => processName.includes(player));
        if (isMediaPlayer && windowTitle) {
          windows.push({
            title: windowTitle,
            process: processName
          });
        }
      }
    }
    return windows;
  } catch (error) {
    if (error?.code === "ETIMEDOUT" || error?.message?.includes("timeout") || error?.message?.includes("cancelled") || error?.message?.includes("Call cancelled") || error?.code === 1) {
      return [];
    }
    if (process.env.NODE_ENV === "development" && !error?.message?.includes("cancelled")) {
      console.error("Error getting active windows:", error?.message || error);
    }
    return [];
  }
}
function startPolling(callback) {
  if (watcherInterval) {
    return;
  }
  console.log("Starting media watcher...");
  watcherInterval = setInterval(async () => {
    try {
      const windows = await getActiveWindows();
      if (process.env.NODE_ENV === "development") {
        console.log("[Watcher] tasklist windows:", windows.slice(0, 5));
      }
      if (windows.length === 0) {
        if (process.env.NODE_ENV === "development") {
          console.log("[Watcher] No media windows detected");
        }
        return;
      }
      for (const window of windows) {
        try {
          const parsed = parseAnimeFilename(window.title);
          if (process.env.NODE_ENV === "development") {
            console.log("[Watcher] Parsed window:", { windowTitle: window.title, parsed });
          }
          if (!parsed.episode || !parsed.title) {
            if (process.env.NODE_ENV === "development") {
              console.log("[Watcher] Skipping - no episode/title", window.title);
            }
            continue;
          }
          const title = parsed.title;
          const episode = parsed.episode;
          if (!title || isNaN(episode)) {
            if (process.env.NODE_ENV === "development") {
              console.log("[Watcher] Skipping - invalid data", { title, episode });
            }
            continue;
          }
          if (lastDetectedEpisode && lastDetectedEpisode.title === title && lastDetectedEpisode.episode === episode) {
            if (process.env.NODE_ENV === "development") {
              console.log("[Watcher] Skipping duplicate", { title, episode });
            }
            continue;
          }
          lastDetectedEpisode = { title, episode };
          callback({
            title,
            episode
          });
          const browserWindows = BrowserWindow.getAllWindows();
          browserWindows.forEach((win) => {
            win.webContents.send("tracking:detected", {
              title,
              episode
            });
          });
          console.log(`Detected: ${title} - Episode ${episode}`);
          break;
        } catch (error) {
          if (process.env.NODE_ENV === "development") {
            console.error("Error parsing window title:", window.title, error);
          }
          continue;
        }
      }
    } catch (error) {
      if (process.env.NODE_ENV === "development") {
        console.error("Watcher error:", error);
      }
    }
  }, 1e4);
}
function stopWatcher() {
  if (watcherInterval) {
    clearInterval(watcherInterval);
    watcherInterval = null;
    console.log("Stopped media watcher");
  }
}
const VIDEO_EXTENSIONS = /* @__PURE__ */ new Set([".mkv", ".mp4", ".avi", ".mov", ".flv", ".webm"]);
function sanitizeName(name) {
  return name.replace(/[<>:"/\\|?*]+/g, "").trim();
}
function inferSeasonFromFilename(filename, episode) {
  const lower = filename.toLowerCase();
  const sMatch = lower.match(/(?:^|[\s._\-])(s)(\d{1,2})(?:[^0-9]|$)/i);
  if (sMatch && sMatch[2]) {
    const n = parseInt(sMatch[2], 10);
    if (!Number.isNaN(n)) return n;
  }
  const seasonMatch = lower.match(/season\s*(\d{1,2})/i);
  if (seasonMatch && seasonMatch[1]) {
    const n = parseInt(seasonMatch[1], 10);
    if (!Number.isNaN(n)) return n;
  }
  return 1;
}
async function collectVideoFiles(dir) {
  const entries = await promises.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      const nested = await collectVideoFiles(full);
      files.push(...nested);
    } else if (entry.isFile()) {
      const ext = path.extname(entry.name).toLowerCase();
      if (VIDEO_EXTENSIONS.has(ext)) {
        files.push(full);
      }
    }
  }
  return files;
}
function findMatchingAnime(parsedTitle, fileName, library) {
  if (!parsedTitle) return null;
  const normalizedParsed = parsedTitle.toLowerCase();
  const bestMatch = library.find((anime) => {
    const t = anime.title.toLowerCase();
    return t.includes(normalizedParsed) || normalizedParsed.includes(t);
  });
  return bestMatch ?? null;
}
async function buildOrganizePlan(sourceDir, targetRoot, library) {
  const files = await collectVideoFiles(sourceDir);
  const plan = [];
  for (const from of files) {
    const base = path.basename(from);
    const ext = path.extname(base);
    const nameWithoutExt = base.slice(0, -ext.length);
    const { title: parsedTitle, episode } = parseAnimeFilename(nameWithoutExt);
    const matchedAnime = parsedTitle ? findMatchingAnime(parsedTitle, nameWithoutExt, library) : null;
    if (!matchedAnime || episode == null) {
      plan.push({
        from,
        to: from,
        title: parsedTitle,
        episode: episode ?? null,
        matchedAnimeId: matchedAnime?.id ?? void 0,
        matchedAnimeTitle: matchedAnime?.title ?? void 0,
        season: null,
        status: "unmatched"
      });
      continue;
    }
    const season = inferSeasonFromFilename(nameWithoutExt);
    const safeTitle = sanitizeName(matchedAnime.title);
    const seasonFolder = `Season ${season}`;
    const fileName = `${safeTitle} - Episode ${episode.toString().padStart(3, "0")}${ext}`;
    const targetDir = path.join(targetRoot, safeTitle, seasonFolder);
    const to = path.join(targetDir, fileName);
    const status = from.toLowerCase() === to.toLowerCase() ? "unmatched" : "ready";
    plan.push({
      from,
      to,
      title: parsedTitle,
      episode,
      matchedAnimeId: matchedAnime.id,
      matchedAnimeTitle: matchedAnime.title,
      season,
      status
    });
  }
  const byTarget = /* @__PURE__ */ new Map();
  for (const item of plan) {
    if (!item.to) continue;
    const key = item.to.toLowerCase();
    byTarget.set(key, (byTarget.get(key) ?? 0) + 1);
  }
  for (const item of plan) {
    const key = item.to.toLowerCase();
    if (byTarget.get(key) > 1 && item.status === "ready") {
      item.status = "conflict";
    }
  }
  return plan;
}
async function applyOrganizePlan(plan, logPath) {
  const operations = plan.filter((p) => p.status === "ready" && p.from !== p.to);
  for (const op of operations) {
    const dir = path.dirname(op.to);
    await promises.mkdir(dir, { recursive: true });
  }
  for (const op of operations) {
    await promises.rename(op.from, op.to);
  }
  const log = {
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    operations: operations.map((op) => ({
      from: op.from,
      to: op.to,
      title: op.title,
      episode: op.episode,
      matchedAnimeId: op.matchedAnimeId,
      season: op.season
    }))
  };
  try {
    const logDir = path.dirname(logPath);
    await promises.mkdir(logDir, { recursive: true });
    await promises.writeFile(logPath, JSON.stringify(log, null, 2), "utf-8");
  } catch (error) {
    console.error("Failed to write organizer log file:", error);
  }
}
const { Client, register } = pkg;
const EXTENSION_SERVER_PORT = 35847;
const EXTENSION_ENDPOINT = "/extension-event";
let extensionServer = null;
let mainWindow = null;
const DISCORD_CLIENT_ID = "1447800723512361040";
let discordClient = null;
let presenceConfig = {
  enabled: true,
  mode: "minimal",
  useMood: true,
  showButtons: true
};
let presenceClearTimeout = null;
const PRESENCE_CLEAR_DELAY = 3e4;
function buildDiscordActivity(ctx, isPro) {
  if (!ctx.title) return null;
  const {
    title,
    episode,
    totalEpisodes,
    episodesThisSession,
    episodesToday,
    moodLabel,
    moodEmoji,
    themeId
  } = ctx;
  let largeImageKey = "anivault-logo";
  if (isPro && themeId) {
    if (themeId.includes("neon")) largeImageKey = "anivault-neon";
    else if (themeId.includes("midnight")) largeImageKey = "anivault-midnight";
  }
  let details = `Watching ${title}`;
  let state = `Episode ${episode}${totalEpisodes ? ` / ${totalEpisodes}` : ""}`;
  const buttons = [];
  if (!isPro) {
    return {
      details,
      state,
      largeImageKey,
      instance: false
    };
  }
  const mode = presenceConfig.mode;
  if (mode === "minimal") {
    details = `Watching ${title}`;
    state = `Ep ${episode}${totalEpisodes ? ` / ${totalEpisodes}` : ""}`;
  } else if (mode === "stats") {
    const parts = [];
    parts.push(`Ep ${episode}${totalEpisodes ? `/${totalEpisodes}` : ""}`);
    if (typeof episodesThisSession === "number" && episodesThisSession > 0) {
      parts.push(`${episodesThisSession} eps this session`);
    }
    if (typeof episodesToday === "number" && episodesToday > 0) {
      parts.push(`${episodesToday} today`);
    }
    details = `Bingeing ${title}`;
    state = parts.join(" â€¢ ");
  } else if (mode === "weeb") {
    const moodText = presenceConfig.useMood && moodLabel ? `${moodEmoji ?? ""} ${moodLabel}`.trim() : "Anime session";
    const parts = [];
    parts.push(`Ep ${episode}${totalEpisodes ? `/${totalEpisodes}` : ""}`);
    if (typeof episodesThisSession === "number" && episodesThisSession > 0) {
      parts.push(`${episodesThisSession} eps this session`);
    }
    details = moodText;
    state = `${title} â€” ${parts.join(" â€¢ ")}`;
  }
  if (presenceConfig.showButtons) {
    buttons.push({
      label: "View on AniList",
      url: "https://anilist.co/"
    });
    buttons.push({
      label: "Get AniVault",
      url: "https://your-anivault-website-url.com"
    });
  }
  const activity = {
    details,
    state,
    largeImageKey,
    instance: false
  };
  if (buttons.length > 0) {
    activity.buttons = buttons;
  }
  return activity;
}
async function initDiscordRPC() {
  try {
    register(DISCORD_CLIENT_ID);
    discordClient = new Client({ transport: "ipc" });
    await discordClient.connect(DISCORD_CLIENT_ID);
    console.log("Discord RPC connected");
    await discordClient.setActivity({
      details: "AniVault",
      state: "Ready to track anime",
      largeImageKey: "logo",
      // <--- This must match the Asset Name in Discord Portal
      largeImageText: "AniVault"
      // Tooltip when hovering over the image
    });
  } catch (error) {
    console.error("Failed to initialize Discord RPC:", error);
    discordClient = null;
  }
}
async function updateDiscordPresence(title, episode) {
  if (!discordClient) {
    return;
  }
  if (presenceClearTimeout) {
    clearTimeout(presenceClearTimeout);
    presenceClearTimeout = null;
  }
  try {
    const activity = buildDiscordActivity(
      {
        title,
        episode
      },
      false
    );
    if (!activity) return;
    await discordClient.setActivity(activity);
    presenceClearTimeout = setTimeout(() => {
      setDefaultDiscordPresence();
      presenceClearTimeout = null;
    }, PRESENCE_CLEAR_DELAY);
  } catch (error) {
    console.error("Failed to update Discord presence:", error);
  }
}
function schedulePresenceClear() {
  if (presenceClearTimeout) {
    clearTimeout(presenceClearTimeout);
    presenceClearTimeout = null;
  }
  setDefaultDiscordPresence();
}
async function setDefaultDiscordPresence() {
  if (!discordClient) {
    return;
  }
  if (presenceClearTimeout) {
    clearTimeout(presenceClearTimeout);
    presenceClearTimeout = null;
  }
  try {
    await discordClient.setActivity({
      details: "AniVault",
      state: "Ready to track anime",
      largeImageKey: "logo",
      largeImageText: "AniVault"
    });
  } catch (error) {
    console.error("Failed to set default Discord presence:", error);
  }
}
async function clearDiscordPresence() {
  await setDefaultDiscordPresence();
}
let handlersRegistered = false;
function registerWindowHandlers() {
  if (handlersRegistered) return;
  ipcMain.handle("window-minimize", () => {
    if (mainWindow) {
      if (!mainWindow.isVisible()) mainWindow.show();
      mainWindow.minimize();
    }
  });
  ipcMain.handle("window-maximize", () => {
    if (!mainWindow) return;
    const wasMaximized = mainWindow.isMaximized();
    if (wasMaximized) {
      mainWindow.unmaximize();
      mainWindow.webContents.send("window-unmaximized", false);
    } else {
      mainWindow.maximize();
      mainWindow.webContents.send("window-maximized", true);
    }
  });
  ipcMain.handle("window-close", () => {
    if (mainWindow) mainWindow.close();
  });
  ipcMain.handle("window-is-maximized", () => {
    return mainWindow?.isMaximized() ?? false;
  });
  handlersRegistered = true;
}
function startExtensionServer() {
  if (extensionServer) {
    return;
  }
  extensionServer = createServer((req, res) => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS, GET");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");
    if (req.method === "OPTIONS") {
      res.writeHead(200);
      res.end();
      return;
    }
    if ((req.method === "POST" || req.method === "GET") && req.url === `${EXTENSION_ENDPOINT}/clear`) {
      schedulePresenceClear();
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ ok: true }));
      return;
    }
    if (req.method === "POST" && req.url === EXTENSION_ENDPOINT) {
      let body = "";
      req.on("data", (chunk) => {
        body += chunk.toString();
      });
      req.on("end", () => {
        try {
          const event = JSON.parse(body);
          if (event.title && event.platform) {
            console.log(
              `[AniVault] Extension event from ${event.platform}: ${event.title} (overall ${event.overallEpisode ?? "?"} / S${event.seasonNumber ?? "?"} E${event.seasonEpisode ?? "?"})`
            );
            const browserWindows = BrowserWindow.getAllWindows();
            browserWindows.forEach((win) => {
              const episodeForLegacy = event.overallEpisode ?? event.seasonEpisode ?? null;
              win.webContents.send("tracking:detected", {
                platform: event.platform,
                title: event.title,
                // Legacy episode field for existing renderer handlers
                episode: episodeForLegacy,
                overallEpisode: event.overallEpisode ?? null,
                seasonNumber: event.seasonNumber ?? null,
                seasonEpisode: event.seasonEpisode ?? null,
                url: event.url ?? null,
                watchedSeconds: event.watchedSeconds ?? null,
                durationSeconds: event.durationSeconds ?? null,
                progress: event.progress ?? null,
                completedAt: event.completedAt ?? (/* @__PURE__ */ new Date()).toISOString(),
                source: "extension"
              });
            });
            const presenceEpisode = event.overallEpisode ?? event.seasonEpisode ?? null;
            if (presenceEpisode !== null) {
              updateDiscordPresence(event.title, presenceEpisode);
            }
            res.writeHead(200, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ ok: true }));
          } else {
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ ok: false, error: "Invalid event data" }));
          }
        } catch (error) {
          console.error("[AniVault] Error parsing extension event:", error);
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ ok: false, error: "Invalid JSON" }));
        }
      });
    } else {
      res.writeHead(404);
      res.end();
    }
  });
  extensionServer.listen(EXTENSION_SERVER_PORT, "127.0.0.1", () => {
    console.log(`[AniVault] Extension server listening on http://127.0.0.1:${EXTENSION_SERVER_PORT}`);
  });
  extensionServer.on("error", (error) => {
    if (error.code === "EADDRINUSE") {
      console.warn(`[AniVault] Extension server port ${EXTENSION_SERVER_PORT} is already in use`);
    } else {
      console.error("[AniVault] Extension server error:", error);
    }
  });
}
function stopExtensionServer() {
  if (extensionServer) {
    extensionServer.close();
    extensionServer = null;
    console.log("[AniVault] Extension server stopped");
  }
}
const ANILIST_CLIENT_ID = "32987";
const ANILIST_CLIENT_SECRET = "YOUR_FALLBACK_SECRET";
const ANILIST_REDIRECT_URI = "anivault://auth/callback";
async function exchangeCodeForToken(code) {
  const response = await fetch("https://anilist.co/api/v2/oauth/token", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      grant_type: "authorization_code",
      client_id: ANILIST_CLIENT_ID,
      client_secret: ANILIST_CLIENT_SECRET,
      redirect_uri: ANILIST_REDIRECT_URI,
      code
    })
  });
  if (!response.ok) {
    const text = await response.text();
    console.error("AniList token error:", response.status, text);
    throw new Error("Failed to exchange code for token");
  }
  const data = await response.json();
  if (!data.access_token) {
    throw new Error("No access_token in token response");
  }
  return data.access_token;
}
function handleOAuthCallback(url) {
  try {
    console.log("Processing OAuth URL:", url);
    const urlObj = new URL(url);
    const hash = urlObj.hash.substring(1);
    const params = new URLSearchParams(hash);
    const accessToken = params.get("access_token");
    console.log("Extracted Token:", accessToken ? `${accessToken.substring(0, 20)}...` : "null");
    if (accessToken) {
      store.set("accessToken", accessToken);
      const windows = BrowserWindow.getAllWindows();
      windows.forEach((win) => {
        win.webContents.send("auth:token-received", accessToken);
      });
      console.log("Token stored and sent to renderer");
    } else {
      console.warn("No access token found in OAuth callback URL");
    }
  } catch (error) {
    console.error("Error handling OAuth callback:", error);
  }
}
function createWindow() {
  const window = new BrowserWindow({
    width: 1400,
    height: 900,
    minWidth: 1200,
    minHeight: 700,
    frame: false,
    transparent: true,
    backgroundColor: "#05050500",
    titleBarStyle: "hidden",
    // Ensure window animations work properly
    skipTaskbar: false,
    webPreferences: {
      preload: join(__dirname, "../preload/preload.mjs"),
      nodeIntegration: false,
      contextIsolation: true,
      sandbox: false
      // <--- Critical: Allows preload script to use import statements
    }
  });
  mainWindow = window;
  window.on("maximize", () => {
    window.webContents.send("window-maximized", true);
  });
  window.on("unmaximize", () => {
    window.webContents.send("window-unmaximized", false);
  });
  if (process.env.NODE_ENV === "development") {
    window.loadURL("http://localhost:5173");
    window.webContents.openDevTools();
  } else {
    window.loadFile(join(__dirname, "../renderer/index.html"));
  }
  ipcMain.handle("auth:open-oauth-window", async (_, authUrl) => {
    return new Promise((resolve2, reject) => {
      const authWindow = new BrowserWindow({
        width: 500,
        height: 700,
        show: true,
        modal: true,
        parent: mainWindow ?? void 0,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true
        }
      });
      let resolved = false;
      const handleUrl = async (url) => {
        if (!url.startsWith("anivault://")) return;
        try {
          const urlObj = new URL(url);
          const code = urlObj.searchParams.get("code");
          if (!code) {
            throw new Error("No code in callback URL");
          }
          const accessToken = await exchangeCodeForToken(code);
          store.set("accessToken", accessToken);
          resolved = true;
          resolve2(accessToken);
          authWindow.close();
        } catch (err) {
          console.error("OAuth callback error:", err);
          if (!resolved) {
            resolved = true;
            reject(err);
            authWindow.close();
          }
        }
      };
      authWindow.webContents.on("did-navigate", (_event, url) => {
        void handleUrl(url);
      });
      authWindow.webContents.on("will-redirect", (event, url) => {
        if (url.startsWith("anivault://")) {
          event.preventDefault();
          void handleUrl(url);
        }
      });
      authWindow.on("closed", () => {
        if (!resolved) {
          resolved = true;
          resolve2(null);
        }
      });
      authWindow.loadURL(authUrl);
    });
  });
  ipcMain.handle("auth:get-token", () => {
    return store.get("accessToken");
  });
  ipcMain.handle("auth:logout", () => {
    store.delete("accessToken");
    store.delete("user");
  });
  ipcMain.handle("auth:open-external", async (_, url) => {
    await shell.openExternal(url);
  });
  ipcMain.handle("license:get-key", () => {
    return store.get("licenseKey");
  });
  ipcMain.handle("license:store-key", (_, key) => {
    store.set("licenseKey", key);
  });
  ipcMain.handle("license:validate", async (_, key) => {
    try {
      console.log("Validating license key:", key);
      const response = await fetch("https://api.lemonsqueezy.com/v1/licenses/activate", {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          license_key: key,
          instance_name: "AniVault Desktop"
        })
      });
      const data = await response.json();
      if (data.activated && data.license_key?.status === "active") {
        store.set("licenseKey", key);
        return { success: true };
      }
      return { success: false, error: data.error || "Invalid key" };
    } catch (error) {
      console.error("License validation failed:", error);
      return { success: false, error: "Network error" };
    }
  });
  ipcMain.handle("dialog:select-folder", async () => {
    const result = await dialog.showOpenDialog({
      properties: ["openDirectory"]
    });
    if (result.canceled || result.filePaths.length === 0) {
      return null;
    }
    return result.filePaths[0];
  });
  ipcMain.handle("organizer:scan", async (_event, args) => {
    const { sourceDir, targetRoot, library } = args;
    if (!sourceDir || !targetRoot) {
      throw new Error("sourceDir and targetRoot are required");
    }
    return buildOrganizePlan(sourceDir, targetRoot, library || []);
  });
  ipcMain.handle("organizer:apply", async (_event, args) => {
    await applyOrganizePlan(args.plan || [], args.logPath);
  });
  ipcMain.handle("presence:update-config", (_event, config) => {
    presenceConfig = { ...presenceConfig, ...config };
  });
  ipcMain.handle("presence:update-now", async (_event, ctx) => {
    if (!presenceConfig.enabled) return;
    if (!discordClient) return;
    if (presenceClearTimeout) {
      clearTimeout(presenceClearTimeout);
      presenceClearTimeout = null;
    }
    try {
      const activity = buildDiscordActivity(ctx, ctx.isPro);
      if (!activity) return;
      await discordClient.setActivity(activity);
      presenceClearTimeout = setTimeout(() => {
        clearDiscordPresence();
        presenceClearTimeout = null;
      }, PRESENCE_CLEAR_DELAY);
    } catch (err) {
      console.error("Failed to update Discord presence:", err);
    }
  });
  ipcMain.handle("anilist:graphql", async (_event, payload) => {
    const headers = {
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    if (payload?.accessToken) {
      headers["Authorization"] = `Bearer ${payload.accessToken}`;
    }
    const response = await fetch("https://graphql.anilist.co", {
      method: "POST",
      headers,
      body: JSON.stringify({
        query: payload?.query,
        variables: payload?.variables
      })
    });
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`AniList API error (${response.status}): ${errorBody}`);
    }
    const data = await response.json();
    if (data.errors) {
      throw new Error(`GraphQL errors: ${JSON.stringify(data.errors)}`);
    }
    return data;
  });
}
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.quit();
} else {
  app.on("second-instance", (_, commandLine) => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
    const url = commandLine.find((arg) => arg.startsWith("anivault://"));
    if (url) {
      console.log("Deep link received via second-instance:", url);
      handleOAuthCallback(url);
    }
  });
  app.whenReady().then(async () => {
    registerWindowHandlers();
    if (process.defaultApp) {
      if (process.argv.length >= 2) {
        app.setAsDefaultProtocolClient("anivault", process.execPath, [resolve(process.argv[1])]);
      }
    } else {
      app.setAsDefaultProtocolClient("anivault");
    }
    createWindow();
    app.on("activate", () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
      }
    });
    await initDiscordRPC();
    startPolling(async (data) => {
      await updateDiscordPresence(data.title, data.episode);
    });
    startExtensionServer();
    app.on("open-url", (event, url) => {
      event.preventDefault();
      console.log("Deep link received via open-url:", url);
      handleOAuthCallback(url);
    });
  });
}
app.on("window-all-closed", async () => {
  if (process.platform !== "darwin") {
    stopWatcher();
    stopExtensionServer();
    await clearDiscordPresence();
    if (discordClient) {
      try {
        await discordClient.destroy();
      } catch (error) {
        console.error("Error destroying Discord client:", error);
      }
      discordClient = null;
    }
    app.quit();
  }
});
app.on("before-quit", async () => {
  stopWatcher();
  stopExtensionServer();
  await clearDiscordPresence();
  if (discordClient) {
    try {
      await discordClient.destroy();
    } catch (error) {
      console.error("Error destroying Discord client:", error);
    }
    discordClient = null;
  }
});


========================================

=== apps\desktop\out\preload\preload.mjs ===

import { contextBridge, ipcRenderer } from "electron";
contextBridge.exposeInMainWorld("electron", {
  minimize: () => ipcRenderer.invoke("window-minimize"),
  maximize: () => ipcRenderer.invoke("window-maximize"),
  close: () => ipcRenderer.invoke("window-close"),
  isMaximized: () => ipcRenderer.invoke("window-is-maximized"),
  onMaximize: (callback) => {
    ipcRenderer.on("window-maximized", (_, isMaximized) => callback(isMaximized));
  },
  onUnmaximize: (callback) => {
    ipcRenderer.on("window-unmaximized", (_, isMaximized) => callback(isMaximized));
  },
  // Auth IPC
  auth: {
    openExternal: (url) => ipcRenderer.invoke("auth:open-external", url),
    onTokenReceived: (callback) => {
      ipcRenderer.on("auth:token-received", (_, token) => callback(token));
    },
    removeTokenListener: () => {
      ipcRenderer.removeAllListeners("auth:token-received");
    },
    getToken: () => ipcRenderer.invoke("auth:get-token"),
    logout: () => ipcRenderer.invoke("auth:logout"),
    // Legacy method (kept for backward compatibility)
    openOAuthWindow: (url) => ipcRenderer.invoke("auth:open-oauth-window", url)
  },
  // License IPC
  license: {
    getKey: () => ipcRenderer.invoke("license:get-key"),
    storeKey: (key) => ipcRenderer.invoke("license:store-key", key),
    validate: (key) => ipcRenderer.invoke("license:validate", key)
  },
  // AniList GraphQL proxy
  anilist: {
    graphql: (payload) => ipcRenderer.invoke("anilist:graphql", payload)
  },
  // Tracking IPC
  tracking: {
    onUpdate: (callback) => {
      ipcRenderer.on("tracking:update", (_, data) => callback(data));
      ipcRenderer.on("tracking:detected", (_, data) => callback(data));
    },
    removeListener: () => {
      ipcRenderer.removeAllListeners("tracking:update");
      ipcRenderer.removeAllListeners("tracking:detected");
    }
  },
  // Presence IPC
  presence: {
    updateConfig: (config) => ipcRenderer.invoke("presence:update-config", config),
    updateNow: (ctx) => ipcRenderer.invoke("presence:update-now", ctx)
  },
  // Organizer IPC
  organizer: {
    scan: (sourceDir, targetRoot, library) => ipcRenderer.invoke("organizer:scan", { sourceDir, targetRoot, library }),
    apply: (plan, logPath) => ipcRenderer.invoke("organizer:apply", { plan, logPath })
  },
  // Dialog IPC
  dialog: {
    selectFolder: () => ipcRenderer.invoke("dialog:select-folder")
  }
});


========================================

=== apps\desktop\package.json ===

{
  "name": "desktop",
  "version": "0.1.0",
  "description": "AniVault Desktop App",
  "type": "module",
  "main": "./out/main/main.js",
  "scripts": {
    "dev": "electron-vite dev",
    "prebuild": "electron-vite build",
    "build": "electron-builder --win --x64",
    "preview": "electron-vite preview"
  },
  "dependencies": {
    "@anivault/shared": "workspace:*",
    "@anivault/ui": "workspace:*",
    "electron-builder": "^24.13.3",
    "electron-log": "^5.4.3",
    "electron-updater": "^6.6.2",
    "discord-rpc": "^4.0.1",
    "electron": "^39.2.6",
    "electron-store": "^8.1.0",
    "framer-motion": "^10.16.16",
    "lucide-react": "^0.303.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "recharts": "^3.5.1",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "electron-vite": "^2.0.0",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3",
    "vite": "^5.0.8"
  },
  "build": {
    "productName": "AniVault",
    "appId": "com.anivault.app",
    "directories": {
      "output": "dist_electron"
    },
    "files": [
      "build/**/*",
      "dist/**/*",
      "node_modules/**/*",
      "package.json"
    ],
    "win": {
      "target": [
        "nsis",
        "portable"
      ],
      "signingHashAlgorithms": [
        "sha256"
      ]
    },
    "nsis": {
      "oneClick": false,
      "perMachine": false,
      "allowElevation": true,
      "allowToChangeInstallationDirectory": true,
      "createDesktopShortcut": true,
      "createStartMenuShortcut": true
    },
    "publish": [
      {
        "provider": "github",
        "owner": "anivault",
        "repo": "AniVault"
      }
    ]
  }
}


========================================

=== apps\desktop\postcss.config.js ===

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



========================================

=== apps\desktop\src\main\main.ts ===

import { app, BrowserWindow, ipcMain, shell, dialog } from 'electron'
import { join, resolve } from 'path'
import { createServer, IncomingMessage, ServerResponse } from 'http'
// @ts-ignore - discord-rpc doesn't have type definitions
import pkg from 'discord-rpc'
const { Client, register } = pkg
import { autoUpdater } from 'electron-updater'
import log from 'electron-log'
import store from './store'
import { startPolling, stopWatcher } from './watcher'
import { buildOrganizePlan, applyOrganizePlan, type OrganizePlanItem } from './organizer'
import type { Anime, ExtensionEpisodeEvent } from '@anivault/shared'

// Extension HTTP server configuration
const EXTENSION_SERVER_PORT = 35847
const EXTENSION_ENDPOINT = '/extension-event'
let extensionServer: ReturnType<typeof createServer> | null = null

type DiscordPresenceMode = 'minimal' | 'stats' | 'weeb'

interface DiscordPresenceConfig {
  enabled: boolean
  mode: DiscordPresenceMode
  useMood: boolean
  showButtons: boolean
}

interface DiscordPresenceContext {
  title: string
  episode: number
  totalEpisodes?: number
  episodesThisSession?: number
  episodesToday?: number
  moodLabel?: string
  moodEmoji?: string
  themeId?: string
}

let mainWindow: BrowserWindow | null = null

// Auto-update events
autoUpdater.on('update-available', (info) => {
  log.info('Update available', info)
  mainWindow?.webContents.send('update:available', info)
})

autoUpdater.on('update-downloaded', (info) => {
  log.info('Update downloaded', info)
  mainWindow?.webContents.send('update:downloaded', info)
})

// Logging for auto-updates
autoUpdater.logger = log
// @ts-ignore - electron-log transport typing
autoUpdater.logger.transports.file.level = 'info'

// Discord RPC client
const DISCORD_CLIENT_ID = import.meta.env.DISCORD_CLIENT_ID || '1447800723512361040'
let discordClient: any = null
let presenceConfig: DiscordPresenceConfig = {
  enabled: true,
  mode: 'minimal',
  useMood: true,
  showButtons: true,
}
let presenceClearTimeout: NodeJS.Timeout | null = null
const PRESENCE_CLEAR_DELAY = 30000 // Clear presence after 30 seconds of no activity
const PRESENCE_CLEAR_SHORT_DELAY = 10000 // Clear presence after 10 seconds when explicitly cleared

function buildDiscordActivity(ctx: DiscordPresenceContext, isPro: boolean): any | null {
  if (!ctx.title) return null

  const {
    title,
    episode,
    totalEpisodes,
    episodesThisSession,
    episodesToday,
    moodLabel,
    moodEmoji,
    themeId,
  } = ctx

  let largeImageKey = 'anivault-logo'
  if (isPro && themeId) {
    if (themeId.includes('neon')) largeImageKey = 'anivault-neon'
    else if (themeId.includes('midnight')) largeImageKey = 'anivault-midnight'
  }

  let details = `Watching ${title}`
  let state = `Episode ${episode}${totalEpisodes ? ` / ${totalEpisodes}` : ''}`
  const buttons: Array<{ label: string; url: string }> = []

  if (!isPro) {
    return {
      details,
      state,
      largeImageKey,
      instance: false,
    }
  }

  const mode = presenceConfig.mode

  if (mode === 'minimal') {
    details = `Watching ${title}`
    state = `Ep ${episode}${totalEpisodes ? ` / ${totalEpisodes}` : ''}`
  } else if (mode === 'stats') {
    const parts: string[] = []
    parts.push(`Ep ${episode}${totalEpisodes ? `/${totalEpisodes}` : ''}`)
    if (typeof episodesThisSession === 'number' && episodesThisSession > 0) {
      parts.push(`${episodesThisSession} eps this session`)
    }
    if (typeof episodesToday === 'number' && episodesToday > 0) {
      parts.push(`${episodesToday} today`)
    }
    details = `Bingeing ${title}`
    state = parts.join(' â€¢ ')
  } else if (mode === 'weeb') {
    const moodText =
      presenceConfig.useMood && moodLabel
        ? `${moodEmoji ?? ''} ${moodLabel}`.trim()
        : 'Anime session'

    const parts: string[] = []
    parts.push(`Ep ${episode}${totalEpisodes ? `/${totalEpisodes}` : ''}`)
    if (typeof episodesThisSession === 'number' && episodesThisSession > 0) {
      parts.push(`${episodesThisSession} eps this session`)
    }

    details = moodText
    state = `${title} â€” ${parts.join(' â€¢ ')}`
  }

  if (presenceConfig.showButtons) {
    buttons.push({
      label: 'View on AniList',
      url: 'https://anilist.co/',
    })
    buttons.push({
      label: 'Get AniVault',
      url: 'https://your-anivault-website-url.com',
    })
  }

  const activity: any = {
    details,
    state,
    largeImageKey,
    instance: false,
  }

  if (buttons.length > 0) {
    activity.buttons = buttons
  }

  return activity
}

/**
 * Initialize Discord RPC client
 */
async function initDiscordRPC() {
  try {
    // Register the Discord client ID
    register(DISCORD_CLIENT_ID)
    
    discordClient = new Client({ transport: 'ipc' })
    
    await discordClient.connect(DISCORD_CLIENT_ID)
    console.log('Discord RPC connected')
    
    // Set initial presence
    await discordClient.setActivity({
      details: 'AniVault',
      state: 'Ready to track anime',
      largeImageKey: 'logo',        // <--- This must match the Asset Name in Discord Portal
      largeImageText: 'AniVault',   // Tooltip when hovering over the image
    })
  } catch (error) {
    console.error('Failed to initialize Discord RPC:', error)
    discordClient = null
  }
}

/**
 * Update Discord presence with current anime episode
 */
async function updateDiscordPresence(title: string, episode: number) {
  if (!discordClient) {
    return
  }

  // Clear any existing timeout
  if (presenceClearTimeout) {
    clearTimeout(presenceClearTimeout)
    presenceClearTimeout = null
  }

  try {
    const activity = buildDiscordActivity(
      {
        title,
        episode,
      },
      false
    )
    if (!activity) return
    await discordClient.setActivity(activity)

    // Set timeout to revert to default presence after inactivity
    presenceClearTimeout = setTimeout(() => {
      setDefaultDiscordPresence()
      presenceClearTimeout = null
    }, PRESENCE_CLEAR_DELAY)
  } catch (error) {
    console.error('Failed to update Discord presence:', error)
  }
}

/**
 * Schedule Discord presence to revert to default after inactivity
 * This is called when tracking stops or no activity is detected
 */
function schedulePresenceClear() {
  // Clear any existing timeout
  if (presenceClearTimeout) {
    clearTimeout(presenceClearTimeout)
    presenceClearTimeout = null
  }

  // Immediately revert to default presence when explicitly cleared
  setDefaultDiscordPresence()
}

/**
 * Set Discord presence to default "AniVault ready to track anime"
 */
async function setDefaultDiscordPresence() {
  if (!discordClient) {
    return
  }

  // Clear any pending timeout
  if (presenceClearTimeout) {
    clearTimeout(presenceClearTimeout)
    presenceClearTimeout = null
  }

  try {
    await discordClient.setActivity({
      details: 'AniVault',
      state: 'Ready to track anime',
      largeImageKey: 'logo',
      largeImageText: 'AniVault',
    })
  } catch (error) {
    console.error('Failed to set default Discord presence:', error)
  }
}

/**
 * Clear Discord presence (legacy - now sets to default instead)
 */
async function clearDiscordPresence() {
  await setDefaultDiscordPresence()
}

// --- WINDOW CONTROL HANDLERS (Registered once, outside createWindow) ---
// These handlers need to be registered before the window is created
// so they're available immediately when the renderer process loads
let handlersRegistered = false

function registerWindowHandlers() {
  if (handlersRegistered) return

  ipcMain.handle('window-minimize', () => {
    if (mainWindow) {
      if (!mainWindow.isVisible()) mainWindow.show() // ensure visible so Windows animation plays
      mainWindow.minimize()
    }
  })

  ipcMain.handle('window-maximize', () => {
    if (!mainWindow) return

    const wasMaximized = mainWindow.isMaximized()

    if (wasMaximized) {
      mainWindow.unmaximize()
      mainWindow.webContents.send('window-unmaximized', false)
    } else {
      mainWindow.maximize()
      mainWindow.webContents.send('window-maximized', true)
    }
  })

  ipcMain.handle('window-close', () => {
    if (mainWindow) mainWindow.close()
  })

  ipcMain.handle('window-is-maximized', () => {
    return mainWindow?.isMaximized() ?? false
  })

  handlersRegistered = true
}

/**
 * Handle extension episode completion events
 */
function handleExtensionEpisodeComplete(event: {
  platform: 'crunchyroll' | 'netflix' | 'zoro' | 'nineanime' | 'animepahe' | 'generic'
  title: string
  overallEpisode: number | null
  seasonNumber: number | null
  seasonEpisode: number | null
  url: string
  watchedSeconds: number
  durationSeconds: number
  progress: number
  completedAt: string
}) {
  console.log('[AniVault] Desktop received extension completion:', {
    title: event.title,
    platform: event.platform,
    overallEpisode: event.overallEpisode,
    seasonNumber: event.seasonNumber,
    seasonEpisode: event.seasonEpisode,
    progress: event.progress,
    watchedSeconds: event.watchedSeconds,
    durationSeconds: event.durationSeconds,
  })
  // Convert to the format expected by the renderer
  // Use overallEpisode if available, otherwise seasonEpisode
  const episode = event.overallEpisode ?? event.seasonEpisode ?? null

  if (episode === null) {
    console.warn('[AniVault] Extension event missing episode number:', event)
    return
  }

  // Forward to renderer process via IPC with season info
  const browserWindows = BrowserWindow.getAllWindows()
  browserWindows.forEach((win) => {
    win.webContents.send('tracking:detected', {
      title: event.title,
      episode: episode,
      overallEpisode: event.overallEpisode,
      seasonNumber: event.seasonNumber,
      seasonEpisode: event.seasonEpisode,
      source: 'extension',
      platform: event.platform,
    })
  })

  // Also update Discord presence if applicable
  updateDiscordPresence(event.title, episode)
}

/**
 * Start HTTP server for extension communication
 */
function startExtensionServer() {
  if (extensionServer) {
    return // Already started
  }

  extensionServer = createServer((req: IncomingMessage, res: ServerResponse) => {
    // CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*')
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS, GET')
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type')

    // Handle OPTIONS (preflight)
    if (req.method === 'OPTIONS') {
      res.writeHead(200)
      res.end()
      return
    }

    // Handle clear detection endpoint (both POST and GET for compatibility)
    if ((req.method === 'POST' || req.method === 'GET') && req.url === `${EXTENSION_ENDPOINT}/clear`) {
      // Extension is clearing detection - schedule Discord presence clear
      schedulePresenceClear()
      res.writeHead(200, { 'Content-Type': 'application/json' })
      res.end(JSON.stringify({ ok: true }))
      return
    }

    // Only handle POST to the extension endpoint
    if (req.method === 'POST' && req.url === EXTENSION_ENDPOINT) {
      let body = ''

      req.on('data', (chunk) => {
        body += chunk.toString()
      })

      req.on('end', () => {
        try {
          const event = JSON.parse(body) as ExtensionEpisodeEvent

          // Validate required fields
          if (event.title && event.platform) {
            console.log(
              `[AniVault] Extension event from ${event.platform}: ${event.title} (overall ${event.overallEpisode ?? '?'} / S${event.seasonNumber ?? '?'} E${event.seasonEpisode ?? '?'})`
            )

            // Forward full payload to renderer(s)
            const browserWindows = BrowserWindow.getAllWindows()
            browserWindows.forEach((win) => {
              const episodeForLegacy = event.overallEpisode ?? event.seasonEpisode ?? null
              win.webContents.send('tracking:detected', {
                platform: event.platform,
                title: event.title,
                // Legacy episode field for existing renderer handlers
                episode: episodeForLegacy,
                overallEpisode: event.overallEpisode ?? null,
                seasonNumber: event.seasonNumber ?? null,
                seasonEpisode: event.seasonEpisode ?? null,
                url: event.url ?? null,
                watchedSeconds: event.watchedSeconds ?? null,
                durationSeconds: event.durationSeconds ?? null,
                progress: event.progress ?? null,
                completedAt: event.completedAt ?? new Date().toISOString(),
                source: 'extension',
              })
            })

            // Update Discord presence using the best available episode number
            const presenceEpisode = event.overallEpisode ?? event.seasonEpisode ?? null
            if (presenceEpisode !== null) {
              updateDiscordPresence(event.title, presenceEpisode)
            }

            res.writeHead(200, { 'Content-Type': 'application/json' })
            res.end(JSON.stringify({ ok: true }))
          } else {
            res.writeHead(400, { 'Content-Type': 'application/json' })
            res.end(JSON.stringify({ ok: false, error: 'Invalid event data' }))
          }
        } catch (error) {
          console.error('[AniVault] Error parsing extension event:', error)
          res.writeHead(400, { 'Content-Type': 'application/json' })
          res.end(JSON.stringify({ ok: false, error: 'Invalid JSON' }))
        }
      })
    } else {
      res.writeHead(404)
      res.end()
    }
  })

  extensionServer.listen(EXTENSION_SERVER_PORT, '127.0.0.1', () => {
    console.log(`[AniVault] Extension server listening on http://127.0.0.1:${EXTENSION_SERVER_PORT}`)
  })

  extensionServer.on('error', (error: NodeJS.ErrnoException) => {
    if (error.code === 'EADDRINUSE') {
      console.warn(`[AniVault] Extension server port ${EXTENSION_SERVER_PORT} is already in use`)
    } else {
      console.error('[AniVault] Extension server error:', error)
    }
  })
}

/**
 * Stop extension HTTP server
 */
function stopExtensionServer() {
  if (extensionServer) {
    extensionServer.close()
    extensionServer = null
    console.log('[AniVault] Extension server stopped')
  }
}

// AniList OAuth configuration
const ANILIST_CLIENT_ID = import.meta.env.VITE_ANILIST_CLIENT_ID || '32987'
const ANILIST_CLIENT_SECRET = import.meta.env.ANILIST_CLIENT_SECRET || 'YOUR_FALLBACK_SECRET'
const ANILIST_REDIRECT_URI = import.meta.env.VITE_ANILIST_REDIRECT_URI || 'anivault://auth/callback'

/**
 * Exchanges an authorization code for an access token
 */
async function exchangeCodeForToken(code: string): Promise<string> {
  const response = await fetch('https://anilist.co/api/v2/oauth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      grant_type: 'authorization_code',
      client_id: ANILIST_CLIENT_ID,
      client_secret: ANILIST_CLIENT_SECRET,
      redirect_uri: ANILIST_REDIRECT_URI,
      code,
    }),
  })

  if (!response.ok) {
    const text = await response.text()
    console.error('AniList token error:', response.status, text)
    throw new Error('Failed to exchange code for token')
  }

  const data = await response.json() as { access_token: string }

  if (!data.access_token) {
    throw new Error('No access_token in token response')
  }

  return data.access_token
}

function handleOAuthCallback(url: string) {
  // Extract access token from URL fragment
  try {
    console.log('Processing OAuth URL:', url) // Debug Log 1

    const urlObj = new URL(url)
    const hash = urlObj.hash.substring(1) // Remove #
    const params = new URLSearchParams(hash)
    const accessToken = params.get('access_token')

    console.log('Extracted Token:', accessToken ? `${accessToken.substring(0, 20)}...` : 'null') // Debug Log 2 (truncated for security)

    if (accessToken) {
      // Store the token
      store.set('accessToken', accessToken)
      // Send token to renderer via IPC
      const windows = BrowserWindow.getAllWindows()
      windows.forEach(win => {
        win.webContents.send('auth:token-received', accessToken)
      })
      console.log('Token stored and sent to renderer')
    } else {
      console.warn('No access token found in OAuth callback URL')
    }
  } catch (error) {
    console.error('Error handling OAuth callback:', error)
  }
}

function createWindow() {
  const window = new BrowserWindow({
    width: 1400,
    height: 900,
    minWidth: 1200,
    minHeight: 700,
    frame: false,
    transparent: true,
    backgroundColor: '#05050500',
    titleBarStyle: 'hidden',
    // Ensure window animations work properly
    skipTaskbar: false,
    webPreferences: {
      preload: join(__dirname, '../preload/preload.mjs'),
      nodeIntegration: false,
      contextIsolation: true,
      sandbox: false, // <--- Critical: Allows preload script to use import statements
    },
  })

  mainWindow = window

  // Listen for window state changes and notify renderer
  window.on('maximize', () => {
    window.webContents.send('window-maximized', true)
  })

  window.on('unmaximize', () => {
    window.webContents.send('window-unmaximized', false)
  })

  if (process.env.NODE_ENV === 'development') {
    window.loadURL('http://localhost:5173')
    window.webContents.openDevTools()
  } else {
    window.loadFile(join(__dirname, '../renderer/index.html'))
  }

  // Auth handlers
  ipcMain.handle('auth:open-oauth-window', async (_, authUrl: string) => {
    return new Promise<string | null>((resolve, reject) => {
      const authWindow = new BrowserWindow({
        width: 500,
        height: 700,
        show: true,
        modal: true,
        parent: mainWindow ?? undefined,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true,
        },
      })

      let resolved = false

      const handleUrl = async (url: string) => {
        if (!url.startsWith('anivault://')) return

        try {
          const urlObj = new URL(url)
          const code = urlObj.searchParams.get('code') // <-- auth code

          if (!code) {
            throw new Error('No code in callback URL')
          }

          const accessToken = await exchangeCodeForToken(code)

          store.set('accessToken', accessToken)
          resolved = true
          resolve(accessToken)
          authWindow.close()
        } catch (err) {
          console.error('OAuth callback error:', err)
          if (!resolved) {
            resolved = true
            reject(err)
            authWindow.close()
          }
        }
      }

      authWindow.webContents.on('did-navigate', (_event, url) => {
        void handleUrl(url)
      })

      authWindow.webContents.on('will-redirect', (event, url) => {
        // intercept custom protocol redirects
        if (url.startsWith('anivault://')) {
          event.preventDefault()
          void handleUrl(url)
        }
      })

      authWindow.on('closed', () => {
        if (!resolved) {
          resolved = true
          resolve(null) // user closed window
        }
      })

      authWindow.loadURL(authUrl)
      // Optional: debug what AniList is actually returning
      // authWindow.webContents.openDevTools({ mode: 'detach' })
    })
  })

  ipcMain.handle('auth:get-token', () => {
    return store.get('accessToken')
  })

  ipcMain.handle('auth:logout', () => {
    store.delete('accessToken')
    store.delete('user')
  })

  // Open external browser for OAuth
  ipcMain.handle('auth:open-external', async (_, url: string) => {
    await shell.openExternal(url)
  })

  // License handlers
  ipcMain.handle('license:get-key', () => {
    return store.get('licenseKey')
  })

  ipcMain.handle('license:store-key', (_, key: string) => {
    store.set('licenseKey', key)
  })

  ipcMain.handle('license:validate', async (_, key: string) => {
    try {
      console.log('Validating license key:', key)

      const response = await fetch('https://api.lemonsqueezy.com/v1/licenses/activate', {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
          license_key: key,
          instance_name: 'AniVault Desktop',
        }),
      })

      const data = await response.json()

      // Check if activated
      if (data.activated && data.license_key?.status === 'active') {
        store.set('licenseKey', key)
        return { success: true }
      }

      return { success: false, error: data.error || 'Invalid key' }
    } catch (error) {
      console.error('License validation failed:', error)
      return { success: false, error: 'Network error' }
    }
  })

  ipcMain.handle('app:check-for-updates', async () => {
    try {
      const res = await autoUpdater.checkForUpdates()
      return res
    } catch (error: any) {
      log.warn('app:check-for-updates failed', error)
      return { error: true, message: error?.message ?? 'Unknown error' }
    }
  })

  ipcMain.handle('dialog:select-folder', async () => {
    const result = await dialog.showOpenDialog({
      properties: ['openDirectory'],
    })

    if (result.canceled || result.filePaths.length === 0) {
      return null
    }

    return result.filePaths[0]
  })

  // Organizer IPC
  ipcMain.handle('organizer:scan', async (_event, args: { sourceDir: string; targetRoot: string; library: Anime[] }) => {
    const { sourceDir, targetRoot, library } = args
    if (!sourceDir || !targetRoot) {
      throw new Error('sourceDir and targetRoot are required')
    }
    return buildOrganizePlan(sourceDir, targetRoot, library || [])
  })

  ipcMain.handle('organizer:apply', async (_event, args: { plan: OrganizePlanItem[]; logPath: string }) => {
    await applyOrganizePlan(args.plan || [], args.logPath)
  })

  // Presence configuration update (Pro settings)
  ipcMain.handle('presence:update-config', (_event, config: Partial<DiscordPresenceConfig>) => {
    presenceConfig = { ...presenceConfig, ...config }
  })

  // Presence context update
  ipcMain.handle('presence:update-now', async (_event, ctx: DiscordPresenceContext & { isPro: boolean }) => {
    if (!presenceConfig.enabled) return
    if (!discordClient) return

    // Clear any existing timeout
    if (presenceClearTimeout) {
      clearTimeout(presenceClearTimeout)
      presenceClearTimeout = null
    }

    try {
      const activity = buildDiscordActivity(ctx, ctx.isPro)
      if (!activity) return
      await discordClient.setActivity(activity)

      // Set timeout to clear presence after inactivity
      presenceClearTimeout = setTimeout(() => {
        clearDiscordPresence()
        presenceClearTimeout = null
      }, PRESENCE_CLEAR_DELAY)
    } catch (err) {
      console.error('Failed to update Discord presence:', err)
    }
  })

  // AniList GraphQL proxy (avoids renderer CORS issues)
  ipcMain.handle('anilist:graphql', async (_event, payload: { query: string; variables?: Record<string, unknown>; accessToken?: string | null }) => {
    const headers: HeadersInit = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    }

    if (payload?.accessToken) {
      headers['Authorization'] = `Bearer ${payload.accessToken}`
    }

    const response = await fetch('https://graphql.anilist.co', {
      method: 'POST',
      headers,
      body: JSON.stringify({
        query: payload?.query,
        variables: payload?.variables,
      }),
    })

    if (!response.ok) {
      const errorBody = await response.text()
      throw new Error(`AniList API error (${response.status}): ${errorBody}`)
    }

    const data = await response.json()
    if (data.errors) {
      throw new Error(`GraphQL errors: ${JSON.stringify(data.errors)}`)
    }

    return data
  })
}

// 1. Request the "Single Instance Lock" immediately
const gotTheLock = app.requestSingleInstanceLock()

if (!gotTheLock) {
  // If we didn't get the lock, it means another instance is running.
  // Quit this new instance immediately.
  app.quit()
} else {
  // We got the lock! We are the primary instance.

  // 2. Listen for the second instance trying to open (This handles the Protocol URL)
  app.on('second-instance', (_, commandLine) => {
    // Someone tried to run a second instance, we should focus our window.
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore()
      mainWindow.focus()
    }

    // Windows passes the URL as a command line argument
    const url = commandLine.find(arg => arg.startsWith('anivault://'))
    if (url) {
      console.log('Deep link received via second-instance:', url) // Debug log
      handleOAuthCallback(url)
    }
  })

  // 3. Initialize the app normally
  app.whenReady().then(async () => {
    // Register window control handlers BEFORE creating window
    registerWindowHandlers()
    
    // Register custom protocol
    if (process.defaultApp) {
      if (process.argv.length >= 2) {
        app.setAsDefaultProtocolClient('anivault', process.execPath, [resolve(process.argv[1])])
      }
    } else {
      app.setAsDefaultProtocolClient('anivault')
    }

    createWindow()

    // Kick off auto-update check shortly after launch
    setTimeout(() => {
      try {
        autoUpdater.checkForUpdatesAndNotify()
      } catch (err) {
        log.warn('autoUpdater check failed', err)
      }
    }, 5000)

    app.on('activate', () => {
      if (BrowserWindow.getAllWindows().length === 0) {
        createWindow()
      }
    })

    // Initialize Discord RPC (sets default "AniVault ready to track anime" presence)
    await initDiscordRPC()

    // Start media watcher
    startPolling(async (data) => {
      // Update Discord presence when episode is detected
      await updateDiscordPresence(data.title, data.episode)
    })

    // Start extension HTTP server
    startExtensionServer()

    // Handle macOS/Linux protocol URL (Open URL event)
    app.on('open-url', (event, url) => {
      event.preventDefault()
      console.log('Deep link received via open-url:', url) // Debug log
      handleOAuthCallback(url)
    })
  })
}



    app.on('window-all-closed', async () => {
      if (process.platform !== 'darwin') {
        stopWatcher()
        stopExtensionServer()
        await clearDiscordPresence()
        if (discordClient) {
          try {
            await discordClient.destroy()
          } catch (error) {
            console.error('Error destroying Discord client:', error)
          }
          discordClient = null
        }
        app.quit()
      }
    })

    app.on('before-quit', async () => {
      stopWatcher()
      stopExtensionServer()
      await clearDiscordPresence()
      if (discordClient) {
        try {
          await discordClient.destroy()
        } catch (error) {
          console.error('Error destroying Discord client:', error)
        }
        discordClient = null
      }
    })



========================================

=== apps\desktop\src\main\organizer.ts ===

import type { Anime } from '@anivault/shared'
import { promises as fs } from 'fs'
import path from 'path'
import { parseAnimeFilename } from './watcher'

export type OrganizeStatus = 'ready' | 'unmatched' | 'conflict'

export interface OrganizePlanItem {
  from: string
  to: string
  title: string | null
  episode: number | null
  matchedAnimeId?: string
  matchedAnimeTitle?: string
  season: number | null
  status: OrganizeStatus
}

const VIDEO_EXTENSIONS = new Set(['.mkv', '.mp4', '.avi', '.mov', '.flv', '.webm'])

export function sanitizeName(name: string): string {
  return name.replace(/[<>:"/\\|?*]+/g, '').trim()
}

function inferSeasonFromFilename(filename: string, episode: number | null): number {
  const lower = filename.toLowerCase()

  // Match S02, S2, [S02], etc.
  const sMatch = lower.match(/(?:^|[\s._\-])(s)(\d{1,2})(?:[^0-9]|$)/i)
  if (sMatch && sMatch[2]) {
    const n = parseInt(sMatch[2], 10)
    if (!Number.isNaN(n)) return n
  }

  // Match "season 20"
  const seasonMatch = lower.match(/season\s*(\d{1,2})/i)
  if (seasonMatch && seasonMatch[1]) {
    const n = parseInt(seasonMatch[1], 10)
    if (!Number.isNaN(n)) return n
  }

  // Default to Season 1 when no explicit hint
  return 1
}

async function collectVideoFiles(dir: string): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true })
  const files: string[] = []

  for (const entry of entries) {
    const full = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      const nested = await collectVideoFiles(full)
      files.push(...nested)
    } else if (entry.isFile()) {
      const ext = path.extname(entry.name).toLowerCase()
      if (VIDEO_EXTENSIONS.has(ext)) {
        files.push(full)
      }
    }
  }

  return files
}

function findMatchingAnime(parsedTitle: string | null, fileName: string, library: Anime[]): Anime | null {
  if (!parsedTitle) return null
  const normalizedParsed = parsedTitle.toLowerCase()

  const bestMatch = library.find((anime) => {
    const t = anime.title.toLowerCase()
    return t.includes(normalizedParsed) || normalizedParsed.includes(t)
  })

  return bestMatch ?? null
}

export async function buildOrganizePlan(
  sourceDir: string,
  targetRoot: string,
  library: Anime[]
): Promise<OrganizePlanItem[]> {
  const files = await collectVideoFiles(sourceDir)
  const plan: OrganizePlanItem[] = []

  for (const from of files) {
    const base = path.basename(from)
    const ext = path.extname(base)
    const nameWithoutExt = base.slice(0, -ext.length)

    const { title: parsedTitle, episode } = parseAnimeFilename(nameWithoutExt)

    const matchedAnime = parsedTitle ? findMatchingAnime(parsedTitle, nameWithoutExt, library) : null

    if (!matchedAnime || episode == null) {
      plan.push({
        from,
        to: from,
        title: parsedTitle,
        episode: episode ?? null,
        matchedAnimeId: matchedAnime?.id ?? undefined,
        matchedAnimeTitle: matchedAnime?.title ?? undefined,
        season: null,
        status: 'unmatched',
      })
      continue
    }

    const season = inferSeasonFromFilename(nameWithoutExt, episode)
    const safeTitle = sanitizeName(matchedAnime.title)
    const seasonFolder = `Season ${season}`

    const fileName = `${safeTitle} - Episode ${episode.toString().padStart(3, '0')}${ext}`
    const targetDir = path.join(targetRoot, safeTitle, seasonFolder)
    const to = path.join(targetDir, fileName)

    const status: OrganizeStatus = from.toLowerCase() === to.toLowerCase() ? 'unmatched' : 'ready'

    plan.push({
      from,
      to,
      title: parsedTitle,
      episode,
      matchedAnimeId: matchedAnime.id,
      matchedAnimeTitle: matchedAnime.title,
      season,
      status,
    })
  }

  const byTarget = new Map<string, number>()
  for (const item of plan) {
    if (!item.to) continue
    const key = item.to.toLowerCase()
    byTarget.set(key, (byTarget.get(key) ?? 0) + 1)
  }
  for (const item of plan) {
    const key = item.to.toLowerCase()
    if (byTarget.get(key)! > 1 && item.status === 'ready') {
      item.status = 'conflict'
    }
  }

  return plan
}

export async function applyOrganizePlan(plan: OrganizePlanItem[], logPath: string): Promise<void> {
  const operations = plan.filter((p) => p.status === 'ready' && p.from !== p.to)

  for (const op of operations) {
    const dir = path.dirname(op.to)
    await fs.mkdir(dir, { recursive: true })
  }

  for (const op of operations) {
    await fs.rename(op.from, op.to)
  }

  const log = {
    createdAt: new Date().toISOString(),
    operations: operations.map((op) => ({
      from: op.from,
      to: op.to,
      title: op.title,
      episode: op.episode,
      matchedAnimeId: op.matchedAnimeId,
      season: op.season,
    })),
  }

  try {
    const logDir = path.dirname(logPath)
    await fs.mkdir(logDir, { recursive: true })
    await fs.writeFile(logPath, JSON.stringify(log, null, 2), 'utf-8')
  } catch (error) {
    console.error('Failed to write organizer log file:', error)
  }
}



========================================

=== apps\desktop\src\main\store.ts ===

import Store from 'electron-store'

interface StoreSchema {
  accessToken: string | null
  licenseKey: string | null
  user: {
    id: string
    username: string
    avatar?: string
  } | null
}

const store = new Store<StoreSchema>({
  defaults: {
    accessToken: null,
    licenseKey: null,
    user: null,
  },
})

export default store



========================================

=== apps\desktop\src\main\watcher.ts ===

import { BrowserWindow } from 'electron'
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

/**
 * Smart anime filename parser
 * Extracts title and episode number from various filename formats
 */
export function parseAnimeFilename(filename: string): { title: string | null; episode: number | null } {
  // Remove file extension
  const nameWithoutExt = filename.replace(/\.[^.]*$/, '')
  
  // Try to extract episode number using various patterns
  const episodePatterns = [
    /[Ss](\d+)[Ee](\d+)/,                    // S01E01, S1E1
    /[Ee]p(?:isode)?\s*(\d+)/i,              // Ep1, Episode 1, ep 1
    /[Ee](\d+)(?:\s|$|\[|\(|v)/,              // E1, E01
    /\s-\s*(\d+)(?:\s|$|\[|\(|v)/,            // - 1, - 01
    /\[(\d+)\](?:\s|$)/,                      // [1], [01]
    /\((\d+)\)(?:\s|$)/,                      // (1), (01)
    /\s(\d+)(?:\s|$|\[|\(|v)/,                // Space followed by number
  ]

  let episode: number | null = null
  let title = nameWithoutExt

  // Try each pattern
  for (const pattern of episodePatterns) {
    const match = nameWithoutExt.match(pattern)
    if (match) {
      // For S01E01 format, use episode number (second group)
      if (pattern.source.includes('[Ss]') && match[2]) {
        episode = parseInt(match[2], 10)
        // Remove the season/episode part from title
        title = nameWithoutExt.replace(pattern, '').trim()
      } else if (match[1]) {
        episode = parseInt(match[1], 10)
        // Remove the episode part from title
        title = nameWithoutExt.replace(pattern, '').trim()
      }
      
      if (episode && !isNaN(episode)) {
        break
      }
    }
  }

  // Clean up title - remove common prefixes/suffixes
  title = title
    .replace(/^\[.*?\]\s*/, '')              // Remove [Release Group]
    .replace(/\s*\[.*?\]\s*$/, '')           // Remove trailing [tags]
    .replace(/\s*\(.*?\)\s*$/, '')           // Remove trailing (tags)
    .replace(/\s*-\s*$/, '')                 // Remove trailing dash
    .replace(/\s+/g, ' ')                     // Normalize whitespace
    .trim()

  // If we found an episode but title is empty or too short, use original filename
  if (episode && (!title || title.length < 2)) {
    title = nameWithoutExt.replace(/\[.*?\]/g, '').replace(/\(.*?\)/g, '').trim()
  }

  return {
    title: title || null,
    episode: episode && !isNaN(episode) ? episode : null,
  }
}

// Add any new .exe names to this list (lowercase)
const MEDIA_PLAYERS = [
  'vlc.exe',          // VLC Media Player
  'mpv.exe',          // MPV
  'mpc-hc.exe',       // Media Player Classic - Home Cinema
  'mpc-be.exe',       // Media Player Classic - Black Edition
  'potplayer.exe',    // PotPlayer
  'kodi.exe',         // Kodi
  'wmplayer.exe',     // Windows Media Player (Legacy)
  'kmplayer.exe',     // KMPlayer (New addition)
  'gom.exe',          // GOM Player (New addition)
  'plex.exe',         // Plex Media Player (New addition)
  'ffplay.exe'        // FFmpeg Play (New addition)
]

let watcherInterval: NodeJS.Timeout | null = null
let lastDetectedEpisode: { title: string; episode: number } | null = null

/**
 * Gets active window titles on Windows using tasklist
 */
async function getActiveWindows(): Promise<Array<{ title: string; process: string }>> {
  try {
    const { stdout, stderr } = await execAsync('tasklist /v /fo csv')

    if (!stdout || stdout.trim().length === 0) {
      if (process.env.NODE_ENV === 'development') {
        console.log('[Watcher] tasklist returned no stdout', { stderr })
      }
      return []
    }
    
    const windows: Array<{ title: string; process: string }> = []
    const lines = stdout.split('\n')
    
    // Skip header line (first line)
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim()
      if (!line) continue
      
      // Parse CSV line (simplified - real CSV parsing would be better)
      const parts = line.match(/"(.*?)"/g)
      if (parts && parts.length >= 9) {
        const processName = parts[0].replace(/"/g, '').toLowerCase()
        const windowTitle = parts[8].replace(/"/g, '').trim()
        
        // Skip if no window title or it's "N/A"
        if (!windowTitle || windowTitle === 'N/A' || windowTitle.length === 0) {
          continue
        }
        
        // Check if it's a media player
        const isMediaPlayer = MEDIA_PLAYERS.some((player) => processName.includes(player))
        
        if (isMediaPlayer && windowTitle) {
          windows.push({
            title: windowTitle,
            process: processName,
          })
        }
      }
    }
    
    return windows
  } catch (error: any) {
    // Handle cancellation/timeout gracefully - these are normal
    if (
      error?.code === 'ETIMEDOUT' || 
      error?.message?.includes('timeout') || 
      error?.message?.includes('cancelled') ||
      error?.message?.includes('Call cancelled') ||
      error?.code === 1
    ) {
      // Command was cancelled or timed out - this is normal, just return empty
      return []
    }
    
    // Only log unexpected errors in development
    if (process.env.NODE_ENV === 'development' && !error?.message?.includes('cancelled')) {
      console.error('Error getting active windows:', error?.message || error)
    }
    return []
  }
}

/**
 * Starts polling for active media player windows
 * Runs every 10 seconds
 */
export function startPolling(callback: (data: { title: string; episode: number }) => void) {
  if (watcherInterval) {
    return // Already running
  }

  console.log('Starting media watcher...')

  watcherInterval = setInterval(async () => {
    try {
      const windows = await getActiveWindows()
      if (process.env.NODE_ENV === 'development') {
        console.log('[Watcher] tasklist windows:', windows.slice(0, 5))
      }
      
      if (windows.length === 0) {
        if (process.env.NODE_ENV === 'development') {
          console.log('[Watcher] No media windows detected')
        }
        return
      }

      // Check each window for episode numbers using smart parser
      for (const window of windows) {
        try {
          // Parse the window title
          const parsed = parseAnimeFilename(window.title)
          if (process.env.NODE_ENV === 'development') {
            console.log('[Watcher] Parsed window:', { windowTitle: window.title, parsed })
          }

          // Check if we found an episode
          if (!parsed.episode || !parsed.title) {
            if (process.env.NODE_ENV === 'development') {
              console.log('[Watcher] Skipping - no episode/title', window.title)
            }
            continue
          }

          const title = parsed.title
          const episode = parsed.episode

          // Check if valid
          if (!title || isNaN(episode)) {
            if (process.env.NODE_ENV === 'development') {
              console.log('[Watcher] Skipping - invalid data', { title, episode })
            }
            continue
          }

        // Avoid duplicate notifications
        if (
          lastDetectedEpisode &&
            lastDetectedEpisode.title === title &&
            lastDetectedEpisode.episode === episode
        ) {
          if (process.env.NODE_ENV === 'development') {
            console.log('[Watcher] Skipping duplicate', { title, episode })
          }
          continue
        }

          lastDetectedEpisode = { title, episode: episode }

        // Call the callback
        callback({
            title,
            episode,
        })

        // Send IPC message to renderer
        const browserWindows = BrowserWindow.getAllWindows()
        browserWindows.forEach((win) => {
          win.webContents.send('tracking:detected', {
              title,
              episode,
          })
        })

          console.log(`Detected: ${title} - Episode ${episode}`)
        break // Only process first match
        } catch (error) {
          // Silently fail for individual window parsing errors
          if (process.env.NODE_ENV === 'development') {
            console.error('Error parsing window title:', window.title, error)
          }
          continue
        }
      }
    } catch (error) {
      // Silently fail - don't spam console
      if (process.env.NODE_ENV === 'development') {
        console.error('Watcher error:', error)
      }
    }
  }, 10000) // Poll every 10 seconds
}

export function stopWatcher() {
  if (watcherInterval) {
    clearInterval(watcherInterval)
    watcherInterval = null
    console.log('Stopped media watcher')
  }
}

// Legacy exports for backward compatibility
export function startWatcher() {
  startPolling(() => {}) // Empty callback, IPC handles it
}


========================================

=== apps\desktop\src\preload\preload.ts ===

import { contextBridge, ipcRenderer } from 'electron'

type RendererPresenceMode = 'minimal' | 'stats' | 'weeb'

interface RendererPresenceContext {
  title: string
  episode: number
  totalEpisodes?: number
  episodesThisSession?: number
  episodesToday?: number
  moodLabel?: string
  moodEmoji?: string
  themeId?: string
  isPro: boolean
}

contextBridge.exposeInMainWorld('electron', {
  minimize: () => ipcRenderer.invoke('window-minimize'),
  maximize: () => ipcRenderer.invoke('window-maximize'),
  close: () => ipcRenderer.invoke('window-close'),
  isMaximized: () => ipcRenderer.invoke('window-is-maximized'),
  onMaximize: (callback: (isMaximized: boolean) => void) => {
    ipcRenderer.on('window-maximized', (_, isMaximized: boolean) => callback(isMaximized))
  },
  onUnmaximize: (callback: (isMaximized: boolean) => void) => {
    ipcRenderer.on('window-unmaximized', (_, isMaximized: boolean) => callback(isMaximized))
  },
  // Auth IPC
  auth: {
    openExternal: (url: string) => ipcRenderer.invoke('auth:open-external', url),
    onTokenReceived: (callback: (token: string) => void) => {
      ipcRenderer.on('auth:token-received', (_, token) => callback(token))
    },
    removeTokenListener: () => {
      ipcRenderer.removeAllListeners('auth:token-received')
    },
    getToken: () => ipcRenderer.invoke('auth:get-token'),
    logout: () => ipcRenderer.invoke('auth:logout'),
    // Legacy method (kept for backward compatibility)
    openOAuthWindow: (url: string) => ipcRenderer.invoke('auth:open-oauth-window', url),
  },
  // License IPC
  license: {
    getKey: () => ipcRenderer.invoke('license:get-key'),
    storeKey: (key: string) => ipcRenderer.invoke('license:store-key', key),
    validate: (key: string) => ipcRenderer.invoke('license:validate', key),
  },
  // AniList GraphQL proxy
  anilist: {
    graphql: (payload: { query: string; variables?: Record<string, unknown>; accessToken?: string | null }) =>
      ipcRenderer.invoke('anilist:graphql', payload),
  },
    // Tracking IPC
    tracking: {
      onUpdate: (callback: (data: { 
        title: string
        episode: number
        overallEpisode?: number
        seasonNumber?: number
        seasonEpisode?: number
        source?: string
        platform?: string
      }) => void) => {
        ipcRenderer.on('tracking:update', (_, data) => callback(data))
        ipcRenderer.on('tracking:detected', (_, data) => callback(data))
      },
      removeListener: () => {
        ipcRenderer.removeAllListeners('tracking:update')
        ipcRenderer.removeAllListeners('tracking:detected')
      },
    },
  // Presence IPC
  presence: {
    updateConfig: (config: Partial<{ enabled: boolean; mode: RendererPresenceMode; useMood: boolean; showButtons: boolean }>) =>
      ipcRenderer.invoke('presence:update-config', config),
    updateNow: (ctx: RendererPresenceContext) =>
      ipcRenderer.invoke('presence:update-now', ctx),
  },
  // Organizer IPC
  organizer: {
    scan: (sourceDir: string, targetRoot: string, library: any[]) =>
      ipcRenderer.invoke('organizer:scan', { sourceDir, targetRoot, library }),
    apply: (plan: any[], logPath: string) =>
      ipcRenderer.invoke('organizer:apply', { plan, logPath }),
  },
  // Dialog IPC
  dialog: {
    selectFolder: () => ipcRenderer.invoke('dialog:select-folder'),
    },
})



========================================

=== apps\desktop\src\renderer\App.tsx ===

import { useEffect } from 'react'
import Layout from './components/Layout'
import { useStore } from './store/useStore'

function App() {
  const theme = useStore((state) => state.theme)

  useEffect(() => {
    const body = document.body
    if (!body) return

    const existingThemeClasses = Array.from(body.classList).filter((cls) => cls.startsWith('theme-'))
    existingThemeClasses.forEach((cls) => body.classList.remove(cls))

    if (theme && theme !== 'default') {
      body.classList.add(theme)
    }
  }, [theme])

  return <Layout />
}

export default App



========================================

=== apps\desktop\src\renderer\components\AnimeDetailsModal.tsx ===

import { motion, AnimatePresence } from 'framer-motion'
import { X, Star, Calendar, Film, ChevronDown } from 'lucide-react'
import { useEffect, useState, useRef } from 'react'
import type { Anime } from '@anivault/shared'
import { useStore } from '../store/useStore'

interface AnimeDetailsModalProps {
  anime: Anime | null
  isOpen: boolean
  onClose: () => void
  onStatusChange?: (message: string) => void
}

type StatusOption = 'plan-to-watch' | 'watching' | 'completed' | 'dropped'

const statusOptions: { value: StatusOption; label: string }[] = [
  { value: 'plan-to-watch', label: 'Planning' },
  { value: 'watching', label: 'Watching' },
  { value: 'completed', label: 'Completed' },
  { value: 'dropped', label: 'Dropped' },
]

const AnimeDetailsModal = ({ anime, isOpen, onClose, onStatusChange }: AnimeDetailsModalProps) => {
  const { library, updateEntry, addToLibrary } = useStore()
  const [showStatusDropdown, setShowStatusDropdown] = useState(false)
  const [progressInput, setProgressInput] = useState('')
  const statusDropdownRef = useRef<HTMLDivElement>(null)

  // Get current status and progress from library
  const libraryEntry = anime ? library.find((a) => a.id === anime.id) : null
  const currentStatus = (libraryEntry?.status || 'plan-to-watch') as StatusOption
  const currentProgress = libraryEntry?.progress || 0

  // Initialize progress input
  useEffect(() => {
    if (anime && isOpen) {
      setProgressInput(currentProgress.toString())
    }
  }, [anime, isOpen, currentProgress])

  // Close on Escape key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose()
      }
    }
    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [isOpen, onClose])

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (statusDropdownRef.current && !statusDropdownRef.current.contains(event.target as Node)) {
        setShowStatusDropdown(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  if (!anime) return null

  const handleStatusChange = async (status: StatusOption) => {
    try {
      if (libraryEntry) {
        await updateEntry(anime.id, { status })
      } else {
        await addToLibrary(anime, status)
      }

      const statusLabel = statusOptions.find((opt) => opt.value === status)?.label || status
      onStatusChange?.(`${status === 'watching' ? 'Added to' : 'Moved to'} ${statusLabel}`)
      setShowStatusDropdown(false)
    } catch (error) {
      console.error('Failed to update status:', error)
    }
  }

  const handleProgressChange = async () => {
    const episode = parseInt(progressInput)
    if (isNaN(episode) || episode < 0) {
      setProgressInput(currentProgress.toString())
      return
    }

    const maxEpisodes = anime.episodes || 999
    const clampedEpisode = Math.min(episode, maxEpisodes)

    try {
      if (libraryEntry) {
        await updateEntry(anime.id, { progress: clampedEpisode })
        onStatusChange?.(`Progress updated to Episode ${clampedEpisode}`)
      } else {
        // If not in library, add it first
        await addToLibrary(anime, 'watching')
        await updateEntry(anime.id, { progress: clampedEpisode })
        onStatusChange?.(`Added to Library - Episode ${clampedEpisode}`)
      }
    } catch (error) {
      console.error('Failed to update progress:', error)
      setProgressInput(currentProgress.toString())
    }
  }

  const handleProgressBlur = () => {
    handleProgressChange()
  }

  const handleProgressKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handleProgressChange()
    }
  }

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50"
          />

          {/* Modal */}
          <motion.div
            initial={{ opacity: 0, scale: 0.9, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.9, y: 20 }}
            className="fixed inset-4 md:inset-8 lg:inset-16 z-50 overflow-hidden"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="relative w-full h-full bg-[#0a0a0a] rounded-xl overflow-hidden border border-white/10 shadow-2xl flex flex-col">
              {/* Hero Header - Banner (Top 40%) */}
              {anime.bannerImage && (
                <div className="relative h-[40vh] overflow-hidden">
                  <img
                    src={anime.bannerImage}
                    alt={anime.title}
                    className="w-full h-full object-cover"
                    onError={(e) => {
                      ;(e.target as HTMLImageElement).style.display = 'none'
                    }}
                  />
                  {/* Gradient overlay at bottom for seamless blend */}
                  <div className="absolute inset-0 bg-gradient-to-t from-[#0a0a0a] to-transparent" />
                </div>
              )}

              {/* Close Button */}
              <button
                onClick={onClose}
                className="absolute top-4 right-4 z-50 w-10 h-10 rounded-full bg-black/50 backdrop-blur-sm hover:bg-black/70 flex items-center justify-center transition-colors border border-white/10"
              >
                <X size={20} className="text-white" />
              </button>

              {/* Content Area */}
              <div className="flex-1 overflow-y-auto scrollbar-hide">
                <div className="px-8 pb-8">
                  {/* Floating Poster - sits naturally below banner */}
                  <div className="flex gap-8 relative z-10">
                    {/* Poster */}
                    <div className="flex-shrink-0 pt-16">
                      <motion.div
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: 0.2 }}
                        className="w-48 md:w-64 lg:w-80 relative z-10"
                      >
                        <img
                          src={anime.coverImage || 'https://via.placeholder.com/300x450'}
                          alt={anime.title}
                          className="w-full rounded-lg shadow-2xl"
                          onError={(e) => {
                            ;(e.target as HTMLImageElement).src =
                              'https://via.placeholder.com/300x450/1a1a1a/8b5cf6?text=No+Image'
                          }}
                        />
                      </motion.div>
                    </div>

                    {/* Content */}
                    <div className="flex-1 space-y-6 pt-16">
                      {/* Title and Metadata */}
                      <div>
                        <motion.h1
                          initial={{ opacity: 0, y: 20 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ delay: 0.1 }}
                          className="text-4xl md:text-5xl font-bold mb-4 bg-gradient-to-r from-violet-400 to-blue-400 bg-clip-text text-transparent"
                        >
                          {anime.titleEnglish || anime.title}
                        </motion.h1>

                        {anime.titleJapanese && (
                          <p className="text-xl text-gray-400 mb-4">{anime.titleJapanese}</p>
                        )}

                        {/* Metadata Row */}
                        <div className="flex flex-wrap items-center gap-4 text-sm text-gray-300">
                          {anime.rating && (
                            <div className="flex items-center gap-1">
                              <Star className="text-violet-400" size={18} />
                              <span className="font-semibold">{(anime.rating * 10).toFixed(0)}</span>
                              <span className="text-gray-500">/ 100</span>
                            </div>
                          )}
                          {anime.year && (
                            <div className="flex items-center gap-1">
                              <Calendar className="text-gray-400" size={16} />
                              <span>{anime.year}</span>
                            </div>
                          )}
                          {anime.format && (
                            <div className="flex items-center gap-1">
                              <Film className="text-gray-400" size={16} />
                              <span>{anime.format}</span>
                            </div>
                          )}
                          {anime.episodes && (
                            <span className="text-gray-400">{anime.episodes} episodes</span>
                          )}
                        </div>

                        {/* Genres */}
                        {anime.genres && anime.genres.length > 0 && (
                          <div className="flex flex-wrap gap-2 mt-4">
                            {anime.genres.slice(0, 5).map((genre) => (
                              <span
                                key={genre}
                                className="px-3 py-1 rounded-full text-xs bg-violet-500/20 text-violet-300 border border-violet-500/30"
                              >
                                {genre}
                              </span>
                            ))}
                          </div>
                        )}
                      </div>

                      {/* Actions Section */}
                      <motion.div
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ delay: 0.3 }}
                        className="space-y-4"
                      >
                        {/* Status Dropdown - High Contrast */}
                        <div className="space-y-2">
                          <label className="text-sm font-semibold text-gray-300">Status</label>
                          <div className="relative" ref={statusDropdownRef}>
                            <button
                              onClick={() => setShowStatusDropdown(!showStatusDropdown)}
                              className="w-full px-6 py-3 rounded-lg bg-violet-600 hover:bg-violet-700 text-white font-semibold text-left flex items-center justify-between transition-colors shadow-lg"
                            >
                              <span>
                                {statusOptions.find((opt) => opt.value === currentStatus)?.label ||
                                  'Planning'}
                              </span>
                              <ChevronDown
                                size={20}
                                className={`text-white transition-transform ${
                                  showStatusDropdown ? 'rotate-180' : ''
                                }`}
                              />
                            </button>

                            {showStatusDropdown && (
                              <motion.div
                                initial={{ opacity: 0, y: -10 }}
                                animate={{ opacity: 1, y: 0 }}
                                className="absolute top-full mt-2 w-full rounded-lg bg-black/95 backdrop-blur-xl border border-white/10 shadow-lg z-50"
                              >
                                {statusOptions.map((option) => (
                                  <button
                                    key={option.value}
                                    onClick={() => handleStatusChange(option.value)}
                                    className={`w-full text-left px-6 py-3 text-sm transition-colors ${
                                      currentStatus === option.value
                                        ? 'bg-violet-500/30 text-violet-400 font-semibold'
                                        : 'text-gray-300 hover:bg-white/10'
                                    }`}
                                  >
                                    {option.label}
                                  </button>
                                ))}
                              </motion.div>
                            )}
                          </div>
                        </div>

                        {/* Progress Input */}
                        <div className="space-y-2">
                          <label className="text-sm font-semibold text-gray-300">
                            Edit Progress
                          </label>
                          <div className="flex items-center gap-2">
                            <input
                              type="number"
                              min="0"
                              max={anime.episodes || 999}
                              value={progressInput}
                              onChange={(e) => setProgressInput(e.target.value)}
                              onBlur={handleProgressBlur}
                              onKeyDown={handleProgressKeyDown}
                              className="flex-1 px-4 py-3 rounded-lg bg-white/5 border border-white/10 text-white focus:outline-none focus:border-violet-500/50 focus:ring-2 focus:ring-violet-500/20"
                              placeholder="0"
                            />
                            <span className="text-gray-400">
                              of {anime.episodes || '?'} episodes
                            </span>
                          </div>
                        </div>
                      </motion.div>

                      {/* Description */}
                      {anime.description && (
                        <motion.div
                          initial={{ opacity: 0, y: 20 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ delay: 0.4 }}
                          className="space-y-2"
                        >
                          <h3 className="text-xl font-semibold">Description</h3>
                          <div className="max-h-64 overflow-y-auto scrollbar-hide pr-2">
                            <p className="text-gray-300 leading-relaxed">
                              {anime.description.replace(/<[^>]*>/g, '')}
                            </p>
                          </div>
                        </motion.div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  )
}

export default AnimeDetailsModal


========================================

=== apps\desktop\src\renderer\components\AnimeMatchModal.tsx ===

import { motion, AnimatePresence } from 'framer-motion'
import { useState, useEffect } from 'react'
import { X, Search } from 'lucide-react'
import type { Anime } from '@anivault/shared'
import { anilistService } from '../services/anilist.service'

interface AnimeMatchModalProps {
  isOpen: boolean
  onClose: () => void
  detectedTitle: string
  detectedEpisode: number
  onMatch: (anime: Anime, episode: number) => void
}

export default function AnimeMatchModal({
  isOpen,
  onClose,
  detectedTitle,
  detectedEpisode,
  onMatch,
}: AnimeMatchModalProps) {
  const [searchQuery, setSearchQuery] = useState(detectedTitle)
  const [searchResults, setSearchResults] = useState<Anime[]>([])
  const [isSearching, setIsSearching] = useState(false)
  const [selectedAnime, setSelectedAnime] = useState<Anime | null>(null)

  // Auto-search when modal opens
  useEffect(() => {
    if (isOpen && detectedTitle) {
      handleSearch()
    }
  }, [isOpen])

  const handleSearch = async () => {
    if (!searchQuery.trim()) return

    setIsSearching(true)
    try {
      const results = await anilistService.searchAnime(searchQuery, {}, 1, 10)
      setSearchResults(results)
    } catch (error) {
      console.error('Search failed:', error)
      setSearchResults([])
    } finally {
      setIsSearching(false)
    }
  }

  const handleSelect = (anime: Anime) => {
    setSelectedAnime(anime)
    onMatch(anime, detectedEpisode)
    onClose()
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  }

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50"
          />

          {/* Modal */}
          <motion.div
            initial={{ opacity: 0, scale: 0.9, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.9, y: 20 }}
            className="fixed inset-4 md:inset-8 lg:inset-16 z-50 overflow-hidden"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="relative w-full h-full bg-[#0a0a0a] rounded-xl overflow-hidden border border-white/10 shadow-2xl flex flex-col">
              {/* Header */}
              <div className="px-6 py-4 border-b border-white/10 flex items-center justify-between">
                <div>
                  <h2 className="text-2xl font-bold text-white">Unknown Anime Detected</h2>
                  <p className="text-sm text-gray-400 mt-1">
                    We found "{detectedTitle} - Episode {detectedEpisode}". Match it to an anime:
                  </p>
                </div>
                <button
                  onClick={onClose}
                  className="w-10 h-10 rounded-full bg-white/5 hover:bg-white/10 flex items-center justify-center transition-colors border border-white/10"
                >
                  <X size={20} className="text-white" />
                </button>
              </div>

              {/* Search Bar */}
              <div className="px-6 py-4 border-b border-white/10">
                <div className="flex gap-2">
                  <div className="flex-1 relative">
                    <Search
                      size={20}
                      className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"
                    />
                    <input
                      type="text"
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      onKeyDown={handleKeyDown}
                      placeholder="Search for anime..."
                      className="w-full pl-10 pr-4 py-2.5 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-violet-500 focus:border-transparent"
                    />
                  </div>
                  <button
                    onClick={handleSearch}
                    disabled={isSearching || !searchQuery.trim()}
                    className="px-6 py-2.5 bg-violet-600 hover:bg-violet-700 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg text-white font-medium transition-colors"
                  >
                    {isSearching ? 'Searching...' : 'Search'}
                  </button>
                </div>
              </div>

              {/* Results */}
              <div className="flex-1 overflow-y-auto scrollbar-hide p-6">
                {isSearching ? (
                  <div className="flex items-center justify-center h-64">
                    <div className="text-gray-400">Searching...</div>
                  </div>
                ) : searchResults.length === 0 ? (
                  <div className="flex items-center justify-center h-64">
                    <div className="text-center">
                      <p className="text-gray-400 mb-2">No results found</p>
                      <p className="text-sm text-gray-500">Try a different search term</p>
                    </div>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {searchResults.map((anime) => (
                      <motion.button
                        key={anime.id}
                        onClick={() => handleSelect(anime)}
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                        className="text-left bg-white/5 hover:bg-white/10 border border-white/10 rounded-lg p-4 transition-colors"
                      >
                        <div className="flex gap-4">
                          <img
                            src={anime.coverImage || 'https://via.placeholder.com/100x140'}
                            alt={anime.title}
                            className="w-20 h-28 object-cover rounded"
                          />
                          <div className="flex-1 min-w-0">
                            <h3 className="font-semibold text-white mb-1 truncate">
                              {anime.title}
                            </h3>
                            {anime.titleEnglish && anime.titleEnglish !== anime.title && (
                              <p className="text-sm text-gray-400 mb-2 truncate">
                                {anime.titleEnglish}
                              </p>
                            )}
                            {anime.episodes && (
                              <p className="text-xs text-gray-500">
                                {anime.episodes} episodes
                              </p>
                            )}
                          </div>
                        </div>
                      </motion.button>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  )
}


========================================

=== apps\desktop\src\renderer\components\AutoOrganizerPanel.tsx ===

import { useState } from 'react'
import { useStore } from '../store/useStore'

type PlanItem = {
  from: string
  to: string
  title: string | null
  episode: number | null
  matchedAnimeTitle?: string
  season: number | null
  status: 'ready' | 'unmatched' | 'conflict'
}

const AutoOrganizerPanel = () => {
  const {
    isPro,
    library,
    organizerSourceDir,
    organizerTargetRoot,
    setOrganizerSourceDir,
    setOrganizerTargetRoot,
  } = useStore((state) => ({
    isPro: state.isPro,
    library: state.library,
    organizerSourceDir: state.organizerSourceDir,
    organizerTargetRoot: state.organizerTargetRoot,
    setOrganizerSourceDir: state.setOrganizerSourceDir,
    setOrganizerTargetRoot: state.setOrganizerTargetRoot,
  }))

  const [plan, setPlan] = useState<PlanItem[]>([])
  const [selected, setSelected] = useState<Record<string, boolean>>({})
  const [isScanning, setIsScanning] = useState(false)
  const [isApplying, setIsApplying] = useState(false)
  const [error, setError] = useState<string | null>(null)

  if (!isPro) {
    return (
      <div className="rounded-2xl border border-border/60 bg-card/40 p-4 text-sm text-muted-foreground">
        Upgrade to AniVault Pro to automatically organize your local anime files.
      </div>
    )
  }

  const handleScan = async () => {
    if (!window.electron?.organizer) {
      setError('Organizer bridge not available. Please restart the app.')
      return
    }
    if (!organizerSourceDir || !organizerTargetRoot) {
      setError('Please set both source and target folders.')
      return
    }
    setError(null)
    setIsScanning(true)
    try {
      const result = await window.electron.organizer.scan(organizerSourceDir, organizerTargetRoot, library || [])
      setPlan(result)
      const sel: Record<string, boolean> = {}
      for (const item of result) {
        sel[item.from] = item.status === 'ready'
      }
      setSelected(sel)
    } catch (err: any) {
      console.error('Organizer scan failed', err)
      setError(err?.message ?? 'Failed to scan folder.')
    } finally {
      setIsScanning(false)
    }
  }

  const handleApply = async () => {
    if (!window.electron?.organizer) return
    const selectedItems = plan.filter((item) => selected[item.from] && item.status === 'ready')
    if (selectedItems.length === 0) {
      setError('No ready files selected.')
      return
    }

    setIsApplying(true)
    setError(null)
    try {
      const logPath = `${organizerTargetRoot}/anivault-organizer-log-${new Date().toISOString().slice(0, 10)}.json`
      await window.electron.organizer.apply(selectedItems, logPath)
      setPlan([])
    } catch (err: any) {
      console.error('Organizer apply failed', err)
      setError(err?.message ?? 'Failed to organize files.')
    } finally {
      setIsApplying(false)
    }
  }

  const readyCount = plan.filter((p) => p.status === 'ready' && selected[p.from]).length

  return (
    <div className="space-y-4">
      <div className="flex flex-col gap-3 md:flex-row">
        <div className="flex-1 space-y-1">
          <label className="text-xs font-medium text-muted-foreground">Source folder (messy downloads)</label>
          <div className="flex gap-2">
            <input
              type="text"
              className="w-full rounded-lg bg-card px-3 py-2 text-sm text-foreground outline-none ring-0 border border-border/60"
              value={organizerSourceDir ?? ''}
              onChange={(e) => setOrganizerSourceDir(e.target.value || null)}
              placeholder="D:\\Downloads\\Anime"
            />
            <button
              type="button"
              className="shrink-0 rounded-lg border border-border/60 bg-card px-3 py-2 text-xs text-muted-foreground hover:bg-white/5"
              onClick={async () => {
                if (!window.electron?.dialog) {
                  setError('Folder picker unavailable. Please restart the app.')
                  return
                }
                const dir = await window.electron.dialog.selectFolder()
                if (dir) {
                  setOrganizerSourceDir(dir)
                }
              }}
            >
              Browse
            </button>
          </div>
        </div>
        <div className="flex-1 space-y-1">
          <label className="text-xs font-medium text-muted-foreground">Target root (organized library)</label>
          <div className="flex gap-2">
            <input
              type="text"
              className="w-full rounded-lg bg-card px-3 py-2 text-sm text-foreground outline-none ring-0 border border-border/60"
              value={organizerTargetRoot ?? ''}
              onChange={(e) => setOrganizerTargetRoot(e.target.value || null)}
              placeholder="D:\\Anime"
            />
            <button
              type="button"
              className="shrink-0 rounded-lg border border-border/60 bg-card px-3 py-2 text-xs text-muted-foreground hover:bg-white/5"
              onClick={async () => {
                if (!window.electron?.dialog) {
                  setError('Folder picker unavailable. Please restart the app.')
                  return
                }
                const dir = await window.electron.dialog.selectFolder()
                if (dir) {
                  setOrganizerTargetRoot(dir)
                }
              }}
            >
              Browse
            </button>
          </div>
        </div>
      </div>

      <div className="flex items-center gap-3">
        <button
          onClick={handleScan}
          disabled={isScanning}
          className="rounded-lg bg-primary px-4 py-2 text-sm font-medium text-primary-foreground shadow shadow-primary/40 disabled:opacity-60"
        >
          {isScanning ? 'Scanningâ€¦' : 'Scan'}
        </button>
        <button
          onClick={handleApply}
          disabled={isApplying || readyCount === 0}
          className="rounded-lg bg-emerald-500/80 px-4 py-2 text-sm font-medium text-white shadow disabled:opacity-50"
        >
          {isApplying ? 'Organizingâ€¦' : `Organize ${readyCount} file${readyCount === 1 ? '' : 's'}`}
        </button>
        {error && <p className="text-xs text-red-400">{error}</p>}
      </div>

      <div className="max-h-80 overflow-auto rounded-xl border border-border/60 bg-card/40">
        <table className="min-w-full text-left text-xs">
          <thead className="bg-background/40">
            <tr>
              <th className="px-3 py-2">
                <input
                  type="checkbox"
                  checked={plan.length > 0 && plan.every((p) => selected[p.from])}
                  onChange={(e) => {
                    const value = e.target.checked
                    const sel: Record<string, boolean> = {}
                    for (const item of plan) {
                      sel[item.from] = value && item.status === 'ready'
                    }
                    setSelected(sel)
                  }}
                />
              </th>
              <th className="px-3 py-2">File</th>
              <th className="px-3 py-2">Detected</th>
              <th className="px-3 py-2">Episode</th>
              <th className="px-3 py-2">Season</th>
              <th className="px-3 py-2">Destination</th>
              <th className="px-3 py-2">Status</th>
            </tr>
          </thead>
          <tbody>
            {plan.length === 0 && (
              <tr>
                <td colSpan={7} className="px-3 py-6 text-center text-muted-foreground">
                  No files scanned yet.
                </td>
              </tr>
            )}
            {plan.map((item) => (
              <tr key={item.from} className="border-t border-border/40">
                <td className="px-3 py-2 align-top">
                  <input
                    type="checkbox"
                    disabled={item.status !== 'ready'}
                    checked={!!selected[item.from]}
                    onChange={(e) => setSelected((prev) => ({ ...prev, [item.from]: e.target.checked }))}
                  />
                </td>
                <td className="px-3 py-2 align-top text-[11px] text-muted-foreground">{item.from}</td>
                <td className="px-3 py-2 align-top text-[11px]">
                  {item.matchedAnimeTitle ?? item.title ?? <span className="text-muted-foreground">Unknown</span>}
                </td>
                <td className="px-3 py-2 align-top text-[11px]">{item.episode ?? '-'}</td>
                <td className="px-3 py-2 align-top text-[11px]">{item.season ?? '-'}</td>
                <td className="px-3 py-2 align-top text-[11px] text-muted-foreground">{item.to}</td>
                <td className="px-3 py-2 align-top text-[11px]">
                  {item.status === 'ready' && (
                    <span className="rounded-full bg-emerald-500/15 px-2 py-0.5 text-[10px] text-emerald-400">
                      Ready
                    </span>
                  )}
                  {item.status === 'unmatched' && (
                    <span className="rounded-full bg-amber-500/10 px-2 py-0.5 text-[10px] text-amber-400">
                      Unmatched
                    </span>
                  )}
                  {item.status === 'conflict' && (
                    <span className="rounded-full bg-red-500/10 px-2 py-0.5 text-[10px] text-red-400">Conflict</span>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}

export default AutoOrganizerPanel



========================================

=== apps\desktop\src\renderer\components\Discover.tsx ===

import { motion } from 'framer-motion'
import { Search, Loader2, X, Plus, ChevronDown, Star } from 'lucide-react'
import { useState, useEffect, useRef } from 'react'
import type { Anime } from '@anivault/shared'
import { anilistService } from '../services/anilist.service'
import { useStore } from '../store/useStore'
import {
  AVAILABLE_MOODS,
  type MoodId,
  type MoodRecommendation,
  getMoodRecommendations,
} from '../services/recommendation.service'
import Toast from './Toast'
import AnimeDetailsModal from './AnimeDetailsModal'

interface AnimeCardProps {
  anime: Anime
  index: number
  onAdd: (anime: Anime) => void
  onClick: (anime: Anime) => void
}

const AnimeCard = ({ anime, index, onAdd, onClick }: AnimeCardProps) => {
  const [isHovered, setIsHovered] = useState(false)

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.9 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ delay: index * 0.05 }}
      className="relative group cursor-pointer"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <motion.div
        whileHover={{ scale: 1.05 }}
        onClick={() => onClick(anime)}
        className="relative aspect-[2/3] rounded-lg overflow-hidden transition-all duration-300 cursor-pointer"
        style={{
          boxShadow: isHovered
            ? '0 0 30px rgba(139, 92, 246, 0.6), 0 0 60px rgba(139, 92, 246, 0.3)'
            : '0 4px 6px rgba(0, 0, 0, 0.3)',
        }}
      >
        {/* Poster Image */}
        <div className="absolute inset-0">
          <img
            src={anime.coverImage || 'https://via.placeholder.com/300x450'}
            alt={anime.title}
            className="w-full h-full object-cover"
            onError={(e) => {
              ;(e.target as HTMLImageElement).src = 'https://via.placeholder.com/300x450/1a1a1a/8b5cf6?text=No+Image'
            }}
          />
          {/* Gradient Overlay */}
          <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent" />
        </div>

        {/* Content */}
        <div className="absolute bottom-0 left-0 right-0 p-4 z-10">
          <h3 className="text-white font-semibold text-sm mb-1 line-clamp-2">
            {anime.titleEnglish || anime.title}
          </h3>
          {anime.rating && (
            <div className="flex items-center gap-1 text-xs text-gray-300">
              <span className="text-violet-400">â˜…</span>
              <span>{anime.rating.toFixed(1)}</span>
            </div>
          )}
        </div>

        {/* Quick Add Button - appears on hover */}
        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{
            opacity: isHovered ? 1 : 0,
            y: isHovered ? 0 : 10,
          }}
          transition={{ duration: 0.2 }}
          className="absolute top-4 right-4 z-20"
        >
          <motion.button
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.95 }}
            onClick={(e) => {
              e.stopPropagation()
              onAdd(anime)
            }}
            className="flex items-center justify-center w-10 h-10 rounded-full bg-violet-500/90 backdrop-blur-sm hover:bg-violet-500 text-white shadow-lg shadow-violet-500/50 transition-all"
          >
            <Plus size={20} />
          </motion.button>
        </motion.div>
      </motion.div>
    </motion.div>
  )
}

interface TopRatedItemProps {
  anime: Anime
  rank: number
  onClick: (anime: Anime) => void
}

const TopRatedItem = ({ anime, rank, onClick }: TopRatedItemProps) => {
  return (
    <motion.div
      initial={{ opacity: 0, x: -10 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ delay: rank * 0.1 }}
      onClick={() => onClick(anime)}
      className="flex items-center gap-3 p-3 rounded-lg bg-white/5 hover:bg-white/10 transition-colors cursor-pointer group"
    >
      {/* Rank Badge */}
      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-violet-500/20 border border-violet-500/30 flex items-center justify-center text-violet-400 font-bold text-sm">
        {rank}
      </div>

      {/* Cover Image */}
      <div className="flex-shrink-0 w-16 h-24 rounded overflow-hidden">
        <img
          src={anime.coverImage || 'https://via.placeholder.com/300x450'}
          alt={anime.title}
          className="w-full h-full object-cover"
          onError={(e) => {
            ;(e.target as HTMLImageElement).src = 'https://via.placeholder.com/300x450/1a1a1a/8b5cf6?text=No+Image'
          }}
        />
      </div>

      {/* Info */}
      <div className="flex-1 min-w-0">
        <h4 className="text-white font-semibold text-sm line-clamp-2 group-hover:text-violet-400 transition-colors">
          {anime.titleEnglish || anime.title}
        </h4>
        {anime.rating && (
          <div className="flex items-center gap-1 mt-1">
            <Star size={14} className="text-violet-400" />
            <span className="text-xs text-gray-400">{(anime.rating * 10).toFixed(0)}</span>
          </div>
        )}
      </div>
    </motion.div>
  )
}

const genres = [
  'Action',
  'Adventure',
  'Comedy',
  'Drama',
  'Fantasy',
  'Horror',
  'Mecha',
  'Music',
  'Mystery',
  'Psychological',
  'Romance',
  'Sci-Fi',
  'Slice of Life',
  'Sports',
  'Supernatural',
  'Thriller',
]

const years = ['2024', '2023', '2022', '2021', '2020', '2019', '2018', '2017', '2016', '2015']

type SortOption = 'POPULARITY_DESC' | 'SCORE_DESC' | 'START_DATE_DESC'

const sortOptions: { value: SortOption; label: string }[] = [
  { value: 'POPULARITY_DESC', label: 'Popularity' },
  { value: 'SCORE_DESC', label: 'Score' },
  { value: 'START_DATE_DESC', label: 'Newest' },
]

interface DiscoverProps {
  initialQuery?: string
}

const Discover = ({ initialQuery = '' }: DiscoverProps) => {
  const [searchQuery, setSearchQuery] = useState(initialQuery)
  const [selectedGenre, setSelectedGenre] = useState<string | null>(null)
  const [selectedYear, setSelectedYear] = useState<string | null>(null)
  const [sortBy, setSortBy] = useState<SortOption>('POPULARITY_DESC')
  const [showGenreDropdown, setShowGenreDropdown] = useState(false)
  const [showYearDropdown, setShowYearDropdown] = useState(false)
  const [showSortDropdown, setShowSortDropdown] = useState(false)
  const [searchResults, setSearchResults] = useState<Anime[]>([])
  const [trendingAnime, setTrendingAnime] = useState<Anime[]>([])
  const [topRatedAnime, setTopRatedAnime] = useState<Anime[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [isLoadingTrending, setIsLoadingTrending] = useState(false)
  const [isLoadingTopRated, setIsLoadingTopRated] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [toastVisible, setToastVisible] = useState(false)
  const [toastMessage, setToastMessage] = useState('')
  const [selectedAnime, setSelectedAnime] = useState<Anime | null>(null)
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [selectedMoodId, setSelectedMoodId] = useState<MoodId>('hype')
  const [moodRec, setMoodRec] = useState<MoodRecommendation | null>(null)
  const [isLoadingMood, setIsLoadingMood] = useState(false)
  const [moodError, setMoodError] = useState<string | null>(null)
  // Pagination state
  const [page, setPage] = useState(1)
  const [hasMore, setHasMore] = useState(true)
  const searchInputRef = useRef<HTMLInputElement>(null)
  const genreDropdownRef = useRef<HTMLDivElement>(null)
  const yearDropdownRef = useRef<HTMLDivElement>(null)
  const sortDropdownRef = useRef<HTMLDivElement>(null)
  const { addToLibrary, accessToken, isPro, library } = useStore()

  // Update search query when initialQuery prop changes
  useEffect(() => {
    if (initialQuery !== undefined) {
      setSearchQuery(initialQuery)
    }
  }, [initialQuery])

  // Auto-focus search input on mount
  useEffect(() => {
    if (searchInputRef.current && !initialQuery) {
      searchInputRef.current.focus()
    }
  }, [initialQuery])

  // Close dropdowns when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as Node
      if (genreDropdownRef.current && !genreDropdownRef.current.contains(target)) {
        setShowGenreDropdown(false)
      }
      if (yearDropdownRef.current && !yearDropdownRef.current.contains(target)) {
        setShowYearDropdown(false)
      }
      if (sortDropdownRef.current && !sortDropdownRef.current.contains(target)) {
        setShowSortDropdown(false)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  // Load trending and top rated on mount if no search
  useEffect(() => {
    if (!searchQuery.trim() && !selectedGenre && !selectedYear) {
      loadTrending()
      loadTopRated()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  // RESET search when filters change (New Search)
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (searchQuery.trim() || selectedGenre || selectedYear) {
        // Reset to page 1 and clear results for a new search
        setPage(1)
        performSearch(1, true) // true = reset list
      } else {
        // Clear search results when search is empty
        setSearchResults([])
        setPage(1)
        setHasMore(true)
        // Reload trending and top rated
        if (!initialQuery) {
          loadTrending()
          loadTopRated()
        }
      }
    }, 500)

    return () => clearTimeout(timeoutId)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchQuery, selectedGenre, selectedYear, sortBy])

  // Mood recommendations (Pro only)
  useEffect(() => {
    if (!isPro) return

    let cancelled = false
    const run = async () => {
      try {
        setIsLoadingMood(true)
        setMoodError(null)
        const rec = await getMoodRecommendations(selectedMoodId, library || [], {
          limit: 12,
          excludeCompleted: true,
          excludeDropped: true,
        })
        if (!cancelled) {
          setMoodRec(rec)
        }
      } catch (err) {
        console.error('Failed to load mood recommendations', err)
        if (!cancelled) {
          setMoodError('Failed to load mood recommendations')
        }
      } finally {
        if (!cancelled) {
          setIsLoadingMood(false)
        }
      }
    }

    void run()

    return () => {
      cancelled = true
    }
  }, [selectedMoodId, library, isPro])

  const loadTrending = async () => {
    try {
      setIsLoadingTrending(true)
      if (accessToken) {
        anilistService.setAccessToken(accessToken)
      }
      const data = await anilistService.getTrendingAnime(20)
      setTrendingAnime(data)
    } catch (err) {
      console.error('Failed to load trending:', err)
    } finally {
      setIsLoadingTrending(false)
    }
  }

  const loadTopRated = async () => {
    try {
      setIsLoadingTopRated(true)
      if (accessToken) {
        anilistService.setAccessToken(accessToken)
      }
      const data = await anilistService.getTopRatedAnime(10)
      setTopRatedAnime(data)
    } catch (err) {
      console.error('Failed to load top rated:', err)
    } finally {
      setIsLoadingTopRated(false)
    }
  }

  const performSearch = async (pageNum: number, reset: boolean = false) => {
    try {
      // Don't show full loading spinner for "load more", only for new search
      if (reset) setIsLoading(true) 
      
      setError(null)

      if (accessToken) {
        anilistService.setAccessToken(accessToken)
      }

      // Call our upgraded API function
      const data = await anilistService.searchAnime(
        searchQuery.trim(),
        {
          genre: selectedGenre,
          year: selectedYear,
          sort: sortBy
        },
        pageNum,
        20 // items per page
      )

      // If we got fewer than 20 items, we've reached the end
      setHasMore(data.length === 20)

      if (reset) {
        setSearchResults(data) // Replace list
      } else {
        setSearchResults(prev => [...prev, ...data]) // Append to list
      }

    } catch (err) {
      console.error('Search failed:', err)
      setError(err instanceof Error ? err.message : 'Failed to search anime')
      if (reset) {
        setSearchResults([])
      }
    } finally {
      setIsLoading(false)
    }
  }

  // "Load More" Handler
  const loadMore = () => {
    if (!isLoading && hasMore) {
      const nextPage = page + 1
      setPage(nextPage)
      performSearch(nextPage, false) // false = append to list
    }
  }

  const handleAddToLibrary = async (anime: Anime) => {
    try {
      await addToLibrary(anime, 'plan-to-watch')
      setToastMessage('Added to Library')
      setToastVisible(true)
    } catch (error) {
      console.error('Failed to add to library:', error)
    }
  }

  const handleCardClick = (anime: Anime) => {
    setSelectedAnime(anime)
    setIsModalOpen(true)
  }

  const handleStatusChange = (message: string) => {
    setToastMessage(message)
    setToastVisible(true)
  }

  const clearSearch = () => {
    setSearchQuery('')
    setSelectedGenre(null)
    setSelectedYear(null)
    if (searchInputRef.current) {
      searchInputRef.current.focus()
    }
  }

  const hasSearchQuery = searchQuery.trim() || selectedGenre || selectedYear

  return (
    <div className="space-y-6">
      {/* Search Input */}
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        className="relative max-w-2xl mx-auto"
      >
        <div className="relative">
          <Search
            className="absolute left-4 top-1/2 -translate-y-1/2 text-gray-400"
            size={24}
          />
          <input
            ref={searchInputRef}
            type="text"
            placeholder="Search for anime..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-full pl-12 pr-12 py-4 text-lg rounded-lg backdrop-blur-xl bg-white/5 border border-white/10 text-white placeholder:text-gray-500 focus:outline-none focus:border-violet-500/50 focus:ring-2 focus:ring-violet-500/20 transition-all"
          />
          {searchQuery && (
            <button
              onClick={clearSearch}
              className="absolute right-4 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white transition-colors"
            >
              <X size={20} />
            </button>
          )}
        </div>
      </motion.div>

      {/* Mood Recommendations (Pro) */}
      {isPro && (
        <section className="mt-8 space-y-4">
          <div className="flex items-center justify-between">
            <div>
              <h2 className="text-lg font-semibold text-foreground flex items-center gap-2">
                Mood Recommendations
                <span className="rounded-full border border-primary/40 bg-primary/10 px-2 py-0.5 text-xs text-primary">
                  Pro
                </span>
              </h2>
              <p className="text-sm text-muted-foreground">
                Pick a mood and we&apos;ll find the perfect anime for your vibe.
              </p>
            </div>
          </div>

          <div className="flex flex-wrap gap-2">
            {AVAILABLE_MOODS.map((mood) => {
              const isActive = mood.id === selectedMoodId
              return (
                <button
                  key={mood.id}
                  onClick={() => setSelectedMoodId(mood.id)}
                  className={[
                    'flex items-center gap-2 rounded-full px-3 py-1 text-sm transition',
                    isActive
                      ? 'bg-primary text-primary-foreground shadow shadow-primary/40'
                      : 'bg-card/60 text-muted-foreground hover:bg-card hover:text-foreground border border-border/60',
                  ].join(' ')}
                >
                  <span>{mood.emoji}</span>
                  <span>{mood.label}</span>
                </button>
              )
            })}
          </div>

          <div className="relative mt-2">
            {isLoadingMood && (
              <div className="flex h-32 items-center justify-center text-sm text-muted-foreground">
                Loading mood-based picks...
              </div>
            )}

            {moodError && !isLoadingMood && (
              <div className="flex h-32 items-center justify-center text-sm text-red-400">
                {moodError}
              </div>
            )}

            {!isLoadingMood && !moodError && moodRec && (
              <div className="space-y-2">
                <p className="text-sm text-muted-foreground">{moodRec.mood.description}</p>
                <div className="grid grid-cols-2 gap-3 md:grid-cols-4 lg:grid-cols-6">
                  {moodRec.anime.map((anime, index) => (
                    <AnimeCard
                      key={anime.id}
                      anime={anime}
                      index={index}
                      onAdd={handleAddToLibrary}
                      onClick={handleCardClick}
                    />
                  ))}
                </div>
              </div>
            )}

            {!isLoadingMood && !moodError && !moodRec && (
              <div className="flex h-32 items-center justify-center text-sm text-muted-foreground">
                No recommendations found for this mood yet.
              </div>
            )}
          </div>
        </section>
      )}

      {/* Filters Row */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="flex flex-wrap items-center gap-4 justify-center"
      >
        {/* Genre Dropdown */}
        <div className="relative" ref={genreDropdownRef}>
          <button
            onClick={() => {
              setShowGenreDropdown(!showGenreDropdown)
              setShowYearDropdown(false)
              setShowSortDropdown(false)
            }}
            className="px-4 py-2 rounded-lg bg-white/5 border border-white/10 text-gray-300 hover:bg-white/10 transition-colors flex items-center gap-2"
          >
            <span className="text-sm font-medium">
              {selectedGenre ? `Genre: ${selectedGenre}` : 'All Genres'}
            </span>
            <ChevronDown
              size={16}
              className={`transition-transform ${showGenreDropdown ? 'rotate-180' : ''}`}
            />
          </button>

          {showGenreDropdown && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="absolute top-full mt-2 w-48 rounded-lg bg-black/90 backdrop-blur-xl border border-white/10 shadow-lg z-50 max-h-64 overflow-y-auto"
            >
              <button
                onClick={() => {
                  setSelectedGenre(null)
                  setShowGenreDropdown(false)
                }}
                className={`w-full text-left px-4 py-2 text-sm transition-colors ${
                  !selectedGenre
                    ? 'bg-violet-500/20 text-violet-400'
                    : 'text-gray-300 hover:bg-white/5'
                }`}
              >
                All Genres
              </button>
              {genres.map((genre) => (
                <button
                  key={genre}
                  onClick={() => {
                    setSelectedGenre(genre)
                    setShowGenreDropdown(false)
                  }}
                  className={`w-full text-left px-4 py-2 text-sm transition-colors ${
                    selectedGenre === genre
                      ? 'bg-violet-500/20 text-violet-400'
                      : 'text-gray-300 hover:bg-white/5'
                  }`}
                >
                  {genre}
                </button>
              ))}
            </motion.div>
          )}
        </div>

        {/* Year Dropdown */}
        <div className="relative" ref={yearDropdownRef}>
          <button
            onClick={() => {
              setShowYearDropdown(!showYearDropdown)
              setShowGenreDropdown(false)
              setShowSortDropdown(false)
            }}
            className="px-4 py-2 rounded-lg bg-white/5 border border-white/10 text-gray-300 hover:bg-white/10 transition-colors flex items-center gap-2"
          >
            <span className="text-sm font-medium">
              {selectedYear ? `Year: ${selectedYear}` : 'All Years'}
            </span>
            <ChevronDown
              size={16}
              className={`transition-transform ${showYearDropdown ? 'rotate-180' : ''}`}
            />
          </button>

          {showYearDropdown && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="absolute top-full mt-2 w-48 rounded-lg bg-black/90 backdrop-blur-xl border border-white/10 shadow-lg z-50 max-h-64 overflow-y-auto"
            >
              <button
                onClick={() => {
                  setSelectedYear(null)
                  setShowYearDropdown(false)
                }}
                className={`w-full text-left px-4 py-2 text-sm transition-colors ${
                  !selectedYear
                    ? 'bg-violet-500/20 text-violet-400'
                    : 'text-gray-300 hover:bg-white/5'
                }`}
              >
                All Years
              </button>
              {years.map((year) => (
                <button
                  key={year}
                  onClick={() => {
                    setSelectedYear(year)
                    setShowYearDropdown(false)
                  }}
                  className={`w-full text-left px-4 py-2 text-sm transition-colors ${
                    selectedYear === year
                      ? 'bg-violet-500/20 text-violet-400'
                      : 'text-gray-300 hover:bg-white/5'
                  }`}
                >
                  {year}
                </button>
              ))}
            </motion.div>
          )}
        </div>

        {/* Sort Dropdown */}
        <div className="relative" ref={sortDropdownRef}>
          <button
            onClick={() => {
              setShowSortDropdown(!showSortDropdown)
              setShowGenreDropdown(false)
              setShowYearDropdown(false)
            }}
            className="px-4 py-2 rounded-lg bg-white/5 border border-white/10 text-gray-300 hover:bg-white/10 transition-colors flex items-center gap-2"
          >
            <span className="text-sm font-medium">
              Sort: {sortOptions.find((opt) => opt.value === sortBy)?.label}
            </span>
            <ChevronDown
              size={16}
              className={`transition-transform ${showSortDropdown ? 'rotate-180' : ''}`}
            />
          </button>

          {showSortDropdown && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              className="absolute top-full mt-2 w-48 rounded-lg bg-black/90 backdrop-blur-xl border border-white/10 shadow-lg z-50"
            >
              {sortOptions.map((option) => (
                <button
                  key={option.value}
                  onClick={() => {
                    setSortBy(option.value)
                    setShowSortDropdown(false)
                  }}
                  className={`w-full text-left px-4 py-2 text-sm transition-colors ${
                    sortBy === option.value
                      ? 'bg-violet-500/20 text-violet-400'
                      : 'text-gray-300 hover:bg-white/5'
                  }`}
                >
                  {option.label}
                </button>
              ))}
            </motion.div>
          )}
        </div>
      </motion.div>

      {/* Search Results */}
      {hasSearchQuery && (
        <div className="space-y-4">
          <h2 className="text-2xl font-bold bg-gradient-to-r from-violet-400 to-blue-400 bg-clip-text text-transparent">
            Search Results
          </h2>

          {/* Show full-page loader only on initial load (when no results yet) */}
          {isLoading && searchResults.length === 0 && (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="w-8 h-8 text-violet-400 animate-spin" />
            </div>
          )}

          {error && !isLoading && (
            <div className="flex items-center justify-center py-12">
              <p className="text-red-400 text-sm">{error}</p>
            </div>
          )}

          {/* Show results even when loading more (grid stays visible) */}
          {!error && searchResults.length > 0 && (
            <>
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6"
              >
                {searchResults.map((anime, index) => (
                  <AnimeCard
                    key={`${anime.id}-${index}`}
                    anime={anime}
                    index={index}
                    onAdd={handleAddToLibrary}
                    onClick={handleCardClick}
                  />
                ))}
              </motion.div>

              {/* LOAD MORE BUTTON */}
              {hasMore && (
                <div className="flex justify-center pt-8 pb-4">
                  <button
                    onClick={loadMore}
                    disabled={isLoading}
                    className="px-6 py-3 bg-white/5 hover:bg-white/10 border border-white/10 rounded-full text-white font-semibold transition-all flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {isLoading ? (
                      <>
                        <Loader2 className="animate-spin" size={18} />
                        Loading...
                      </>
                    ) : (
                      'Load More Anime'
                    )}
                  </button>
                </div>
              )}
            </>
          )}

          {!isLoading && !error && searchResults.length === 0 && (
            <div className="flex flex-col items-center justify-center py-12 text-gray-400">
              <Search size={48} className="mb-4 opacity-50" />
              <p className="text-lg">No results found</p>
              <p className="text-sm mt-2">Try a different search term or filter</p>
            </div>
          )}
        </div>
      )}

      {/* Trending Now + Top Rated (when no search) - Grid Layout */}
      {!hasSearchQuery && (
        <div className="grid grid-cols-1 lg:grid-cols-10 gap-8">
          {/* Main Column - Trending Now (70%) */}
          <div className="lg:col-span-7 space-y-4">
            <h2 className="text-2xl font-bold bg-gradient-to-r from-violet-400 to-blue-400 bg-clip-text text-transparent">
              Trending Now
            </h2>

            {isLoadingTrending && (
              <div className="flex items-center justify-center py-12">
                <Loader2 className="w-8 h-8 text-violet-400 animate-spin" />
              </div>
            )}

            {!isLoadingTrending && trendingAnime.length > 0 && (
              <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"
              >
                {trendingAnime.map((anime, index) => (
                  <AnimeCard
                    key={anime.id}
                    anime={anime}
                    index={index}
                    onAdd={handleAddToLibrary}
                    onClick={handleCardClick}
                  />
                ))}
              </motion.div>
            )}
          </div>

          {/* Right Sidebar - Top Rated (30%) */}
          <div className="lg:col-span-3 space-y-4">
            <h2 className="text-2xl font-bold bg-gradient-to-r from-violet-400 to-blue-400 bg-clip-text text-transparent">
              Top Rated
            </h2>

            {isLoadingTopRated && (
              <div className="flex items-center justify-center py-12">
                <Loader2 className="w-8 h-8 text-violet-400 animate-spin" />
              </div>
            )}

            {!isLoadingTopRated && topRatedAnime.length > 0 && (
              <div className="space-y-2">
                {topRatedAnime.map((anime, index) => (
                  <TopRatedItem
                    key={anime.id}
                    anime={anime}
                    rank={index + 1}
                    onClick={handleCardClick}
                  />
                ))}
              </div>
            )}
          </div>
        </div>
      )}

      {/* Anime Details Modal */}
      <AnimeDetailsModal
        anime={selectedAnime}
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false)
          setSelectedAnime(null)
        }}
        onStatusChange={handleStatusChange}
      />

      {/* Toast Notification */}
      <Toast
        message={toastMessage}
        isVisible={toastVisible}
        onClose={() => setToastVisible(false)}
      />
    </div>
  )
}

export default Discover


========================================

=== apps\desktop\src\renderer\components\HomeDashboard.tsx ===

import { motion } from 'framer-motion'
import { Loader2, Star } from 'lucide-react'
import { useState, useEffect } from 'react'
import type { Anime } from '@anivault/shared'
import { anilistService } from '../services/anilist.service'
import { useStore } from '../store/useStore'
import Toast from './Toast'
import AnimeDetailsModal from './AnimeDetailsModal'

interface AnimeCardProps {
  anime: Anime
  index: number
  onAdd: (anime: Anime) => void
  onClick: (anime: Anime) => void
}

const AnimeCard = ({ anime, index, onAdd, onClick }: AnimeCardProps) => {
  const [isHovered, setIsHovered] = useState(false)

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.9 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ delay: index * 0.05 }}
      className="relative group cursor-pointer"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <motion.div
        whileHover={{ scale: 1.05 }}
        onClick={() => onClick(anime)}
        className="relative aspect-[2/3] rounded-lg overflow-hidden transition-all duration-300 cursor-pointer"
        style={{
          boxShadow: isHovered
            ? '0 0 30px rgba(139, 92, 246, 0.6), 0 0 60px rgba(139, 92, 246, 0.3)'
            : '0 4px 6px rgba(0, 0, 0, 0.3)',
        }}
      >
        {/* Poster Image */}
        <div className="absolute inset-0">
          <img
            src={anime.coverImage || 'https://via.placeholder.com/300x450'}
            alt={anime.title}
            className="w-full h-full object-cover"
            onError={(e) => {
              ;(e.target as HTMLImageElement).src = 'https://via.placeholder.com/300x450/1a1a1a/8b5cf6?text=No+Image'
            }}
          />
          {/* Gradient Overlay */}
          <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent" />
        </div>

        {/* Content */}
        <div className="absolute bottom-0 left-0 right-0 p-4 z-10">
          <h3 className="text-white font-semibold text-sm mb-1 line-clamp-2">
            {anime.titleEnglish || anime.title}
          </h3>
          {anime.rating && (
            <div className="flex items-center gap-1 text-xs text-gray-300">
              <span className="text-violet-400">â˜…</span>
              <span>{anime.rating.toFixed(1)}</span>
            </div>
          )}
        </div>
      </motion.div>
    </motion.div>
  )
}

interface TopRatedItemProps {
  anime: Anime
  rank: number
  onClick: (anime: Anime) => void
}

const TopRatedItem = ({ anime, rank, onClick }: TopRatedItemProps) => {
  return (
    <motion.div
      initial={{ opacity: 0, x: -10 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ delay: rank * 0.1 }}
      onClick={() => onClick(anime)}
      className="flex items-center gap-3 p-3 rounded-lg bg-white/5 hover:bg-white/10 transition-colors cursor-pointer group"
    >
      {/* Rank Badge */}
      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-violet-500/20 border border-violet-500/30 flex items-center justify-center text-violet-400 font-bold text-sm">
        {rank}
      </div>

      {/* Cover Image */}
      <div className="flex-shrink-0 w-16 h-24 rounded overflow-hidden">
        <img
          src={anime.coverImage || 'https://via.placeholder.com/300x450'}
          alt={anime.title}
          className="w-full h-full object-cover"
          onError={(e) => {
            ;(e.target as HTMLImageElement).src = 'https://via.placeholder.com/300x450/1a1a1a/8b5cf6?text=No+Image'
          }}
        />
      </div>

      {/* Info */}
      <div className="flex-1 min-w-0">
        <h4 className="text-white font-semibold text-sm line-clamp-2 group-hover:text-violet-400 transition-colors">
          {anime.titleEnglish || anime.title}
        </h4>
        {anime.rating && (
          <div className="flex items-center gap-1 mt-1">
            <Star size={14} className="text-violet-400" />
            <span className="text-xs text-gray-400">{(anime.rating * 10).toFixed(0)}</span>
          </div>
        )}
      </div>
    </motion.div>
  )
}

const HomeDashboard = () => {
  const [trendingAnime, setTrendingAnime] = useState<Anime[]>([])
  const [topRatedAnime, setTopRatedAnime] = useState<Anime[]>([])
  const [isLoadingTrending, setIsLoadingTrending] = useState(true)
  const [isLoadingTopRated, setIsLoadingTopRated] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [toastVisible, setToastVisible] = useState(false)
  const [toastMessage, setToastMessage] = useState('')
  const [selectedAnime, setSelectedAnime] = useState<Anime | null>(null)
  const [isModalOpen, setIsModalOpen] = useState(false)
  const { accessToken, addToLibrary } = useStore()

  const handleAddToLibrary = async (anime: Anime) => {
    try {
      await addToLibrary(anime, 'plan-to-watch')
      setToastMessage('Added to Library')
      setToastVisible(true)
    } catch (error) {
      console.error('Failed to add to library:', error)
    }
  }

  const handleCardClick = (anime: Anime) => {
    setSelectedAnime(anime)
    setIsModalOpen(true)
  }

  const handleStatusChange = (message: string) => {
    setToastMessage(message)
    setToastVisible(true)
  }

  useEffect(() => {
    const fetchData = async () => {
      try {
        setIsLoadingTrending(true)
        setIsLoadingTopRated(true)
        setError(null)

        // Set token if available (public endpoints work without token)
        if (accessToken) {
          anilistService.setAccessToken(accessToken)
        } else {
          // Clear token for guest mode
          anilistService.setAccessToken(null)
        }

        // Fetch trending (20 items) - works without authentication
        const trendingData = await anilistService.getTrendingAnime(20)
        setTrendingAnime(trendingData)

        // Fetch top rated (10 items) - works without authentication
        const topRatedData = await anilistService.getTopRatedAnime(10)
        setTopRatedAnime(topRatedData)
      } catch (err) {
        console.error('Failed to fetch data:', err)
        setError(err instanceof Error ? err.message : 'Failed to load anime')
      } finally {
        setIsLoadingTrending(false)
        setIsLoadingTopRated(false)
      }
    }

    fetchData()
  }, [accessToken])

  return (
    <div className="space-y-8">
      {/* Two Column Layout */}
      <div className="grid grid-cols-1 lg:grid-cols-10 gap-8">
        {/* Left Column - Trending Now (70%) */}
        <div className="lg:col-span-7 space-y-4">
          <h2 className="text-2xl font-bold bg-gradient-to-r from-violet-400 to-blue-400 bg-clip-text text-transparent">
            Trending Now
          </h2>

          {isLoadingTrending && (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="w-8 h-8 text-violet-400 animate-spin" />
            </div>
          )}

          {error && !isLoadingTrending && (
            <div className="flex items-center justify-center py-12">
              <p className="text-red-400 text-sm">{error}</p>
            </div>
          )}

          {!isLoadingTrending && !error && trendingAnime.length > 0 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"
            >
              {trendingAnime.slice(0, 12).map((anime, index) => (
                <AnimeCard
                  key={anime.id}
                  anime={anime}
                  index={index}
                  onAdd={handleAddToLibrary}
                  onClick={handleCardClick}
                />
              ))}
            </motion.div>
          )}
        </div>

        {/* Right Column - Top Rated (30%) */}
        <div className="lg:col-span-3 space-y-4">
          <h2 className="text-2xl font-bold bg-gradient-to-r from-violet-400 to-blue-400 bg-clip-text text-transparent">
            Top Rated
          </h2>

          {isLoadingTopRated && (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="w-8 h-8 text-violet-400 animate-spin" />
            </div>
          )}

          {!isLoadingTopRated && topRatedAnime.length > 0 && (
            <div className="space-y-2">
              {topRatedAnime.map((anime, index) => (
                <TopRatedItem
                  key={anime.id}
                  anime={anime}
                  rank={index + 1}
                  onClick={handleCardClick}
                />
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Anime Details Modal */}
      <AnimeDetailsModal
        anime={selectedAnime}
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false)
          setSelectedAnime(null)
        }}
        onStatusChange={handleStatusChange}
      />

      {/* Toast Notification */}
      <Toast
        message={toastMessage}
        isVisible={toastVisible}
        onClose={() => setToastVisible(false)}
      />
    </div>
  )
}

export default HomeDashboard



========================================

=== apps\desktop\src\renderer\components\Layout.tsx ===

import { motion, AnimatePresence } from 'framer-motion'
import { useState, useEffect } from 'react'
import Sidebar from './Sidebar'
import SearchBar from './SearchBar'
import TitleBar from './TitleBar'
import Library from './Library'
import Discover from './Discover'
import WelcomeScreen from './WelcomeScreen'
import HomeDashboard from './HomeDashboard'
import Toast from './Toast'
import AnimeMatchModal from './AnimeMatchModal'
import LicenseSettings from './LicenseSettings'
import StatsDashboard from './StatsDashboard'
import ThemeSelector from './settings/ThemeSelector'
import AutoOrganizerPanel from './AutoOrganizerPanel'
import { useStore } from '../store/useStore'
import { anilistService } from '../services/anilist.service'
import { resolveFranchiseEpisode } from '../services/tracking.service'
import { convertGlobalToSeasonEpisode } from '@anivault/shared'
import type { WatchEvent } from '../services/stats.service'

function computeEpisodesToday(events: WatchEvent[]): number {
  if (!events || events.length === 0) return 0
  const todayStr = new Date().toISOString().slice(0, 10)
  return events.filter((ev) => ev.at.startsWith(todayStr)).length
}

function computeEpisodesThisSession(events: WatchEvent[]): number {
  if (!events || events.length === 0) return 0
  const now = Date.now()
  const twoHoursAgo = now - 2 * 60 * 60 * 1000
  return events.filter((ev) => new Date(ev.at).getTime() >= twoHoursAgo).length
}

function inferMoodLabel(): { label?: string; emoji?: string } {
  const hour = new Date().getHours()
  if (hour >= 22 || hour < 3) return { label: 'Late night anime', emoji: 'ğŸŒ™' }
  if (hour >= 18 && hour < 22) return { label: 'Evening binge', emoji: 'ğŸ”¥' }
  if (hour >= 12 && hour < 18) return { label: 'Daytime chill', emoji: 'ğŸ˜Œ' }
  return { label: 'Anime break', emoji: 'ğŸ§' }
}

const Layout = () => {
  const [heroImage, setHeroImage] = useState<string | null>(null)
  const [currentPage, setCurrentPage] = useState('home') // <--- State to track the page
  const [searchQuery, setSearchQuery] = useState('') // <--- Search query for discover page
  const [toastVisible, setToastVisible] = useState(false)
  const [toastMessage, setToastMessage] = useState('')
  const [matchModalOpen, setMatchModalOpen] = useState(false)
  const [pendingDetection, setPendingDetection] = useState<{ title: string; episode: number } | null>(null)
  const {
    isAuthenticated,
    isGuest,
    library,
    accessToken,
    updateProgress,
    findAnimeByTitle,
    addMapping,
    addToLibrary,
    login,
    logout,
    user,
    isPro,
    theme,
    discordPresenceEnabled,
    discordPresenceMode,
    discordPresenceUseMood,
    discordPresenceShowButtons,
    setDiscordPresenceEnabled,
    setDiscordPresenceMode,
    setDiscordPresenceUseMood,
    setDiscordPresenceShowButtons,
    lastPresenceContext,
    setLastPresenceContext,
    watchEvents,
  } = useStore()

  const pushPresenceConfig = (partial?: Partial<{
    enabled: boolean
    mode: 'minimal' | 'stats' | 'weeb'
    useMood: boolean
    showButtons: boolean
  }>) => {
    if (!window.electron?.presence) return
    void window.electron.presence.updateConfig({
      enabled: partial?.enabled ?? discordPresenceEnabled,
      mode: partial?.mode ?? discordPresenceMode,
      useMood: partial?.useMood ?? discordPresenceUseMood,
      showButtons: partial?.showButtons ?? discordPresenceShowButtons,
    })
  }

  const sendPresenceUpdate = (title: string, episode: number, totalEpisodes?: number) => {
    if (!window.electron?.presence) return
    if (!discordPresenceEnabled) return

    const episodesToday = computeEpisodesToday(watchEvents || [])
    const episodesThisSession = computeEpisodesThisSession(watchEvents || [])
    const moodInfo = discordPresenceUseMood && isPro ? inferMoodLabel() : { label: undefined, emoji: undefined }

    // push config
    pushPresenceConfig()

    // push current context
    void window.electron.presence.updateNow({
      title,
      episode,
      totalEpisodes,
      episodesThisSession,
      episodesToday,
      moodLabel: moodInfo.label,
      moodEmoji: moodInfo.emoji,
      themeId: theme,
      isPro,
    })

    setLastPresenceContext({ title, episode, totalEpisodes })
  }

  // Clear search when navigating to a different page
  const handleNavigate = (page: string) => {
    setSearchQuery('') // Always clear search when navigating
    setCurrentPage(page)
  }

  // Listen for tracking updates from main process
  useEffect(() => {
    if (!isAuthenticated && !isGuest) return

    const handleTrackingUpdate = async (data: { 
      title: string
      episode: number
      overallEpisode?: number
      seasonNumber?: number
      seasonEpisode?: number
      source?: string
      platform?: string
    }) => {
      console.log('[AniVault] Renderer received tracking update:', data)
      
      setToastMessage(`Detected ${data.title} Ep ${data.episode}. Matching...`)
      setToastVisible(true)

      // Try to find matching anime in library
      let matchingAnime = findAnimeByTitle(data.title)
      
      // STRICT season verification - never update the wrong season
      if (matchingAnime && data.seasonNumber) {
        const animeTitle = matchingAnime.title.toLowerCase()
        const detectedSeason = data.seasonNumber
        
        console.log(`[AniVault] Verifying season match:`, {
          detected: `Season ${detectedSeason}`,
          foundTitle: matchingAnime.title
        })
        
        // For Season 1: match if title has NO season number OR has "Season 1"
        if (detectedSeason === 1) {
          const hasNoSeasonSuffix = !animeTitle.match(/season\s+\d+/i) && !animeTitle.match(/\s+s\d+/i) && !animeTitle.match(/part\s+\d+/i)
          const hasSeasonOne = animeTitle.includes('season 1') || animeTitle.includes(' s1') || animeTitle.includes('part 1')
          
          if (!hasNoSeasonSuffix && !hasSeasonOne) {
            console.log(`[AniVault] âŒ Found "${matchingAnime.title}" but it's not Season 1, searching for S1...`)
            matchingAnime = null
          } else {
            console.log(`[AniVault] âœ… Verified as Season 1`)
          }
        } else {
          // For Season 2+: must have explicit season number in title
          const hasCorrectSeason = animeTitle.includes(`season ${detectedSeason}`) || 
                                   animeTitle.includes(` s${detectedSeason} `) ||
                                   animeTitle.includes(` s${detectedSeason}:`) ||
                                   animeTitle.match(new RegExp(`\\bs${detectedSeason}\\b`, 'i')) ||
                                   animeTitle.includes(`part ${detectedSeason}`)
          
          if (!hasCorrectSeason) {
            console.log(`[AniVault] âŒ Found "${matchingAnime.title}" but doesn't match Season ${detectedSeason}, searching for correct season...`)
            matchingAnime = null
          } else {
            console.log(`[AniVault] âœ… Verified as Season ${detectedSeason}`)
          }
        }
      }

      // If no match in library, try smart AniList search
      if (!matchingAnime) {
        console.log('[AniVault] No library match, searching AniList...')
        try {
          // Include season in search query if available
          let searchQuery = data.title
          if (data.seasonNumber && data.seasonNumber > 1) {
            searchQuery = `${data.title} Season ${data.seasonNumber}`
            console.log(`[AniVault] Including season in search: "${searchQuery}"`)
          }
          
          const results = await anilistService.searchAnime(searchQuery, {}, 1, 10)
          console.log(`[AniVault] AniList search for "${searchQuery}" returned ${results.length} results`)
          
          // Filter results by season if specified
          let filteredResults = results
          if (data.seasonNumber) {
            filteredResults = results.filter(result => {
              const title = result.title.toLowerCase()
              
              if (data.seasonNumber === 1) {
                // Season 1: accept if no season suffix OR has "Season 1"
                const hasNoSeason = !title.match(/season\s+\d+/i) && !title.match(/\s+s\d+/i)
                const hasSeason1 = title.includes('season 1') || title.match(/\bs1\b/i) || title.includes('part 1')
                return hasNoSeason || hasSeason1
              } else {
                // Season 2+: must have correct season number
                return title.includes(`season ${data.seasonNumber}`) ||
                       title.match(new RegExp(`\\bs${data.seasonNumber}\\b`, 'i')) ||
                       title.includes(`part ${data.seasonNumber}`)
              }
            })
            console.log(`[AniVault] Filtered to ${filteredResults.length} results matching Season ${data.seasonNumber}`)
          }
          
          // Smart auto-match
          if (filteredResults.length > 0) {
            const bestMatch = filteredResults[0]
            const detectedTitleLower = data.title.toLowerCase()
            const resultTitleLower = bestMatch.title.toLowerCase()
            const resultEnglishLower = bestMatch.titleEnglish?.toLowerCase() || ''
            
            // Check for exact or very close match
            const isExactMatch = resultTitleLower === detectedTitleLower || 
                                resultEnglishLower === detectedTitleLower ||
                                resultTitleLower.includes(detectedTitleLower) ||
                                detectedTitleLower.includes(resultTitleLower)
            
            // Auto-select if only 1 filtered result OR exact match
            if (filteredResults.length === 1 || isExactMatch) {
              console.log('[AniVault] âœ… Smart auto-match found:', bestMatch.title)
              
              // Add to library as "watching"
              await addToLibrary(bestMatch, 'watching')
              
              // Create mapping for future
              addMapping(data.title, bestMatch.id)
              
              matchingAnime = bestMatch
            } else {
              console.log(`[AniVault] Multiple filtered results (${filteredResults.length}), showing modal`)
              console.log('[AniVault] Best match:', bestMatch.title, '| isExactMatch:', isExactMatch)
              setPendingDetection(data)
              setMatchModalOpen(true)
              return
            }
          } else {
            console.log('[AniVault] No season-matching results from AniList, showing modal')
            setPendingDetection(data)
            setMatchModalOpen(true)
            return
          }
        } catch (error) {
          console.error('[AniVault] AniList search failed:', error)
          setPendingDetection(data)
          setMatchModalOpen(true)
          return
        }
      }

          if (matchingAnime) {
        console.log(`[AniVault] âœ… Matched anime: ${matchingAnime.title}`)
        
        const totalEpisodes = (matchingAnime as any).episodes as number | undefined
        let nextEpisode = data.episode
        let finalAnime = matchingAnime
        let resolvedSeasonEpisode: number | null = null
        let resolvedSeasonNumber: number | null = data.seasonNumber ?? null
        
        // CRITICAL SAFEGUARD: Double-check season match before ANY updates
        if (data.seasonNumber) {
          const animeTitle = matchingAnime.title.toLowerCase()
          const detectedSeason = data.seasonNumber
          let seasonVerified = false
          
          if (detectedSeason === 1) {
            // Season 1: title should have no season suffix OR "Season 1"
            const hasNoSeason = !animeTitle.match(/season\s+[2-9]/i) && !animeTitle.match(/\bs[2-9]\b/i)
            const hasSeason1 = animeTitle.includes('season 1') || animeTitle.match(/\bs1\b/i)
            seasonVerified = hasNoSeason || hasSeason1
          } else {
            // Season 2+: title must have the exact season number
            seasonVerified = animeTitle.includes(`season ${detectedSeason}`) ||
                           animeTitle.match(new RegExp(`\\bs${detectedSeason}\\b`, 'i')) !== null ||
                           animeTitle.includes(`part ${detectedSeason}`)
          }
          
          if (!seasonVerified) {
            console.error(`[AniVault] âŒ SEASON MISMATCH: Matched "${matchingAnime.title}" but detection says Season ${detectedSeason}!`)
            console.error(`[AniVault] This would update the WRONG season. Aborting and showing modal.`)
            setPendingDetection(data)
            setMatchModalOpen(true)
            return
          }
          
          console.log(`[AniVault] âœ… Season ${detectedSeason} verified for: ${matchingAnime.title}`)
        }

        // If Crunchyroll sent global numbering + season, convert to season-local episode using per-season counts
        if (data.overallEpisode && data.seasonNumber) {
          try {
            const timeline = await anilistService.getFranchiseTimeline(parseInt(matchingAnime.id))
            if (timeline && timeline.length >= data.seasonNumber) {
              const episodeCounts = timeline.map((s) => (s as any).episodes || 0)
              const seasonEpisode = convertGlobalToSeasonEpisode(data.overallEpisode, data.seasonNumber, episodeCounts)
              const seasonAnime = timeline[data.seasonNumber - 1]

              console.log(
                `[AniVault] [Season-Fix] Global E${data.overallEpisode} -> S${data.seasonNumber}E${seasonEpisode} using counts`,
                episodeCounts
              )

              if (seasonAnime) {
                finalAnime = seasonAnime
                nextEpisode = seasonEpisode
                resolvedSeasonEpisode = seasonEpisode
                resolvedSeasonNumber = data.seasonNumber

                const inLib = library.find((a) => a.id === seasonAnime.id)
                if (!inLib) {
                  console.log(`[AniVault] Adding season entry to library: ${seasonAnime.title}`)
                  await addToLibrary(seasonAnime, 'watching')
                }
              }
            }
          } catch (err) {
            console.warn('[AniVault] Season conversion failed, falling back to existing logic:', err)
          }
        }
        
        // CRITICAL: Determine if we need franchise resolution
        // Some shows use continuous numbering (Kaiju: E1-E12 S1, E13+ S2)
        // Others use per-season numbering (OPM: S1 E1-E12, S2 E1-E12, S3 E1-E12)
        
        // Heuristic for continuous numbering:
        // 1. Episode exceeds matched anime's total episodes (e.g., E19 for S2 with 11 eps), OR
        // 2. Episode > 24 AND we have season info (likely continuous), OR
        // 3. We're in Season 2+ but episode is way higher than expected
        const needsResolution = data.overallEpisode && (
          (totalEpisodes && data.overallEpisode > totalEpisodes) ||
          (data.overallEpisode > 24 && data.seasonNumber && data.seasonNumber > 1)
        )
        
        console.log(`[AniVault] Episode resolution check:`, {
          overallEpisode: data.overallEpisode,
          seasonNumber: data.seasonNumber,
          matchedAnimeTotal: totalEpisodes,
          needsResolution
        })
        
        if (needsResolution) {
          console.log(`[AniVault] ğŸ”„ Using franchise resolver for global episode ${data.overallEpisode}`)
          console.log(`[AniVault] Initial match: ${matchingAnime.title} (${matchingAnime.id})`)
          
          try {
            // Get full franchise timeline (all seasons in order)
            console.log(`[AniVault] Fetching franchise timeline...`)
            const timeline = await anilistService.getFranchiseTimeline(parseInt(matchingAnime.id))
            console.log(`[AniVault] Timeline fetched: ${timeline.length} season(s)`)
            timeline.forEach((s, i) => {
              console.log(`  [${i + 1}] ${s.title} - ${(s as any).episodes || '?'} episodes`)
            })
            
            if (timeline.length > 1) {
              // Multi-season franchise - resolve to correct season
              console.log(`[AniVault] Resolving episode ${data.overallEpisode} across ${timeline.length} seasons...`)
              const resolved = resolveFranchiseEpisode(timeline, data.overallEpisode)
              
              if (resolved) {
                console.log(`[AniVault] âœ… [SmartTrack] Mapped Absolute Ep ${data.overallEpisode} to ${resolved.title} Ep ${resolved.episode}`)
                
                // Use the resolved season and episode
                const correctSeason = timeline.find(a => a.id === resolved.animeId)
                if (correctSeason) {
                  finalAnime = correctSeason
                  nextEpisode = resolved.episode
                  
                  // Check if it's in library, if not add it
                  const inLibrary = library.find(a => a.id === correctSeason.id)
                  if (!inLibrary) {
                    console.log(`[AniVault] Adding ${correctSeason.title} to library as "watching"`)
                    await addToLibrary(correctSeason, 'watching')
                  }
                  
                  console.log(`[AniVault] Will update: ${finalAnime.title} to ${nextEpisode}/${(finalAnime as any).episodes}`)
                } else {
                  console.warn('[AniVault] Could not find resolved season in timeline')
                }
              } else {
                console.warn('[AniVault] Resolver returned null, using original episode')
              }
            } else {
              // Single season, use episode as-is
              console.log(`[AniVault] Single-season anime, using episode ${data.overallEpisode} as-is`)
            }
          } catch (err) {
            console.error('[AniVault] âŒ Failed to fetch franchise timeline:', err)
            console.warn('[AniVault] Falling back to original episode number')
          }
        } else if (data.seasonNumber) {
          // Has season number but doesn't need resolution
          // This is likely per-season numbering (e.g., OPM S3 E7)
          console.log(`[AniVault] âœ… Per-season numbering detected (S${data.seasonNumber} E${data.episode}), using episode as-is`)
        }
        
        // Final episode validation - don't clamp if it seems correct
        const finalTotalEpisodes = (finalAnime as any).episodes as number | undefined
        if (finalTotalEpisodes && nextEpisode > finalTotalEpisodes) {
          console.log(`[AniVault] âš ï¸ Episode ${nextEpisode} still exceeds total ${finalTotalEpisodes} after resolution, clamping`)
          nextEpisode = finalTotalEpisodes
        }
        
        console.log(`[AniVault] ğŸ“ Updating progress:`, {
          id: finalAnime.id,
          title: finalAnime.title,
          episode: nextEpisode,
          totalEpisodes: finalTotalEpisodes,
          displayAs: `${nextEpisode}/${finalTotalEpisodes || '?'}`
        })
        
        // Update progress and ensure status is "watching"
        try {
          await updateProgress(finalAnime.id, { progress: nextEpisode, status: 'watching' }, 'desktop')
          setToastMessage(`Updated ${finalAnime.title} to Episode ${nextEpisode}/${finalTotalEpisodes || '?'}`)
          sendPresenceUpdate(finalAnime.title, nextEpisode, finalTotalEpisodes)
        } catch (error) {
          console.error('Failed to update progress:', error)
          setToastMessage(`Failed to update ${finalAnime.title}`)
        }
      }
    }

    console.log('[AniVault] ğŸ§ Attaching tracking:detected listener...')
    window.electron.tracking.onUpdate(handleTrackingUpdate)

    // Test IPC connection
    console.log('[AniVault] Tracking listener attached, waiting for events...')

    return () => {
      console.log('[AniVault] Removing tracking listener')
      window.electron.tracking.removeListener()
    }
  }, [isAuthenticated, isGuest, accessToken, findAnimeByTitle, updateProgress, addToLibrary, addMapping, library])

  // Clear old presence context on app startup if no recent activity
  useEffect(() => {
    if (lastPresenceContext && watchEvents) {
      const hasRecentActivity = watchEvents.length > 0 && 
        watchEvents[watchEvents.length - 1] &&
        Date.now() - new Date(watchEvents[watchEvents.length - 1].at).getTime() < 60000 // Within last minute

      if (!hasRecentActivity) {
        // Clear old presence context on startup
        setLastPresenceContext(undefined)
      }
    }
  }, []) // Only run on mount

  // Re-send presence when mode/toggles change (and we have last context)
  // Only if we're actively watching
  useEffect(() => {
    if (!discordPresenceEnabled) return
    if (!lastPresenceContext) return
    if (!window.electron?.presence) return

    // Only update if there's recent activity (actively watching)
    const hasRecentActivity = watchEvents && watchEvents.length > 0 && 
      watchEvents[watchEvents.length - 1] &&
      Date.now() - new Date(watchEvents[watchEvents.length - 1].at).getTime() < 60000 // Within last minute

    if (!hasRecentActivity) {
      return // Don't restore old presence
    }

    pushPresenceConfig()
    sendPresenceUpdate(
      lastPresenceContext.title,
      lastPresenceContext.episode,
      lastPresenceContext.totalEpisodes
    )
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [discordPresenceMode, discordPresenceUseMood, discordPresenceShowButtons])

  // Handle anime match from modal
  const handleAnimeMatch = async (anime: any, episode: number) => {
    try {
      console.log('[AniVault] User selected from modal:', anime.title, 'Ep', episode)
      
      // Add mapping for future detections
      addMapping(pendingDetection?.title || '', anime.id)

      // Check if anime is in library
      const libraryEntry = library.find((a) => a.id === anime.id)
      
      if (!libraryEntry) {
        // Add to library as "watching"
        console.log('[AniVault] Adding to library as "watching"')
        await addToLibrary(anime, 'watching')
      }

      // Determine if we need franchise resolution
      let nextEpisode = episode
      const totalEpisodes = (anime as any).episodes as number | undefined
      const overallEp = (pendingDetection as any)?.overallEpisode
      const seasonNum = (pendingDetection as any)?.seasonNumber
      
      // Heuristic: Only use franchise resolver if episode > 24 OR exceeds total
      // This avoids wrongly resolving per-season numbered shows (like OPM S3 E7)
      const needsResolution = overallEp && (
        overallEp > 24 || 
        (totalEpisodes && overallEp > totalEpisodes)
      )
      
      if (needsResolution) {
        console.log(`[AniVault] Modal: Using franchise resolver for global episode ${overallEp}`)
        
        try {
          const timeline = await anilistService.getFranchiseTimeline(parseInt(anime.id))
          console.log(`[AniVault] Timeline fetched: ${timeline.length} season(s)`)
          
          if (timeline.length > 1) {
            const resolved = resolveFranchiseEpisode(timeline, overallEp)
            if (resolved) {
              console.log(`[AniVault] âœ… [SmartTrack Modal] Mapped Absolute Ep ${overallEp} to ${resolved.title} Ep ${resolved.episode}`)
              nextEpisode = resolved.episode
              
              // If resolved to a different season, update the anime reference
              if (resolved.animeId !== anime.id) {
                const correctSeason = timeline.find(a => a.id === resolved.animeId)
                if (correctSeason) {
                  console.log(`[AniVault] Switching to correct season: ${correctSeason.title}`)
                  anime = correctSeason
                  const inLib = library.find(a => a.id === correctSeason.id)
                  if (!inLib) {
                    await addToLibrary(correctSeason, 'watching')
                  }
                }
              }
            }
          }
        } catch (err) {
          console.warn('[AniVault] Failed franchise resolution in modal, using original:', err)
        }
      } else if (seasonNum) {
        // Per-season numbering (e.g., OPM S3 E7) - use episode as-is
        console.log(`[AniVault] âœ… Per-season numbering (S${seasonNum} E${episode}), using episode as-is`)
      }

      // Final clamp check
      const finalTotalEpisodes = (anime as any).episodes as number | undefined
      if (finalTotalEpisodes && nextEpisode > finalTotalEpisodes) {
        console.log(`[AniVault] Episode ${nextEpisode} exceeds total ${finalTotalEpisodes}, clamping`)
        nextEpisode = finalTotalEpisodes
      }

      // Update progress and force status to "watching"
      console.log('[AniVault] Updating progress to episode', nextEpisode, 'of', finalTotalEpisodes)
      await updateProgress(anime.id, { progress: nextEpisode, status: 'watching' }, 'desktop')
      setToastMessage(`Matched and updated ${anime.title} to Episode ${nextEpisode}/${finalTotalEpisodes || '?'}`)
      sendPresenceUpdate(anime.title, nextEpisode, finalTotalEpisodes)
      setToastVisible(true)
    } catch (error) {
      console.error('Failed to match anime:', error)
      setToastMessage(`Failed to match anime`)
      setToastVisible(true)
    }
  }

  // A helper function to render the correct view
  const renderContent = () => {
    switch (currentPage) {
      case 'home':
        return <HomeDashboard />
      case 'library':
        return <Library />
      case 'discover':
        return <Discover initialQuery={searchQuery} />
      case 'stats':
        return <StatsDashboard />
      case 'settings':
        return (
          <div className="max-w-2xl mx-auto mt-10">
            <h2 className="text-3xl font-bold mb-6">Settings</h2>
            
            {/* Account Section */}
            <div className="bg-card/60 rounded-xl p-6 border border-border/60 mb-6">
              <h3 className="text-xl font-semibold mb-4 flex items-center gap-2">
                Account
                {isAuthenticated && (
                  <span className="text-xs bg-green-500/20 text-green-400 px-2 py-0.5 rounded-full">
                    Connected
                  </span>
                )}
              </h3>

              {isAuthenticated && user ? (
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-4">
                    <img
                      src={user.avatar || 'https://via.placeholder.com/100'}
                      alt={user.username}
                      className="w-12 h-12 rounded-full border border-white/20"
                    />
                    <div>
                      <p className="font-bold text-foreground">{user.username}</p>
                      <p className="text-sm text-muted-foreground">Sync is active</p>
                    </div>
                  </div>
                  <button
                    onClick={async () => {
                      try {
                        await logout()
                      } catch (error) {
                        console.error('Logout failed:', error)
                      }
                    }}
                    className="px-4 py-2 bg-red-500/10 text-red-400 border border-red-500/20 rounded-md hover:bg-red-500/20 transition-colors"
                  >
                    Logout
                  </button>
                </div>
              ) : (
                <div className="flex items-center justify-between">
                  <p className="text-muted-foreground text-sm max-w-md">
                    Connect your AniList account to sync your library and unlock cloud features.
                  </p>
                  <button
                    onClick={async () => {
                      try {
                        await login()
                      } catch (error) {
                        console.error('Login failed:', error)
                      }
                    }}
                    className="px-6 py-2.5 bg-violet-600 rounded-lg hover:bg-violet-700 transition-all font-medium shadow-lg shadow-violet-500/20"
                  >
                    Connect AniList
                  </button>
                </div>
              )}
            </div>

            {/* Subscription Section */}
            <div className="bg-card/60 rounded-xl p-6 border border-border/60 mb-6">
              <LicenseSettings />
            </div>

            {/* App Preferences (Placeholder) */}
            <div className="bg-card/60 rounded-xl p-6 border border-border/60">
              <h3 className="text-xl font-semibold mb-4">Application</h3>
              <div className="mb-6">
                <ThemeSelector />
              </div>
              <div className="mb-6 space-y-2">
                <h3 className="text-xl font-semibold">Auto Organizer (Pro)</h3>
                <p className="text-sm text-muted-foreground">
                  Automatically rename and move your downloaded anime into a clean folder structure.
                </p>
                <AutoOrganizerPanel />
              </div>
              <div className="mb-6 space-y-3">
                <div className="flex items-center justify-between">
                  <h4 className="text-sm font-semibold text-foreground flex items-center gap-2">
                    Discord Presence Pro+
                    <span className="rounded-full border border-primary/40 bg-primary/10 px-2 py-0.5 text-[10px] uppercase tracking-wide text-primary">
                      Pro
                    </span>
                  </h4>
                </div>
                {!isPro && (
                  <p className="text-xs text-muted-foreground">
                    Upgrade to AniVault Pro to unlock advanced Discord Rich Presence.
                  </p>
                )}
                {isPro && (
                  <div className="space-y-3">
                    <label className="flex items-center justify-between gap-4 text-sm">
                      <span className="text-muted-foreground">Enable Discord Presence</span>
                      <input
                        type="checkbox"
                        checked={discordPresenceEnabled}
                        onChange={(e) => {
                          setDiscordPresenceEnabled(e.target.checked)
                          pushPresenceConfig({ enabled: e.target.checked })
                          if (e.target.checked && lastPresenceContext) {
                            sendPresenceUpdate(
                              lastPresenceContext.title,
                              lastPresenceContext.episode,
                              lastPresenceContext.totalEpisodes
                            )
                          }
                        }}
                      />
                    </label>

                    <div className="space-y-1">
                      <p className="text-xs font-medium text-muted-foreground">Presence mode</p>
                      <div className="flex flex-wrap gap-2">
                        {(['minimal', 'stats', 'weeb'] as const).map((mode) => (
                          <button
                            key={mode}
                            onClick={() => {
                              setDiscordPresenceMode(mode)
                              pushPresenceConfig({ mode })
                              if (discordPresenceEnabled && lastPresenceContext) {
                                sendPresenceUpdate(
                                  lastPresenceContext.title,
                                  lastPresenceContext.episode,
                                  lastPresenceContext.totalEpisodes
                                )
                              }
                            }}
                            className={[
                              'rounded-full px-3 py-1 text-xs capitalize transition',
                              discordPresenceMode === mode
                                ? 'bg-primary text-primary-foreground shadow shadow-primary/40'
                                : 'bg-card/60 text-muted-foreground border border-border/60 hover:bg-card hover:text-foreground',
                            ].join(' ')}
                          >
                            {mode === 'minimal' && 'Minimal'}
                            {mode === 'stats' && 'Stats Flex'}
                            {mode === 'weeb' && 'Weeb Mode'}
                          </button>
                        ))}
                      </div>
                    </div>

                    <label className="flex items-center justify-between gap-4 text-xs">
                      <span className="text-muted-foreground">Show mood label & emoji</span>
                      <input
                        type="checkbox"
                        checked={discordPresenceUseMood}
                        onChange={(e) => {
                          setDiscordPresenceUseMood(e.target.checked)
                          pushPresenceConfig({ useMood: e.target.checked })
                          if (discordPresenceEnabled && lastPresenceContext) {
                            sendPresenceUpdate(
                              lastPresenceContext.title,
                              lastPresenceContext.episode,
                              lastPresenceContext.totalEpisodes
                            )
                          }
                        }}
                      />
                    </label>

                    <label className="flex items-center justify-between gap-4 text-xs">
                      <span className="text-muted-foreground">Show AniList / AniVault buttons</span>
                      <input
                        type="checkbox"
                        checked={discordPresenceShowButtons}
                        onChange={(e) => {
                          setDiscordPresenceShowButtons(e.target.checked)
                          pushPresenceConfig({ showButtons: e.target.checked })
                          if (discordPresenceEnabled && lastPresenceContext) {
                            sendPresenceUpdate(
                              lastPresenceContext.title,
                              lastPresenceContext.episode,
                              lastPresenceContext.totalEpisodes
                            )
                          }
                        }}
                      />
                    </label>
                  </div>
                )}
              </div>
              <div className="space-y-4">
                <div className="flex items-center justify-between opacity-50">
                  <span className="text-gray-300">Run at Startup</span>
                  <div className="w-10 h-6 bg-white/10 rounded-full relative">
                    <div className="w-4 h-4 bg-gray-500 rounded-full absolute left-1 top-1"></div>
                  </div>
                </div>
                <div className="flex items-center justify-between opacity-50">
                  <span className="text-gray-300">Minimize to Tray</span>
                  <div className="w-10 h-6 bg-white/10 rounded-full relative">
                    <div className="w-4 h-4 bg-gray-500 rounded-full absolute left-1 top-1"></div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )
      default:
        return <div>Page not found</div>
    }
  }

  // Auth Guard: Show WelcomeScreen if not authenticated and not in guest mode
  if (!isAuthenticated && !isGuest) {
    return (
      <div className="h-screen w-screen overflow-hidden bg-background text-foreground">
        <TitleBar />
        <WelcomeScreen />
      </div>
    )
  }

  return (
    <div className="h-screen w-screen overflow-hidden bg-background text-foreground">
      {/* Hero Background Image */}
      {heroImage && (
        <div
          className="absolute inset-0 z-0 opacity-20"
          style={{
            backgroundImage: `url(${heroImage})`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            filter: 'blur(40px) brightness(0.3)',
          }}
        />
      )}

      <div className="absolute inset-0 z-0 bg-gradient-to-b from-primary/20 via-background/40 to-background" />
      <TitleBar />

      <div className="flex h-[calc(100vh-2rem)] relative z-10">
        {/* Pass state down to Sidebar */}
        <Sidebar activePage={currentPage} onNavigate={handleNavigate} />

        <main className="flex-1 flex flex-col overflow-hidden">
          <div className="p-6 backdrop-blur-xl bg-card/40 border-b border-border/60">
            <SearchBar
              value={searchQuery}
              onValueChange={setSearchQuery}
              onSearch={(query) => {
                setSearchQuery(query)
                if (query.trim()) {
                  setCurrentPage('discover')
                }
              }}
            />
          </div>

          <div className="flex-1 overflow-y-auto p-6 scrollbar-hide">
            <AnimatePresence mode="wait">
              <motion.div
                key={currentPage} // This ensures the animation runs when page changes
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                transition={{ duration: 0.2 }}
                className="h-full"
              >
                {renderContent()}
              </motion.div>
            </AnimatePresence>
          </div>
        </main>
      </div>

      {/* Toast Notification for tracking updates */}
      <Toast
        message={toastMessage}
        isVisible={toastVisible}
        onClose={() => setToastVisible(false)}
      />

      {/* Anime Match Modal */}
      {pendingDetection && (
        <AnimeMatchModal
          isOpen={matchModalOpen}
          onClose={() => {
            setMatchModalOpen(false)
            setPendingDetection(null)
          }}
          detectedTitle={pendingDetection.title}
          detectedEpisode={pendingDetection.episode}
          onMatch={handleAnimeMatch}
        />
      )}
    </div>
  )
}

export default Layout


========================================

=== apps\desktop\src\renderer\components\Library.tsx ===

import { motion } from 'framer-motion'
import { useState } from 'react'
import { useStore } from '../store/useStore'
import type { Anime } from '@anivault/shared'
import AnimeDetailsModal from './AnimeDetailsModal'
import Toast from './Toast'

const Library = () => {
  const library = useStore((state) => state.library)
  const [selectedAnime, setSelectedAnime] = useState<Anime | null>(null)
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [toastVisible, setToastVisible] = useState(false)
  const [toastMessage, setToastMessage] = useState('')

  const handleCardClick = (anime: Anime) => {
    setSelectedAnime(anime)
    setIsModalOpen(true)
  }

  const handleStatusChange = (message: string) => {
    setToastMessage(message)
    setToastVisible(true)
  }

  if (library.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full text-gray-500">
        <h2 className="text-2xl font-bold mb-2">Your Library</h2>
        <p>You haven't added any anime yet.</p>
      </div>
    )
  }

  // Group by status
  const grouped = library.reduce((acc, anime) => {
    const status = anime.status
    if (!acc[status]) {
      acc[status] = []
    }
    acc[status].push(anime)
    return acc
  }, {} as Record<string, Anime[]>)

  const statusLabels: Record<string, string> = {
    'watching': 'Watching',
    'plan-to-watch': 'Planning',
    'completed': 'Completed',
    'on-hold': 'On Hold',
    'dropped': 'Dropped',
  }

  const statusOrder = ['watching', 'plan-to-watch', 'completed', 'on-hold', 'dropped']

  return (
    <div className="space-y-8">
      <h2 className="text-3xl font-bold mb-6">Your Library</h2>
      
      {statusOrder.map((status) => {
        const animes = grouped[status] || []
        if (animes.length === 0) return null

        return (
          <div key={status} className="space-y-4">
            <h3 className="text-xl font-semibold text-gray-300">{statusLabels[status]}</h3>
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
              {animes.map((anime) => (
                <motion.div
                  key={anime.id}
                  initial={{ opacity: 0, scale: 0.9 }}
                  animate={{ opacity: 1, scale: 1 }}
                  onClick={() => handleCardClick(anime)}
                  className="relative group cursor-pointer"
                >
                  <div className="relative aspect-[2/3] rounded-lg overflow-hidden bg-black/20">
                    <img
                      src={anime.coverImage || 'https://via.placeholder.com/300x450'}
                      alt={anime.title}
                      className="w-full h-full object-cover"
                      onError={(e) => {
                        ;(e.target as HTMLImageElement).src = 'https://via.placeholder.com/300x450/1a1a1a/8b5cf6?text=No+Image'
                      }}
                    />
                    <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent opacity-0 group-hover:opacity-100 transition-opacity" />
                    <div className="absolute bottom-0 left-0 right-0 p-3 opacity-0 group-hover:opacity-100 transition-opacity">
                      <h4 className="text-white font-semibold text-sm line-clamp-2">
                        {anime.titleEnglish || anime.title}
                      </h4>
                      {anime.progress > 0 && (
                        <div className="mt-2">
                          <div className="h-1 bg-white/20 rounded-full overflow-hidden">
                            <div
                              className="h-full bg-violet-500"
                              style={{ width: `${(anime.progress / (anime.episodes || 1)) * 100}%` }}
                            />
                          </div>
                          <p className="text-xs text-gray-300 mt-1">
                            {anime.progress} / {anime.episodes || '?'} episodes
                          </p>
                        </div>
                      )}
                    </div>
                  </div>
                </motion.div>
              ))}
            </div>
          </div>
        )
      })}

      {/* Anime Details Modal */}
      <AnimeDetailsModal
        anime={selectedAnime}
        isOpen={isModalOpen}
        onClose={() => {
          setIsModalOpen(false)
          setSelectedAnime(null)
        }}
        onStatusChange={handleStatusChange}
      />

      {/* Toast Notification */}
      <Toast
        message={toastMessage}
        isVisible={toastVisible}
        onClose={() => setToastVisible(false)}
      />
    </div>
  )
}

export default Library



========================================

=== apps\desktop\src\renderer\components\LicenseSettings.tsx ===

import { useMemo, useState } from 'react'
import { AnimatePresence, motion } from 'framer-motion'
import { ShieldCheck, KeyRound, Crown, AlertTriangle } from 'lucide-react'
import Toast from './Toast'
import { useStore } from '../store/useStore'

const maskLicenseKey = (key: string | null) => {
  if (!key) return ''
  // Keep last 4 characters visible, mask the rest but preserve dashes
  return key.replace(/[A-Za-z0-9](?=[A-Za-z0-9]{4})/g, 'X')
}

const LicenseSettings = () => {
  const { isPro, licenseKey, activatePro, deactivatePro, devTogglePro } = useStore()
  const [inputKey, setInputKey] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [statusMessage, setStatusMessage] = useState('')
  const [toastMessage, setToastMessage] = useState('')
  const [toastVisible, setToastVisible] = useState(false)
  const [toastType, setToastType] = useState<'success' | 'info' | 'error'>('success')

  const maskedKey = useMemo(() => maskLicenseKey(licenseKey), [licenseKey])

  const handleActivate = async () => {
    setIsLoading(true)
    setStatusMessage('')
    try {
      const success = await activatePro(inputKey)
      if (success) {
        setStatusMessage('License activated! Enjoy AniVault Pro.')
        setToastType('success')
        setToastMessage('Pro activated successfully')
        setToastVisible(true)
      } else {
        setStatusMessage('Invalid license key. Please check and try again.')
        setToastType('error')
        setToastMessage('Activation failed')
        setToastVisible(true)
      }
    } catch (error) {
      console.error('Failed to activate license:', error)
      setStatusMessage('Something went wrong. Please try again.')
      setToastType('error')
      setToastMessage('Activation error')
      setToastVisible(true)
    } finally {
      setIsLoading(false)
    }
  }

  const handleDeactivate = async () => {
    setIsLoading(true)
    setStatusMessage('')
    try {
      await deactivatePro()
      setStatusMessage('License deactivated. You are now on the Free plan.')
      setToastType('info')
      setToastMessage('Pro deactivated')
      setToastVisible(true)
    } catch (error) {
      console.error('Failed to deactivate license:', error)
      setStatusMessage('Failed to deactivate license. Please try again.')
      setToastType('error')
      setToastMessage('Deactivation error')
      setToastVisible(true)
    } finally {
      setIsLoading(false)
    }
  }

  const handleDevToggle = () => {
    devTogglePro()
    setToastType('info')
    setToastMessage('Dev Mode: Pro Status Switched')
    setToastVisible(true)
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-3">
        <Crown className="text-yellow-400" size={24} />
        <div>
          <p className="text-lg font-semibold">AniVault Pro</p>
          <p className="text-sm text-white/60">
            Unlock Pro features with your license key.
          </p>
        </div>
      </div>

      <AnimatePresence mode="wait">
        {isPro ? (
          <motion.div
            key="pro-card"
            initial={{ opacity: 0, y: 12, scale: 0.98 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -12, scale: 0.98 }}
            className="rounded-xl border border-yellow-400/30 bg-yellow-500/10 p-5 shadow-lg shadow-yellow-500/10"
          >
            <div className="flex items-center justify-between gap-3 flex-wrap">
              <div className="flex items-center gap-3">
                <ShieldCheck className="text-yellow-300" size={28} />
                <div>
                  <p className="text-yellow-200 font-semibold">Pro Active</p>
                  <p className="text-white/80 text-sm">
                    Thanks for supporting AniVault!
                  </p>
                </div>
              </div>
              <div className="text-sm text-white/70">
                <span className="font-medium">License:</span>{' '}
                <span className="font-mono">{maskedKey || 'N/A'}</span>
              </div>
            </div>

            <motion.button
              type="button"
              whileHover={{ scale: 1.01 }}
              whileTap={{ scale: 0.98 }}
              onClick={handleDeactivate}
              disabled={isLoading}
              className="mt-4 inline-flex items-center gap-2 rounded-lg bg-red-600/80 hover:bg-red-600 px-4 py-2 text-sm font-semibold text-white transition disabled:opacity-60"
            >
              <AlertTriangle size={16} />
              {isLoading ? 'Processing...' : 'Deactivate License'}
            </motion.button>
          </motion.div>
        ) : (
          <motion.div
            key="free-card"
            initial={{ opacity: 0, y: 12, scale: 0.98 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -12, scale: 0.98 }}
            className="rounded-xl border border-white/10 bg-white/5 p-5 shadow-lg"
          >
            <label className="block text-sm font-medium text-white/80 mb-2" htmlFor="license-key">
              License Key
            </label>
            <div className="flex flex-col md:flex-row gap-3">
              <div className="relative flex-1">
                <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 text-white/50" size={18} />
                <input
                  id="license-key"
                  type="text"
                  value={inputKey}
                  onChange={(e) => setInputKey(e.target.value)}
                  placeholder="XXXX-XXXX-XXXX-XXXX"
                  className="w-full rounded-lg bg-black/30 border border-white/10 text-white px-10 py-2 placeholder:text-white/40 focus:outline-none focus:ring-2 focus:ring-violet-500/60"
                />
              </div>
              <motion.button
                type="button"
                whileHover={{ scale: 1.01 }}
                whileTap={{ scale: 0.98 }}
                onClick={handleActivate}
                disabled={isLoading || !inputKey.trim()}
                className="inline-flex items-center justify-center gap-2 rounded-lg bg-violet-600 hover:bg-violet-500 px-4 py-2 text-sm font-semibold text-white transition disabled:opacity-60"
              >
                {isLoading ? 'Activating...' : 'Activate Pro'}
              </motion.button>
            </div>
            {statusMessage && (
              <p className="mt-3 text-sm text-white/70">{statusMessage}</p>
            )}
          </motion.div>
        )}
      </AnimatePresence>

      {import.meta.env.DEV && (
        <div className="rounded-xl border border-dashed border-white/20 bg-white/5 p-4">
          <div className="flex items-center justify-between gap-3 flex-wrap">
            <div className="flex items-center gap-2">
              <span role="img" aria-label="tool">
                ğŸ› ï¸
              </span>
              <p className="font-semibold">Developer Debug</p>
            </div>
            <motion.button
              type="button"
              whileHover={{ scale: 1.01 }}
              whileTap={{ scale: 0.98 }}
              onClick={handleDevToggle}
              className="inline-flex items-center justify-center gap-2 rounded-lg border border-white/20 px-4 py-2 text-sm font-semibold text-white hover:bg-white/10 transition"
            >
              Force Toggle Pro Mode
            </motion.button>
          </div>
          <p className="mt-2 text-xs text-white/60">
            For testing only. Simulates switching Pro state locally.
          </p>
        </div>
      )}

      <Toast
        message={toastMessage}
        isVisible={toastVisible}
        onClose={() => setToastVisible(false)}
        type={toastType}
      />
    </div>
  )
}

export default LicenseSettings



========================================

=== apps\desktop\src\renderer\components\SearchBar.tsx ===

import { motion } from 'framer-motion'
import { Search } from 'lucide-react'
import { Input } from '@anivault/ui'
import { useState, useEffect } from 'react'

interface SearchBarProps {
  onSearch?: (query: string) => void
  value?: string
  onValueChange?: (value: string) => void
}

const SearchBar = ({ onSearch, value: controlledValue, onValueChange }: SearchBarProps) => {
  const [internalValue, setInternalValue] = useState('')
  const searchQuery = controlledValue !== undefined ? controlledValue : internalValue

  const setSearchQuery = (newValue: string) => {
    if (controlledValue === undefined) {
      setInternalValue(newValue)
    } else {
      onValueChange?.(newValue)
    }
  }

  // Debounce search and call onSearch
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (onSearch) {
        onSearch(searchQuery)
      }
    }, 300) // Debounce by 300ms

    return () => clearTimeout(timeoutId)
  }, [searchQuery, onSearch])

  return (
    <motion.div
      initial={{ y: -20, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      transition={{ delay: 0.2 }}
      className="relative"
    >
      <div className="relative">
        <Search
          className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"
          size={20}
        />
        <Input
          type="text"
          placeholder="Search anime..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter' && searchQuery.trim() && onSearch) {
              onSearch(searchQuery.trim())
            }
          }}
          className="pl-10 pr-4 py-2 w-full max-w-md backdrop-blur-xl bg-white/5 border-white/10 text-white placeholder:text-gray-500 focus:border-violet-500/50 focus:ring-violet-500/20"
        />
      </div>
    </motion.div>
  )
}

export default SearchBar



========================================

=== apps\desktop\src\renderer\components\settings\ThemeSelector.tsx ===

import { useState } from 'react'
import { Lock } from 'lucide-react'
import Toast from '../Toast'
import { useStore } from '../../store/useStore'

const THEMES = [
  { id: 'default', name: 'Default', isPremium: false, previewColor: 'linear-gradient(135deg, #8b5cf6, #3b82f6)' },
  { id: 'theme-neon', name: 'Neon', isPremium: true, previewColor: 'linear-gradient(135deg, #ff4d9d, #22d3ee)' },
  { id: 'theme-ocean', name: 'Ocean', isPremium: true, previewColor: 'linear-gradient(135deg, #0ea5e9, #14b8a6)' },
  { id: 'theme-midnight', name: 'Midnight', isPremium: true, previewColor: 'linear-gradient(135deg, #111827, #8b5cf6)' },
]

const ThemeSelector = () => {
  const { isPro, theme, setTheme } = useStore((state) => ({
    isPro: state.isPro,
    theme: state.theme,
    setTheme: state.setTheme,
  }))

  const [toastVisible, setToastVisible] = useState(false)
  const [toastMessage, setToastMessage] = useState('')
  const [toastType, setToastType] = useState<'success' | 'info' | 'error'>('info')

  const handleSelect = (themeId: string, isPremium: boolean) => {
    if (isPremium && !isPro) {
      setToastMessage('Upgrade to Pro to unlock this theme')
      setToastType('info')
      setToastVisible(true)
      return
    }

    setTheme(themeId)
    setToastMessage('Theme applied')
    setToastType('success')
    setToastVisible(true)
  }

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <div>
          <h4 className="text-lg font-semibold">Themes</h4>
          <p className="text-sm text-white/60">Pick a look for AniVault</p>
        </div>
        {!isPro && (
          <span className="text-xs px-2 py-1 rounded-full bg-yellow-500/10 text-yellow-300 border border-yellow-500/30">
            Pro Unlocks
          </span>
        )}
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
        {THEMES.map((item) => {
          const isActive = theme === item.id || (!theme && item.id === 'default')
          const isLocked = item.isPremium && !isPro
          return (
            <button
              key={item.id}
              type="button"
              onClick={() => handleSelect(item.id, item.isPremium)}
              className={`relative text-left rounded-xl border border-white/10 bg-white/5 p-4 transition-all hover:border-primary/60 hover:bg-white/10 ${
                isActive ? 'ring-2 ring-primary border-primary/50' : ''
              } ${isLocked ? 'opacity-80' : ''}`}
            >
              {isLocked && (
                <div className="absolute top-3 right-3 text-white/70">
                  <Lock size={16} />
                </div>
              )}

              <div className="flex items-center justify-between gap-2">
                <div>
                  <p className="font-semibold text-white">{item.name}</p>
                  <p className="text-xs text-white/60">
                    {item.isPremium ? 'Premium theme' : 'Free theme'}
                  </p>
                </div>
                <span
                  className="h-10 w-16 rounded-md border border-white/20 shadow-inner"
                  style={{ background: item.previewColor }}
                />
              </div>

              {isActive && (
                <div className="mt-3 inline-flex items-center gap-2 text-xs text-primary bg-primary/10 px-2 py-1 rounded-full border border-primary/30">
                  <span className="inline-block h-2 w-2 rounded-full bg-primary animate-pulse" />
                  Selected
                </div>
              )}
            </button>
          )
        })}
      </div>

      <Toast
        message={toastMessage}
        isVisible={toastVisible}
        onClose={() => setToastVisible(false)}
        type={toastType}
      />
    </div>
  )
}

export default ThemeSelector











========================================

=== apps\desktop\src\renderer\components\Sidebar.tsx ===

import { motion } from 'framer-motion'
import { Home, Search, Library, Settings, TrendingUp, BarChart2 } from 'lucide-react'

// Define the shape of our props so TypeScript is happy
interface SidebarProps {
  activePage: string
  onNavigate: (page: string) => void
}

const navItems = [
  { icon: Home, label: 'Home', id: 'home' },
  { icon: Library, label: 'Library', id: 'library' },
  { icon: Search, label: 'Discover', id: 'discover' },
  { icon: BarChart2, label: 'Stats', id: 'stats' },
  { icon: Settings, label: 'Settings', id: 'settings' },
]

const Sidebar = ({ activePage, onNavigate }: SidebarProps) => {
  return (
    <motion.aside
      initial={{ x: -100, opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      transition={{ duration: 0.3 }}
      className="w-64 h-full backdrop-blur-xl bg-card/40 border-r border-border/60"
    >
      <div className="p-6">
        <h1 className="text-2xl font-bold bg-gradient-to-r from-primary to-primary/60 bg-clip-text text-transparent">
          AniVault
        </h1>
      </div>
      <nav className="px-4 space-y-2">
        {navItems.map((item) => {
          const Icon = item.icon
          const isActive = activePage === item.id
          return (
            <motion.button
              key={item.id}
              onClick={() => onNavigate(item.id)} // <--- This now talks to Layout!
              whileHover={{ x: 4 }}
              whileTap={{ scale: 0.98 }}
              className={`w-full flex items-center gap-3 px-4 py-3 rounded-lg transition-all ${
                isActive
                  ? 'bg-primary/20 text-primary shadow-lg shadow-primary/20 border border-primary/40'
                  : 'text-muted-foreground hover:text-foreground hover:bg-card/50 border border-transparent'
              }`}
            >
              <Icon size={20} />
              <span className="font-medium">{item.label}</span>
            </motion.button>
          )
        })}
      </nav>
    </motion.aside>
  )
}

export default Sidebar


========================================

=== apps\desktop\src\renderer\components\StatsDashboard.tsx ===

import { useMemo } from 'react'
import { Card } from '@anivault/ui'
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, CartesianGrid, AreaChart, Area, TooltipProps } from 'recharts'
import { Lock } from 'lucide-react'
import { useStore } from '../store/useStore'
import { buildStatsSnapshot, type StatsSnapshot, type WatchEvent } from '../services/stats.service'
import type { ValueType, NameType } from 'recharts/types/component/DefaultTooltipContent'

const StatCard = ({ title, value, subtitle }: { title: string; value: string; subtitle?: string }) => (
  <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
    <div className="p-4 space-y-1">
      <p className="text-sm text-muted-foreground">{title}</p>
      <p className="text-2xl font-bold">{value}</p>
      {subtitle && <p className="text-xs text-muted-foreground">{subtitle}</p>}
    </div>
  </Card>
)

const ThemedTooltip = ({ active, payload, label }: TooltipProps<ValueType, NameType>) => {
  if (active && payload && payload.length) {
    return (
      <div className="rounded-lg border border-primary/30 bg-primary/15 px-3 py-2 shadow-lg shadow-primary/20 backdrop-blur">
        <p className="text-xs text-foreground/80 mb-1">{label}</p>
        {payload.map((entry, idx) => (
          <p key={idx} className="text-sm font-semibold text-foreground">
            {entry.name ?? 'Value'}: {entry.value}
          </p>
        ))}
      </div>
    )
  }
  return null
}

const ArchetypeBadge = ({ archetype }: { archetype: string }) => {
  const config: Record<string, { label: string; emoji: string }> = {
    'night-owl': { label: 'Night Owl Binger', emoji: 'ğŸ¦‰' },
    'weekend-marathoner': { label: 'Weekend Marathoner', emoji: 'ğŸ®' },
    'daily-sipper': { label: 'Daily Sipper', emoji: 'â˜•' },
    'casual': { label: 'Casual Watcher', emoji: 'ğŸ“º' },
    'unknown': { label: 'Getting Started', emoji: 'ğŸŒŸ' },
  }

  const { label, emoji } = config[archetype] || { label: archetype, emoji: 'ğŸ“Š' }

  return (
    <span className="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-primary/10 border border-primary/30 text-sm font-medium text-foreground">
      <span>{emoji}</span>
      <span>{label}</span>
    </span>
  )
}

const StatsDashboard = () => {
  const { isPro, library, watchEvents } = useStore((state) => ({
    isPro: state.isPro,
    library: state.library,
    watchEvents: state.watchEvents,
  }))

  const snapshot = useMemo<StatsSnapshot>(() => {
    return buildStatsSnapshot(library || [], watchEvents || [])
  }, [library, watchEvents])

  const stats = snapshot.libraryStats

  // Compute completed and watching counts
  const completedCount = useMemo(() => library.filter((a) => a.status === 'completed').length, [library])
  const watchingCount = useMemo(() => library.filter((a) => a.status === 'watching').length, [library])

  // Format hours nicely
  const formattedHours = useMemo(() => {
    const hours = Math.round(stats.totalHours * 10) / 10
    return hours.toLocaleString(undefined, { maximumFractionDigits: 1 })
  }, [stats.totalHours])

  // Chart data with fallbacks
  const genreData = stats.genreBreakdown.length > 0 ? stats.genreBreakdown : [{ name: 'N/A', count: 0 }]
  const scoreData = stats.scoreDistribution.length > 0 ? stats.scoreDistribution : [{ score: 0, count: 0 }]
  const hasGenreData = stats.genreBreakdown.some((g) => g.count > 0)
  const hasScoreData = stats.scoreDistribution.some((s) => s.count > 0)

  // Heatmap data - last 30 days
  const recentHeatmapCells = snapshot.heatmap.cells.slice(-30)
  const hasHeatmapData = snapshot.heatmap.cells.length > 0

  // Format date for display
  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr)
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
  }

  return (
    <div className="relative space-y-6 w-full">
      {!isPro && (
        <div className="absolute inset-0 z-20 flex items-center justify-center backdrop-blur-md bg-background/70 rounded-2xl border border-border/60">
          <div className="text-center space-y-3 px-6 py-8">
            <div className="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-primary/10 text-primary">
              <Lock size={20} />
            </div>
            <p className="text-lg font-semibold text-foreground">Upgrade to Pro to see your stats</p>
            <p className="text-sm text-muted-foreground">Unlock detailed watch history and insights.</p>
            <button className="px-4 py-2 rounded-lg bg-primary text-white font-medium shadow-lg shadow-primary/30 hover:bg-primary/90 transition">
              Upgrade to Pro
            </button>
          </div>
        </div>
      )}

      {/* Hero Section - Lifetime Overview */}
      <div className="space-y-4">
        <div>
          <h2 className="text-3xl font-bold text-foreground">Anime Insights</h2>
          <p className="text-sm text-muted-foreground mt-1">Your anime life at a glance</p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <StatCard title="Total Hours Watched" value={formattedHours} subtitle="Assuming ~24 min per episode" />
          <StatCard title="Total Episodes Watched" value={stats.totalEpisodes.toLocaleString()} />
          <StatCard title="Anime Completed" value={completedCount.toLocaleString()} />
          <StatCard title="Currently Watching" value={watchingCount.toLocaleString()} />
        </div>
      </div>

      {/* Activity & Binge Row */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Activity Heatmap */}
        <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
          <div className="p-4 space-y-4">
            <div>
              <h3 className="text-lg font-semibold text-foreground">Activity Heatmap</h3>
              <p className="text-xs text-muted-foreground">Last 30 days of watch activity</p>
            </div>
            {hasHeatmapData ? (
              <div className="space-y-2">
                <div className="flex flex-wrap gap-1">
                  {recentHeatmapCells.map((cell, idx) => {
                    const intensity = snapshot.heatmap.maxCount > 0 ? cell.count / snapshot.heatmap.maxCount : 0
                    return (
                      <div
                        key={idx}
                        className="w-3 h-3 rounded-sm border border-border/30"
                        style={{
                          backgroundColor: `var(--primary)`,
                          opacity: Math.max(0.2, intensity),
                        }}
                        title={`${cell.date}: ${cell.count} episode${cell.count !== 1 ? 's' : ''}`}
                      />
                    )
                  })}
                </div>
                <div className="flex items-center justify-between text-xs text-muted-foreground pt-2">
                  <span>Less</span>
                  <div className="flex gap-1">
                    {[0.2, 0.4, 0.6, 0.8, 1.0].map((opacity) => (
                      <div
                        key={opacity}
                        className="w-3 h-3 rounded-sm border border-border/30"
                        style={{
                          backgroundColor: `var(--primary)`,
                          opacity,
                        }}
                      />
                    ))}
                  </div>
                  <span>More</span>
                </div>
              </div>
            ) : (
              <div className="h-32 flex items-center justify-center text-sm text-muted-foreground">
                No watch activity logged yet
              </div>
            )}
          </div>
        </Card>

        {/* Binge Profile */}
        <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
          <div className="p-4 space-y-4">
            <div>
              <h3 className="text-lg font-semibold text-foreground">Binge Profile</h3>
              <p className="text-xs text-muted-foreground">Your watching patterns</p>
            </div>
            {snapshot.bingeProfile.totalSessions > 0 ? (
              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-muted-foreground">Total sessions</span>
                  <span className="text-lg font-semibold text-foreground">{snapshot.bingeProfile.totalSessions}</span>
                </div>
                {snapshot.bingeProfile.longestSession && (
                  <div className="flex items-center justify-between">
                    <span className="text-sm text-muted-foreground">Longest session</span>
                    <span className="text-lg font-semibold text-foreground">
                      {snapshot.bingeProfile.longestSession.episodes} episodes
                    </span>
                  </div>
                )}
                <div className="flex items-center justify-between">
                  <span className="text-sm text-muted-foreground">Average per session</span>
                  <span className="text-lg font-semibold text-foreground">
                    {Math.round(snapshot.bingeProfile.averageEpisodesPerSession * 10) / 10} episodes
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-sm text-muted-foreground">Most in a day</span>
                  <span className="text-lg font-semibold text-foreground">
                    {snapshot.bingeProfile.mostEpisodesInADay} episodes
                  </span>
                </div>
                <div className="pt-2 border-t border-border/30">
                  <ArchetypeBadge archetype={snapshot.bingeProfile.archetype} />
                </div>
              </div>
            ) : (
              <div className="h-32 flex items-center justify-center text-sm text-muted-foreground">
                Start watching with AniVault to see your binge profile!
              </div>
            )}
          </div>
        </Card>
      </div>

      {/* Tastes Row */}
      <div className="space-y-4">
        <h3 className="text-xl font-semibold text-foreground">Your Taste</h3>
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Top Genres */}
          <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
            <div className="p-4 space-y-2">
              <p className="text-sm font-semibold text-foreground">Top Genres</p>
              <div className="relative h-64 w-full">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={genreData}>
                    <defs>
                      <linearGradient id="genreGradient" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stopColor="var(--primary)" stopOpacity={0.9} />
                        <stop offset="100%" stopColor="var(--primary)" stopOpacity={0.35} />
                      </linearGradient>
                    </defs>
                    <CartesianGrid strokeDasharray="3 3" stroke="var(--border)" opacity={0.35} />
                    <XAxis dataKey="name" stroke="var(--text-muted)" tickLine={false} axisLine={false} />
                    <YAxis stroke="var(--text-muted)" allowDecimals={false} tickLine={false} axisLine={false} />
                    <Tooltip
                      content={<ThemedTooltip />}
                      cursor={{ fill: 'var(--primary)', fillOpacity: 0.08 }}
                    />
                    <Bar dataKey="count" fill="url(#genreGradient)" radius={[8, 8, 4, 4]} isAnimationActive={hasGenreData} />
                  </BarChart>
                </ResponsiveContainer>
                {!hasGenreData && (
                  <div className="absolute inset-0 flex items-center justify-center text-sm text-muted-foreground">
                    No genre data yet
                  </div>
                )}
              </div>
            </div>
          </Card>

          {/* Score Distribution */}
          <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
            <div className="p-4 space-y-2">
              <p className="text-sm font-semibold text-foreground">Score Distribution</p>
              <div className="relative h-64 w-full">
                <ResponsiveContainer width="100%" height="100%">
                  <AreaChart data={scoreData}>
                    <defs>
                      <linearGradient id="scoreGradient" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stopColor="var(--primary)" stopOpacity={0.35} />
                        <stop offset="100%" stopColor="var(--primary)" stopOpacity={0.05} />
                      </linearGradient>
                    </defs>
                    <CartesianGrid strokeDasharray="3 3" stroke="var(--border)" opacity={0.35} />
                    <XAxis dataKey="score" stroke="var(--text-muted)" tickLine={false} axisLine={false} />
                    <YAxis stroke="var(--text-muted)" allowDecimals={false} tickLine={false} axisLine={false} />
                    <Tooltip
                      content={<ThemedTooltip />}
                      cursor={{ stroke: 'var(--primary)', strokeOpacity: 0.15, strokeWidth: 1 }}
                    />
                    <Area
                      type="monotone"
                      dataKey="count"
                      stroke="var(--primary)"
                      fill="url(#scoreGradient)"
                      strokeWidth={2}
                      isAnimationActive={hasScoreData}
                    />
                  </AreaChart>
                </ResponsiveContainer>
                {!hasScoreData && (
                  <div className="absolute inset-0 flex items-center justify-center text-sm text-muted-foreground">
                    No score data yet
                  </div>
                )}
              </div>
            </div>
          </Card>
        </div>
      </div>

      {/* Milestones Row */}
      <div className="space-y-4">
        <h3 className="text-xl font-semibold text-foreground">Milestones</h3>
        {snapshot.milestones.length > 0 ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            {snapshot.milestones.map((milestone) => {
              const progress = (milestone.current / milestone.target) * 100
              const isAchieved = milestone.achievedAt !== undefined || milestone.current >= milestone.target

              return (
                <Card
                  key={milestone.id}
                  className={`bg-card text-foreground border shadow-lg transition-all ${
                    isAchieved
                      ? 'border-primary/60 shadow-primary/20'
                      : 'border-border/60 shadow-primary/10'
                  }`}
                >
                  <div className="p-4 space-y-3">
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        <h4 className="text-sm font-semibold text-foreground">{milestone.title}</h4>
                        <p className="text-xs text-muted-foreground mt-1">{milestone.description}</p>
                      </div>
                      {isAchieved && (
                        <span className="text-xs px-2 py-1 rounded-full bg-primary/20 text-primary border border-primary/30">
                          Achieved
                        </span>
                      )}
                    </div>
                    <div className="space-y-1">
                      <div className="flex items-center justify-between text-xs">
                        <span className="text-muted-foreground">Progress</span>
                        <span className="text-foreground font-medium">
                          {milestone.current} / {milestone.target}
                        </span>
                      </div>
                      <div className="w-full h-2 bg-border/50 rounded-full overflow-hidden">
                        <div
                          className="h-full bg-primary transition-all duration-300 rounded-full"
                          style={{ width: `${Math.min(progress, 100)}%` }}
                        />
                      </div>
                    </div>
                    {milestone.achievedAt && (
                      <p className="text-xs text-muted-foreground">
                        Achieved {formatDate(milestone.achievedAt)}
                      </p>
                    )}
                  </div>
                </Card>
              )
            })}
          </div>
        ) : (
          <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
            <div className="p-8 text-center">
              <p className="text-sm text-muted-foreground">
                Milestones will appear as you watch more anime with AniVault.
              </p>
            </div>
          </Card>
        )}
      </div>

      {/* Yearly Summary */}
      <div className="space-y-4">
        <h3 className="text-xl font-semibold text-foreground">
          {snapshot.yearlySummary ? `Anime Wrapped ${snapshot.yearlySummary.year}` : 'This Year So Far'}
        </h3>
        {snapshot.yearlySummary ? (
          <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
            <div className="p-6 space-y-6">
              {/* Highlight Metrics */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div className="text-center">
                  <p className="text-2xl font-bold text-foreground">{snapshot.yearlySummary.totalEpisodes}</p>
                  <p className="text-xs text-muted-foreground mt-1">Episodes watched</p>
                </div>
                <div className="text-center">
                  <p className="text-2xl font-bold text-foreground">
                    {Math.round(snapshot.yearlySummary.totalHours * 10) / 10}
                  </p>
                  <p className="text-xs text-muted-foreground mt-1">Hours watched</p>
                </div>
                <div className="text-center">
                  <p className="text-2xl font-bold text-foreground">{snapshot.yearlySummary.animeStarted}</p>
                  <p className="text-xs text-muted-foreground mt-1">New anime started</p>
                </div>
                <div className="text-center">
                  <p className="text-2xl font-bold text-foreground">{snapshot.yearlySummary.animeCompleted}</p>
                  <p className="text-xs text-muted-foreground mt-1">Anime completed</p>
                </div>
              </div>

              {/* Top Genres */}
              {snapshot.yearlySummary.topGenres.length > 0 && (
                <div className="space-y-2">
                  <p className="text-sm font-semibold text-foreground">Top Genres</p>
                  <div className="flex flex-wrap gap-2">
                    {snapshot.yearlySummary.topGenres.map((genre, idx) => (
                      <span
                        key={idx}
                        className="px-3 py-1 rounded-full bg-primary/10 border border-primary/30 text-sm text-foreground"
                      >
                        {genre.genre} ({genre.count})
                      </span>
                    ))}
                  </div>
                </div>
              )}

              {/* Top Anime */}
              {snapshot.yearlySummary.topAnime.length > 0 && (
                <div className="space-y-2">
                  <p className="text-sm font-semibold text-foreground">Top Anime</p>
                  <div className="space-y-2">
                    {snapshot.yearlySummary.topAnime.map((anime, idx) => (
                      <div key={idx} className="flex items-center justify-between p-2 rounded-lg bg-background/40">
                        <span className="text-sm text-foreground font-medium">{anime.title}</span>
                        <span className="text-xs text-muted-foreground">{anime.episodes} episodes watched</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </Card>
        ) : (
          <Card className="bg-card text-foreground border border-border/60 shadow-lg shadow-primary/10">
            <div className="p-8 text-center">
              <p className="text-sm text-muted-foreground">No watch activity for this year yet.</p>
            </div>
          </Card>
        )}
      </div>
    </div>
  )
}

export default StatsDashboard


========================================

=== apps\desktop\src\renderer\components\TitleBar.tsx ===

import { Minus, Square, X, Maximize2 } from 'lucide-react'
import { motion } from 'framer-motion'
import { useState, useEffect } from 'react'

const TitleBar = () => {
  const [isMaximized, setIsMaximized] = useState(false)

  // Check initial window state and listen for changes
  useEffect(() => {
    const checkMaximized = async () => {
      try {
        const maximized = await window.electron?.isMaximized()
        setIsMaximized(maximized ?? false)
      } catch (err) {
        // Silently fail
      }
    }
    checkMaximized()

    // Listen for window state changes
    const handleMaximize = () => {
      setIsMaximized(true)
    }
    
    const handleUnmaximize = () => {
      setIsMaximized(false)
    }

    if (window.electron) {
      window.electron.onMaximize(handleMaximize)
      window.electron.onUnmaximize(handleUnmaximize)
    }

    // Also periodically check state to ensure it stays in sync (fallback)
    // This ensures the icon updates even if events don't fire
    const syncInterval = setInterval(async () => {
      try {
        const maximized = await window.electron?.isMaximized()
        setIsMaximized(prev => {
          if (prev !== maximized) {
            return maximized ?? false
          }
          return prev
        })
      } catch (err) {
        // Silently fail
      }
    }, 200) // Check every 200ms for faster response

    // Cleanup
    return () => {
      clearInterval(syncInterval)
    }
  }, [])

  // Handlers calling the window.electron bridge
  const handleMinimize = (e: React.MouseEvent) => {
    e.preventDefault()
    e.stopPropagation()

    // Optional: tiny visual feedback before minimize
    const root = document.getElementById('root')
    if (root) {
      root.style.transition = 'transform 120ms ease, opacity 120ms ease'
      root.style.transform = 'scale(0.98)'
      root.style.opacity = '0.8'
    }

    setTimeout(() => {
      if (window.electron) {
        window.electron
          .minimize()
          .catch(err => console.error('Minimize error:', err))
      }

      // Reset for when the window is restored
      if (root) {
        root.style.transform = ''
        root.style.opacity = ''
      }
    }, 110)
  }
  
  const handleMaximize = async (e: React.MouseEvent) => {
    e.preventDefault()
    e.stopPropagation()
    if (window.electron) {
      await window.electron.maximize().catch(() => {})
      // Immediately check state after maximize/unmaximize
      setTimeout(async () => {
        const maximized = await window.electron?.isMaximized()
        setIsMaximized(maximized ?? false)
      }, 100)
    }
  }
  
  const handleClose = (e: React.MouseEvent) => {
    e.preventDefault()
    e.stopPropagation()
    if (window.electron) {
      window.electron.close().catch(err => console.error('Close error:', err))
    }
  }

  return (
    // 'drag-region' makes the whole bar draggable
    <div className="flex items-center justify-end h-8 bg-transparent drag-region relative z-50">
      {/* 'no-drag' is CRITICAL: Buttons won't click if they are draggable */}
      <div className="flex no-drag relative z-[60]">
        {/* Minimize */}
        <motion.button
          whileHover={{ backgroundColor: 'rgba(255, 255, 255, 0.1)' }}
          onClick={handleMinimize}
          className="w-12 h-8 flex items-center justify-center hover:bg-white/10 transition-colors cursor-pointer"
          type="button"
        >
          <Minus size={14} />
        </motion.button>

        {/* Maximize / Restore */}
        <motion.button
          whileHover={{ backgroundColor: 'rgba(255, 255, 255, 0.1)' }}
          onClick={handleMaximize}
          className="w-12 h-8 flex items-center justify-center hover:bg-white/10 transition-colors cursor-pointer"
          title={isMaximized ? 'Restore Down' : 'Maximize'}
          type="button"
        >
          {isMaximized ? (
            <Maximize2 size={12} className="text-white" />
          ) : (
            <Square size={12} className="text-white" />
          )}
        </motion.button>

        {/* Close (Red hover effect) */}
        <motion.button
          whileHover={{ backgroundColor: '#ef4444' }}
          onClick={handleClose}
          className="w-12 h-8 flex items-center justify-center hover:bg-red-500 transition-colors cursor-pointer"
          type="button"
        >
          <X size={14} />
        </motion.button>
      </div>
    </div>
  )
}

export default TitleBar



========================================

=== apps\desktop\src\renderer\components\Toast.tsx ===

import { motion, AnimatePresence } from 'framer-motion'
import { Check, X } from 'lucide-react'
import { useEffect } from 'react'

interface ToastProps {
  message: string
  isVisible: boolean
  onClose: () => void
  type?: 'success' | 'info' | 'error'
}

const Toast = ({ message, isVisible, onClose, type = 'success' }: ToastProps) => {
  useEffect(() => {
    if (isVisible) {
      const timer = setTimeout(() => {
        onClose()
      }, 3000)
      return () => clearTimeout(timer)
    }
  }, [isVisible, onClose])

  const bgColor =
    type === 'error'
      ? 'bg-red-600/90 border-red-400/20 shadow-red-500/50'
      : type === 'info'
      ? 'bg-blue-600/90 border-blue-400/20 shadow-blue-500/50'
      : 'bg-violet-600/90 border-violet-400/20 shadow-violet-500/50'

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ opacity: 0, y: 20, scale: 0.9 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: -20, scale: 0.9 }}
          className={`fixed bottom-6 right-6 z-[100] ${bgColor} backdrop-blur-xl text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-2 border`}
        >
          <Check size={20} />
          <span className="font-medium">{message}</span>
          <button
            onClick={onClose}
            className="ml-2 hover:opacity-70 transition-opacity"
          >
            <X size={16} />
          </button>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

export default Toast



========================================

=== apps\desktop\src\renderer\components\TrendingNow.tsx ===

import { motion } from 'framer-motion'
import { Plus, Loader2 } from 'lucide-react'
import { useState, useEffect } from 'react'
import type { Anime } from '@anivault/shared'
import { anilistService } from '../services/anilist.service'
import { useStore } from '../store/useStore'
import Toast from './Toast'
import AnimeDetailsModal from './AnimeDetailsModal'

interface AnimeCardProps {
  anime: Anime
  index: number
  onAdd: (anime: Anime) => void
  onClick: (anime: Anime) => void
}

const AnimeCard = ({ anime, index, onAdd, onClick }: AnimeCardProps) => {
  const [isHovered, setIsHovered] = useState(false)

  return (
    <motion.div
      initial={{ opacity: 0, x: -20 }}
      animate={{ opacity: 1, x: 0 }}
      transition={{ delay: index * 0.1 }}
      className="flex-shrink-0 w-48 group"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <motion.div
        whileHover={{ scale: 1.05 }}
        onClick={() => onClick(anime)}
        className="relative h-[28rem] rounded-lg overflow-hidden cursor-pointer transition-all duration-300"
        style={{
          boxShadow: isHovered
            ? '0 0 30px rgba(139, 92, 246, 0.6), 0 0 60px rgba(139, 92, 246, 0.3)'
            : '0 4px 6px rgba(0, 0, 0, 0.3)',
        }}
      >
        {/* Poster Image */}
        <div className="absolute inset-0">
          <img
            src={anime.coverImage || 'https://via.placeholder.com/300x450'}
            alt={anime.title}
            className="w-full h-full object-cover"
            onError={(e) => {
              ;(e.target as HTMLImageElement).src = 'https://via.placeholder.com/300x450/1a1a1a/8b5cf6?text=No+Image'
            }}
          />
          {/* Gradient Overlay */}
          <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/50 to-transparent" />
        </div>

        {/* Content */}
        <div className="absolute bottom-0 left-0 right-0 p-4 z-10">
          <h3 className="text-white font-semibold text-sm mb-1 line-clamp-2">
            {anime.titleEnglish || anime.title}
          </h3>
          {anime.rating && (
            <div className="flex items-center gap-1 text-xs text-gray-300">
              <span className="text-violet-400">â˜…</span>
              <span>{anime.rating.toFixed(1)}</span>
            </div>
          )}
        </div>

        {/* Quick Add Button - appears on hover */}
        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{
            opacity: isHovered ? 1 : 0,
            y: isHovered ? 0 : 10,
          }}
          transition={{ duration: 0.2 }}
          className="absolute top-4 right-4 z-20"
        >
          <motion.button
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.95 }}
            onClick={(e) => {
              e.stopPropagation()
              onAdd(anime)
            }}
            className="flex items-center justify-center w-10 h-10 rounded-full bg-violet-500/90 backdrop-blur-sm hover:bg-violet-500 text-white shadow-lg shadow-violet-500/50 transition-all"
          >
            <Plus size={20} />
          </motion.button>
        </motion.div>
      </motion.div>
    </motion.div>
  )
}

const TrendingNow = () => {
  const [trendingAnime, setTrendingAnime] = useState<Anime[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [toastVisible, setToastVisible] = useState(false)
  const [toastMessage, setToastMessage] = useState('')
  const [selectedAnime, setSelectedAnime] = useState<Anime | null>(null)
  const [isModalOpen, setIsModalOpen] = useState(false)
  const { accessToken, addToLibrary } = useStore()

  const handleAddToLibrary = async (anime: Anime) => {
    try {
      await addToLibrary(anime, 'plan-to-watch')
      setToastMessage('Added to Library')
      setToastVisible(true)
    } catch (error) {
      console.error('Failed to add to library:', error)
    }
  }

  const handleCardClick = (anime: Anime) => {
    setSelectedAnime(anime)
    setIsModalOpen(true)
  }

  const handleStatusChange = (message: string) => {
    setToastMessage(message)
    setToastVisible(true)
  }

  useEffect(() => {
    const fetchTrending = async () => {
      try {
        setIsLoading(true)
        setError(null)
        
        // Set access token if available
        if (accessToken) {
          anilistService.setAccessToken(accessToken)
        }
        
        const data = await anilistService.getTrendingAnime(10)
        setTrendingAnime(data)
      } catch (err) {
        console.error('Failed to fetch trending anime:', err)
        setError(err instanceof Error ? err.message : 'Failed to load trending anime')
      } finally {
        setIsLoading(false)
      }
    }

    fetchTrending()
  }, [accessToken])

  return (
    <div className="relative mb-12">
      {/* Dark gradient background fading from black to transparent at top */}
      <div className="absolute inset-0 bg-gradient-to-b from-black via-black/50 to-transparent -z-10" />
      
      <div className="relative">
        {/* Section Header */}
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="mb-6"
        >
          <h2 className="text-2xl font-bold mb-2 bg-gradient-to-r from-violet-400 to-blue-400 bg-clip-text text-transparent">
            Trending Now
          </h2>
          <p className="text-sm text-gray-400">Discover what's hot in the anime world</p>
        </motion.div>

        {/* Loading State */}
        {isLoading && (
          <div className="flex items-center justify-center py-12">
            <Loader2 className="w-8 h-8 text-violet-400 animate-spin" />
          </div>
        )}

        {/* Error State */}
        {error && !isLoading && (
          <div className="flex items-center justify-center py-12">
            <p className="text-red-400 text-sm">{error}</p>
          </div>
        )}

        {/* Horizontal Scroll Carousel */}
        {!isLoading && !error && trendingAnime.length > 0 && (
          <div className="overflow-x-auto overflow-y-visible pb-4 -mx-6 px-6 scrollbar-hide">
            <div className="flex gap-4">
              {trendingAnime.map((anime, index) => (
                <AnimeCard
                  key={anime.id}
                  anime={anime}
                  index={index}
                  onAdd={handleAddToLibrary}
                  onClick={handleCardClick}
                />
              ))}
            </div>
          </div>
        )}

        {/* Anime Details Modal */}
        <AnimeDetailsModal
          anime={selectedAnime}
          isOpen={isModalOpen}
          onClose={() => {
            setIsModalOpen(false)
            setSelectedAnime(null)
          }}
          onStatusChange={handleStatusChange}
        />

        {/* Toast Notification */}
        <Toast
          message={toastMessage}
          isVisible={toastVisible}
          onClose={() => setToastVisible(false)}
        />

        {/* Empty State */}
        {!isLoading && !error && trendingAnime.length === 0 && (
          <div className="flex items-center justify-center py-12">
            <p className="text-gray-400 text-sm">No trending anime found</p>
          </div>
        )}
      </div>
    </div>
  )
}

export default TrendingNow



========================================

=== apps\desktop\src\renderer\components\WelcomeScreen.tsx ===

import { motion } from 'framer-motion'
import { Sparkles, Info } from 'lucide-react'
import { useState } from 'react'
import { useStore } from '../store/useStore'

const WelcomeScreen = () => {
  const login = useStore((state) => state.login)
  const enableGuestMode = useStore((state) => state.enableGuestMode)
  const [showTooltip, setShowTooltip] = useState(false)
  const [isLoggingIn, setIsLoggingIn] = useState(false)

  const handleConnect = async () => {
    try {
      setIsLoggingIn(true)
      await login()
    } catch (error) {
      console.error('Failed to connect:', error)
      // Error is already handled gracefully - user cancelled
    } finally {
      setIsLoggingIn(false)
    }
  }

  const handleGuestMode = () => {
    enableGuestMode()
  }

  return (
    <div className="h-screen w-screen flex items-center justify-center bg-[#050505] text-white relative overflow-hidden">
      {/* Animated background gradient */}
      <div className="absolute inset-0 bg-gradient-to-br from-violet-900/20 via-blue-900/20 to-black" />
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,rgba(139,92,246,0.1),transparent_50%)]" />

      {/* Content */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="relative z-10 text-center max-w-2xl px-6"
      >
        {/* Logo/Icon */}
        <motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ delay: 0.2, duration: 0.5 }}
          className="mb-8 flex justify-center"
        >
          <div className="w-24 h-24 rounded-2xl bg-gradient-to-br from-violet-500 to-blue-500 flex items-center justify-center shadow-2xl shadow-violet-500/50">
            <Sparkles size={48} className="text-white" />
          </div>
        </motion.div>

        {/* Title */}
        <motion.h1
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
          className="text-6xl font-bold mb-4 bg-gradient-to-r from-violet-400 via-blue-400 to-violet-400 bg-clip-text text-transparent bg-[length:200%_auto] animate-[shimmer_3s_ease-in-out_infinite]"
        >
          AniVault
        </motion.h1>

        {/* Subtitle */}
        <motion.p
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4 }}
          className="text-xl text-gray-400 mb-12"
        >
          Your ultimate anime tracking ecosystem
        </motion.p>

        {/* Action Buttons */}
        <motion.div
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.5 }}
          className="flex flex-col sm:flex-row items-center justify-center gap-4"
        >
          {/* Login Button */}
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleConnect}
            disabled={isLoggingIn}
            className="px-8 py-4 bg-gradient-to-r from-violet-600 to-blue-600 rounded-lg text-white font-semibold text-lg shadow-lg shadow-violet-500/50 hover:shadow-xl hover:shadow-violet-500/70 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isLoggingIn ? 'Connecting...' : 'Login with AniList'}
          </motion.button>

          {/* Guest Mode Button */}
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={handleGuestMode}
            className="px-8 py-4 rounded-lg text-white font-semibold text-lg border-2 border-white/20 hover:border-white/40 hover:bg-white/5 transition-all"
          >
            Continue as Guest
          </motion.button>
        </motion.div>

        {/* Why Login Tooltip */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.6 }}
          className="mt-8 relative inline-block"
        >
          <button
            onMouseEnter={() => setShowTooltip(true)}
            onMouseLeave={() => setShowTooltip(false)}
            className="flex items-center gap-2 text-sm text-gray-400 hover:text-gray-300 transition-colors"
          >
            <Info size={16} />
            <span>Why Login?</span>
          </button>

          {showTooltip && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-64 p-4 bg-black/90 backdrop-blur-xl border border-white/10 rounded-lg shadow-lg z-50"
            >
              <h4 className="font-semibold mb-2 text-violet-400">Cloud Sync Features</h4>
              <ul className="text-xs text-gray-300 space-y-1 text-left">
                <li>â€¢ Sync your library across devices</li>
                <li>â€¢ Automatic progress tracking</li>
                <li>â€¢ Access your AniList data</li>
                <li>â€¢ Real-time updates</li>
              </ul>
              <div className="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-full w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-white/10" />
            </motion.div>
          )}
        </motion.div>
      </motion.div>
    </div>
  )
}

export default WelcomeScreen


========================================

=== apps\desktop\src\renderer\index.css ===

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --bg-main: #050505;
  --bg-card: #0b0b10;
  --text-main: #ffffff;
  --text-muted: #9ca3af;
  --primary: #8b5cf6;
  --border: #1f2937;
}

body.theme-neon {
  --bg-main: #040404;
  --bg-card: #0b0b16;
  --text-main: #f8fafc;
  --text-muted: #a5b4fc;
  --primary: #ff4d9d;
  --border: #172554;
}

body.theme-ocean {
  --bg-main: #0b1021;
  --bg-card: #0f172a;
  --text-main: #e0f2fe;
  --text-muted: #94a3b8;
  --primary: #14b8a6;
  --border: #1e293b;
}

body.theme-midnight {
  --bg-main: #000000;
  --bg-card: #0a0a0a;
  --text-main: #f1f5f9;
  --text-muted: #94a3b8;
  --primary: #8b5cf6;
  --border: #1f2937;
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  @apply bg-background;
}

::-webkit-scrollbar-thumb {
  @apply bg-muted rounded-full;
}

::-webkit-scrollbar-thumb:hover {
  background-color: hsl(var(--muted));
  opacity: 0.8;
}

/* Electron window controls */
.drag-region {
  -webkit-app-region: drag;
}

.no-drag {
  -webkit-app-region: no-drag;
  pointer-events: auto;
}

/* Hide scrollbar but keep functionality */
.scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.scrollbar-hide::-webkit-scrollbar {
  display: none;
}

/* Line clamp utility */
.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* Correct root selector for CSS variables (fallback defaults) */
:root {
  --bg-main: #050505;
  --bg-card: #0b0b10;
  --text-main: #ffffff;
  --text-muted: #9ca3af;
  --primary: #8b5cf6;
  --border: #1f2937;
}



========================================

=== apps\desktop\src\renderer\index.html ===

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AniVault</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>



========================================

=== apps\desktop\src\renderer\main.tsx ===

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)



========================================

=== apps\desktop\src\renderer\services\anilist.service.ts ===

import type { Anime } from '@anivault/shared'

const ANILIST_API_URL = 'https://graphql.anilist.co'

interface AniListMedia {
  id: number
  title: {
    romaji: string
    english?: string
    native?: string
  }
  coverImage: {
    large: string
    medium: string
  }
  bannerImage?: string
  description?: string
  episodes?: number
  status?: string
  genres?: string[]
  tags?: { name: string }[]
  popularity?: number
  trending?: number
  startDate?: {
    year?: number
    month?: number
    day?: number
  }
  format?: string
  averageScore?: number
}

interface AniListResponse {
  data: {
    Page: {
      pageInfo?: {
        total: number
        perPage: number
        currentPage: number
        lastPage: number
        hasNextPage: boolean
      }
      media: AniListMedia[]
    }
  }
}

interface AniListUserResponse {
  data: {
    Viewer: {
      id: number
      name: string
      avatar?: {
        large: string
      }
      options?: {
        profileColor?: string
      }
    }
  }
}

// Cache entry with timestamp
interface CacheEntry<T> {
  data: T
  timestamp: number
}

export class AniListService {
  private accessToken: string | null = null
  // Request cache (5 minute TTL)
  private cache = new Map<string, CacheEntry<any>>()
  private readonly CACHE_TTL = 5 * 60 * 1000 // 5 minutes
  // Request throttling - track last request time per endpoint
  private lastRequestTime = new Map<string, number>()
  private readonly MIN_REQUEST_INTERVAL = 1000 // 1 second between requests to same endpoint
  // Pending requests to avoid duplicate concurrent requests
  private pendingRequests = new Map<string, Promise<any>>()

  private isRateLimitError(error: any): boolean {
    if (!error) return false
    if (error.message && typeof error.message === 'string' && error.message.includes('Rate limit')) return true
    if (typeof error === 'object' && 'status' in error && (error as any).status === 429) return true
    return false
  }

  private isFetchFailed(error: any): boolean {
    if (!error) return false
    if (error instanceof TypeError && error.message === 'Failed to fetch') return true
    if (typeof error.message === 'string' && error.message.toLowerCase().includes('fetch failed')) return true
    return false
  }

  constructor(accessToken?: string) {
    this.accessToken = accessToken || null
  }

  /**
   * Fetch a diversified recommendation pool for mood-based suggestions.
   * Combines trending, popularity, and score-based lists and de-duplicates.
   */
  async getRecommendationPool(): Promise<Anime[]> {
    const fetchPool = async (sort: 'TRENDING_DESC' | 'POPULARITY_DESC' | 'SCORE_DESC', perPage: number) => {
      const query = `
        query GetRecommendationPool($perPage: Int) {
          Page(perPage: $perPage) {
            media(type: ANIME, sort: ${sort}) {
              id
              title {
                romaji
                english
                native
              }
              coverImage {
                large
                medium
              }
              bannerImage
              description
              episodes
              status
              genres
              tags {
                name
              }
              popularity
              trending
              averageScore
              startDate {
                year
                month
                day
              }
              format
            }
          }
        }
      `

      const response = await this.graphqlRequest<AniListResponse>(query, { perPage })
      return response.data.Page.media
    }

    try {
      // Smaller, sequential pulls to ease AniList rate limits.
      const trending = await fetchPool('TRENDING_DESC', 30).catch((err) => {
        if (this.isRateLimitError(err) || this.isFetchFailed(err)) return []
        throw err
      })
      const popular = await fetchPool('POPULARITY_DESC', 50).catch((err) => {
        if (this.isRateLimitError(err) || this.isFetchFailed(err)) return []
        throw err
      })
      const scored = await fetchPool('SCORE_DESC', 50).catch((err) => {
        if (this.isRateLimitError(err) || this.isFetchFailed(err)) return []
        throw err
      })

      const merged = [...trending, ...popular, ...scored]
      const seen = new Set<number>()
      const unique = merged.filter((m) => {
        if (seen.has(m.id)) return false
        seen.add(m.id)
        return true
      })

      return unique.map((media) => this.mapAniListMediaToAnime(media))
    } catch (error) {
      if (this.isFetchFailed(error)) {
        console.warn('Network error fetching recommendation pool; returning empty pool.')
        return []
      }
      if (this.isRateLimitError(error)) {
        console.warn('Rate limited on recommendation pool; returning empty pool.')
        return []
      }
      console.error('Error fetching recommendation pool:', error)
      throw error
    }
  }

  setAccessToken(token: string) {
    this.accessToken = token
    // Clear cache when token changes to avoid serving stale data
    this.cache.clear()
  }

  /**
   * Creates a cache key from query and variables
   */
  private getCacheKey(query: string, variables?: Record<string, unknown>): string {
    return `${query}:${JSON.stringify(variables || {})}`
  }

  /**
   * Checks if cached data is still valid
   */
  private getCached<T>(key: string): T | null {
    const entry = this.cache.get(key)
    if (!entry) return null

    const now = Date.now()
    if (now - entry.timestamp > this.CACHE_TTL) {
      this.cache.delete(key)
      return null
    }

    return entry.data as T
  }

  /**
   * Stores data in cache
   */
  private setCached<T>(key: string, data: T): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    })
  }

  /**
   * Throttles requests to prevent rate limiting
   */
  private async throttleRequest(endpointKey: string): Promise<void> {
    const lastTime = this.lastRequestTime.get(endpointKey) || 0
    const now = Date.now()
    const timeSinceLastRequest = now - lastTime

    if (timeSinceLastRequest < this.MIN_REQUEST_INTERVAL) {
      const waitTime = this.MIN_REQUEST_INTERVAL - timeSinceLastRequest
      await new Promise(resolve => setTimeout(resolve, waitTime))
    }

    this.lastRequestTime.set(endpointKey, Date.now())
  }

  /**
   * Retries a failed request with exponential backoff
   */
  private async retryWithBackoff<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    baseDelay: number = 1000
  ): Promise<T> {
    let lastError: Error | null = null

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn()
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error))
        
        // Don't retry on the last attempt
        if (attempt === maxRetries) break

        // Don't retry if it's not a network error
        if (!(error instanceof TypeError && error.message === 'Failed to fetch')) {
          throw error
        }

        // Exponential backoff: 1s, 2s, 4s
        const delay = baseDelay * Math.pow(2, attempt)
        console.warn(`Request failed, retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries})`)
        await new Promise(resolve => setTimeout(resolve, delay))
      }
    }

    throw lastError || new Error('Request failed after retries')
  }

  private async graphqlRequest<T>(query: string, variables?: Record<string, unknown>): Promise<T> {
    const cacheKey = this.getCacheKey(query, variables)
    const endpointKey = query.substring(0, 50) // Use first 50 chars as endpoint identifier

    // Check cache first
    const cached = this.getCached<T>(cacheKey)
    if (cached) {
      return cached
    }

    // Check if there's already a pending request for this query
    const pending = this.pendingRequests.get(cacheKey)
    if (pending) {
      return pending
    }

    // Throttle requests to prevent rate limiting
    await this.throttleRequest(endpointKey)

    // Create the request promise
    const requestPromise = this.retryWithBackoff(async () => {
      // If running in Electron, try IPC proxy to bypass CORS
      const electronApi = (globalThis as any)?.electron
      if (electronApi?.anilist?.graphql) {
        return electronApi.anilist.graphql({
          query,
          variables,
          accessToken: this.accessToken,
        }) as Promise<T>
      }

      const headers: HeadersInit = {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }

      if (this.accessToken) {
        headers['Authorization'] = `Bearer ${this.accessToken}`
      }

      const response = await fetch(ANILIST_API_URL, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          query,
          variables,
        }),
      })

      if (!response.ok) {
        const errorBody = await response.text()
        console.error('AniList API Error Body:', errorBody)
        
        // Handle rate limiting (429 Too Many Requests)
        if (response.status === 429) {
          throw new Error('Rate limit exceeded. Please wait a moment before trying again.')
        }
        
        throw new Error(`AniList API error (${response.status}): ${errorBody}`)
      }

      const data = await response.json()

      if (data.errors) {
        throw new Error(`GraphQL errors: ${JSON.stringify(data.errors)}`)
      }

      return data as T
    }).then((data) => {
      // Cache successful response
      this.setCached(cacheKey, data)
      // Remove from pending requests
      this.pendingRequests.delete(cacheKey)
      return data
    }).catch((error) => {
      // Remove from pending requests on error
      this.pendingRequests.delete(cacheKey)
      throw error
    })

    // Store pending request
    this.pendingRequests.set(cacheKey, requestPromise)

    try {
      return await requestPromise
    } catch (error) {
      // Enhanced error handling for network issues
      if (error instanceof TypeError && error.message === 'Failed to fetch') {
        console.error('Network error: Failed to fetch from AniList API. This could be due to:')
        console.error('1. Network connectivity issues')
        console.error('2. Rate limiting (too many requests)')
        console.error('3. CORS restrictions (unlikely for AniList)')
        throw new Error('Network error: Unable to connect to AniList API. Please check your internet connection or wait a moment and try again.')
      }
      throw error
    }
  }

  /**
   * Fetches trending anime from AniList
   */
  async getTrendingAnime(perPage: number = 10): Promise<Anime[]> {
    const query = `
      query GetTrendingAnime($perPage: Int) {
        Page(perPage: $perPage) {
          media(type: ANIME, sort: TRENDING_DESC, status: RELEASING) {
            id
            title {
              romaji
              english
              native
            }
            coverImage {
              large
              medium
            }
            bannerImage
            description
            episodes
            status
            genres
            tags {
              name
            }
            popularity
            trending
            startDate {
              year
              month
              day
            }
            format
            averageScore
          }
        }
      }
    `

    try {
      const response = await this.graphqlRequest<AniListResponse>(query, { perPage })
      const mediaList = response.data.Page.media

      return mediaList.map((media) => this.mapAniListMediaToAnime(media))
    } catch (error) {
      if (this.isFetchFailed(error)) {
        console.warn('Network error fetching trending; returning empty list.')
        return []
      }
      if (this.isRateLimitError(error)) {
        console.warn('Rate limited on trending; returning empty list.')
        return []
      }
      console.error('Error fetching trending anime:', error)
      throw error
    }
  }

  /**
   * Updates the progress for an anime
   */
  async updateProgress(
    mediaId: number,
    progress: number,
    status?: 'CURRENT' | 'PLANNING' | 'COMPLETED' | 'PAUSED' | 'DROPPED',
    episodeNumber?: number
  ): Promise<boolean> {
    if (!this.accessToken) {
      throw new Error('Authentication required to update progress')
    }

    const mutation = `
      mutation UpdateProgress($mediaId: Int!, $progress: Int!, $status: MediaListStatus, $episode: Int) {
        SaveMediaListEntry(mediaId: $mediaId, progress: $progress, status: $status, episode: $episode) {
          id
          progress
          status
        }
      }
    `

    try {
      await this.graphqlRequest(mutation, {
        mediaId,
        progress,
        status: status || 'PLANNING',
        episode: episodeNumber,
      })
      return true
    } catch (error) {
      console.error('Error updating progress:', error)
      throw error
    }
  }

  /**
   * Fetches top rated anime from AniList
   */
  async getTopRatedAnime(perPage: number = 10): Promise<Anime[]> {
    const query = `
      query GetTopRatedAnime($perPage: Int) {
        Page(perPage: $perPage) {
          media(type: ANIME, sort: SCORE_DESC) {
            id
            title {
              romaji
              english
              native
            }
            coverImage {
              large
              medium
            }
            bannerImage
            description
            episodes
            status
            genres
            tags {
              name
            }
            popularity
            trending
            startDate {
              year
              month
              day
            }
            format
            averageScore
          }
        }
      }
    `

    try {
      const response = await this.graphqlRequest<AniListResponse>(query, { perPage })
      const mediaList = response.data.Page.media

      return mediaList.map((media) => this.mapAniListMediaToAnime(media))
    } catch (error) {
      if (this.isFetchFailed(error)) {
        console.warn('Network error fetching top rated; returning empty list.')
        return []
      }
      if (this.isRateLimitError(error)) {
        console.warn('Rate limited on top rated; returning empty list.')
        return []
      }
      console.error('Error fetching top rated anime:', error)
      throw error
    }
  }

  /**
   * Searches for anime with proper pagination and server-side filtering
   */
  async searchAnime(
    query: string, 
    filters: { 
      genre?: string | null, 
      year?: string | null, 
      sort?: string 
    }, 
    page: number = 1, 
    perPage: number = 20
  ): Promise<Anime[]> {
    // We added $page, $year (seasonYear), and $sort to the query
    const queryString = `
      query SearchAnime($search: String, $genres: [String], $page: Int, $perPage: Int, $year: Int, $sort: [MediaSort]) {
        Page(page: $page, perPage: $perPage) {
          pageInfo {
            total
            perPage
            currentPage
            lastPage
            hasNextPage
          }
          media(type: ANIME, search: $search, genre_in: $genres, seasonYear: $year, sort: $sort) {
            id
            title {
              romaji
              english
              native
            }
            coverImage {
              large
              medium
            }
            bannerImage
            description
            episodes
            status
            genres
            startDate {
              year
              month
              day
            }
            format
            averageScore
          }
        }
      }
    `

    try {
      // Construct variables dynamically
      const variables: Record<string, any> = {
        page,
        perPage,
        sort: filters.sort || 'POPULARITY_DESC', // Default sort
      }

      // Only add search if user typed something (empty string returns weird results sometimes)
      if (query && query.trim().length > 0) {
        variables.search = query
      }

      if (filters.genre) {
        variables.genres = [filters.genre]
      }

      // Send the year to the server!
      if (filters.year) {
        variables.year = parseInt(filters.year)
      }

      const response = await this.graphqlRequest<AniListResponse>(queryString, variables)
      const mediaList = response.data.Page.media

      return mediaList.map((media) => this.mapAniListMediaToAnime(media))
    } catch (error) {
      console.error('Error searching anime:', error)
      throw error
    }
  }

  /**
   * Gets the current user's profile
   */
  async getCurrentUser() {
    if (!this.accessToken) {
      throw new Error('Authentication required')
    }

    const query = `
      query GetCurrentUser {
        Viewer {
          id
          name
          avatar {
            large
          }
          options {
            profileColor
          }
        }
      }
    `

    try {
      const response = await this.graphqlRequest<AniListUserResponse>(query)
      return response.data.Viewer
    } catch (error) {
      console.error('Error fetching user:', error)
      throw error
    }
  }

  /**
   * Fetches the user's entire library (Watch List)
   */
  async getUserLibrary(userId: number): Promise<Anime[]> {
    const query = `
      query GetUserLibrary($userId: Int) {
        MediaListCollection(userId: $userId, type: ANIME) {
          lists {
            entries {
              status
              progress
              score
              media {
                id
                title {
                  romaji
                  english
                  native
                }
                coverImage {
                  large
                  medium
                }
                bannerImage
                description
                episodes
                genres
                startDate {
                  year
                }
                format
                averageScore
              }
            }
          }
        }
      }
    `

    try {
      const response = await this.graphqlRequest<any>(query, { userId })
      const lists = response.data.MediaListCollection?.lists || []

      let allAnime: Anime[] = []

      for (const list of lists) {
        const mappedEntries = list.entries.map((entry: any) => {
          const anime = this.mapAniListMediaToAnime(entry.media)
          
          // 1. Force the progress from the User's List (not the generic anime data)
          anime.progress = entry.progress || 0
          
          // 2. Map AniList Rating
          if (entry.score) {
            anime.rating = entry.score
          }

          // 3. STRICT 4 CATEGORY MAPPING (No "on-hold" category)
          // Maps AniList's "PAUSED" to "plan-to-watch" to avoid a 5th category
          const statusMap: Record<string, 'watching' | 'plan-to-watch' | 'completed' | 'dropped'> = {
            'CURRENT': 'watching',
            'REPEATING': 'watching',
            'COMPLETED': 'completed',
            'DROPPED': 'dropped',
            'PLANNING': 'plan-to-watch',
            'PAUSED': 'plan-to-watch' // Force "Paused" into "Planning" to avoid 5th category
          }
          
          anime.status = statusMap[entry.status] || 'plan-to-watch'
          
          return anime
        })
        allAnime = [...allAnime, ...mappedEntries]
      }

      return allAnime
    } catch (error) {
      console.error('Error fetching user library:', error)
      return []
    }
  }

  private mapAniListMediaToAnime(media: AniListMedia): Anime {
    return {
      id: media.id.toString(),
      title: media.title.romaji,
      titleEnglish: media.title.english || undefined,
      titleJapanese: media.title.native || undefined,
      description: media.description || undefined,
      coverImage: media.coverImage.large,
      bannerImage: media.bannerImage || undefined,
      episodes: media.episodes || undefined,
      status: 'plan-to-watch', // Default status, will be updated from user's list
      progress: 0,
      rating: media.averageScore ? media.averageScore / 10 : undefined,
      genres: media.genres || [],
      year: media.startDate?.year || undefined,
      format: media.format as 'TV' | 'Movie' | 'OVA' | 'ONA' | 'Special' | undefined,
      createdAt: new Date(),
      updatedAt: new Date(),
      // Attach extra AniList metadata for downstream consumers (mood recs, stats)
      ...(media.averageScore ? { averageScore: media.averageScore } : {}),
      ...(media.popularity ? { popularity: media.popularity } : {}),
      ...(media.trending ? { trending: media.trending } : {}),
      ...(media.tags ? { tags: media.tags.map((t) => t.name) } : {}),
    }
  }

  /**
   * Fetch franchise timeline (all seasons in order) for an anime
   * Walks prequels to find root, then follows sequels to build complete timeline
   * Returns: [Season 1, Season 2, Season 3, ...] in order
   */
  async getFranchiseTimeline(mediaId: number): Promise<Anime[]> {
    console.log('[AniVault] Fetching franchise timeline for media ID:', mediaId)
    
    const query = `
      query GetMediaWithRelations($id: Int) {
        Media(id: $id) {
          id
          title {
            romaji
            english
            native
          }
          episodes
          format
          coverImage {
            large
            medium
          }
          bannerImage
          description
          status
          genres
          averageScore
          popularity
          startDate {
            year
            month
            day
          }
          relations {
            edges {
              relationType
              node {
                id
                title {
                  romaji
                  english
                  native
                }
                episodes
                format
              }
            }
          }
        }
      }
    `

    try {
      // Step A: Find the root (walk back through prequels)
      let currentId = mediaId
      let root: any | null = null
      const visited = new Set<number>()

      while (true) {
        if (visited.has(currentId)) {
          console.warn('[AniVault] Circular relation detected, breaking')
          break
        }
        visited.add(currentId)

        const response = await this.graphqlRequest<{ data: { Media: any } }>(query, { id: currentId })
        const media = response.data.Media

        // Check for prequel
        const prequelEdge = media.relations?.edges?.find((edge: any) => edge.relationType === 'PREQUEL')
        
        if (prequelEdge && prequelEdge.node) {
          console.log(`[AniVault] Found prequel: ${prequelEdge.node.title.romaji} (${prequelEdge.node.id})`)
          currentId = prequelEdge.node.id
        } else {
          // No prequel = this is the root
          root = media
          console.log(`[AniVault] Found root: ${media.title.romaji} (${media.id})`)
          break
        }
      }

      if (!root) {
        console.warn('[AniVault] Failed to find root, using original media')
        const response = await this.graphqlRequest<{ data: { Media: any } }>(query, { id: mediaId })
        root = response.data.Media
      }

      // Step B & C: Build timeline by walking sequels from root
      const timeline: Anime[] = []
      const timelineVisited = new Set<number>()
      let current = root

      while (current) {
        if (timelineVisited.has(current.id)) {
          console.warn('[AniVault] Circular sequel detected, breaking')
          break
        }
        timelineVisited.add(current.id)

        // Add current to timeline
        const anime = this.mapAniListMediaToAnime(current)
        timeline.push(anime)
        console.log(`[AniVault] Timeline [${timeline.length}]: ${anime.title} (${anime.episodes || '?'} eps)`)

        // Find sequel
        const sequelEdge = current.relations?.edges?.find((edge: any) => edge.relationType === 'SEQUEL')
        
        if (sequelEdge && sequelEdge.node) {
          console.log(`[AniVault] Found sequel: ${sequelEdge.node.title.romaji}`)
          // Fetch full data for sequel
          const seqResponse = await this.graphqlRequest<{ data: { Media: any } }>(query, { id: sequelEdge.node.id })
          current = seqResponse.data.Media
        } else {
          // No more sequels
          break
        }
      }

      console.log(`[AniVault] âœ… Franchise timeline complete: ${timeline.length} season(s)`)
      return timeline

    } catch (error) {
      console.error('[AniVault] Failed to fetch franchise timeline:', error)
      // Fallback: return just the requested anime
      try {
        const response = await this.graphqlRequest<{ data: { Media: any } }>(query, { id: mediaId })
        return [this.mapAniListMediaToAnime(response.data.Media)]
      } catch {
        return []
      }
    }
  }
}

// Export singleton instance
export const anilistService = new AniListService()



========================================

=== apps\desktop\src\renderer\services\auth.service.ts ===

// Replace with your actual Client ID from AniList
const ANILIST_CLIENT_ID = import.meta.env.VITE_ANILIST_CLIENT_ID || '32987'
const ANILIST_REDIRECT_URI = 'anivault://auth/callback'


const ANILIST_AUTH_URL =
  `https://anilist.co/api/v2/oauth/authorize` +
  `?client_id=${ANILIST_CLIENT_ID}` +
  `&redirect_uri=${encodeURIComponent(ANILIST_REDIRECT_URI)}` +
  `&response_type=code`

/**
 * Initiates AniList OAuth login flow
 */
export async function loginWithAnilist(): Promise<string> {
  if (!window.electron?.auth?.openOAuthWindow) {
    throw new Error('Authentication system not initialized. Please restart the app.')
  }

  console.log('Opening Auth URL:', ANILIST_AUTH_URL)
  const token = await window.electron.auth.openOAuthWindow(ANILIST_AUTH_URL)

  if (token) return token
  throw new Error('Authentication cancelled or failed')
}

/**
 * Logs out the current user
 */
export async function logout(): Promise<void> {
  await window.electron.auth.logout()
}

/**
 * Gets the stored access token
 */
export async function getStoredToken(): Promise<string | null> {
  return await window.electron.auth.getToken()
}


========================================

=== apps\desktop\src\renderer\services\licensing.service.ts ===

const LEMONSQUEEZY_API_URL = 'https://api.lemonsqueezy.com/v1/licenses/activate'

/**
 * Validates a license key with LemonSqueezy
 */
export async function validateLicenseKey(key: string): Promise<boolean> {
  try {
    const response = await fetch(LEMONSQUEEZY_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        license_key: key,
      }),
    })

    if (!response.ok) {
      return false
    }

    const data = await response.json()

    // Check if the license is valid and activated
    // Adjust this based on LemonSqueezy's actual response structure
    return data.valid === true && data.activated === true
  } catch (error) {
    console.error('Error validating license key:', error)
    return false
  }
}

declare global {
  interface Window {
    electron: {
      license: {
        getKey: () => Promise<string | null>
        storeKey: (key: string) => Promise<void>
      }
    }
  }
}

/**
 * Gets the stored license key
 */
export async function getStoredLicenseKey(): Promise<string | null> {
  return await window.electron.license.getKey()
}

/**
 * Stores a license key
 */
export async function storeLicenseKey(key: string): Promise<void> {
  await window.electron.license.storeKey(key)
}



========================================

=== apps\desktop\src\renderer\services\recommendation.service.ts ===

import type { Anime } from '@anivault/shared'
import { anilistService } from './anilist.service'

export type MoodId =
  | 'hype'
  | 'chill'
  | 'emotional'
  | 'dark'
  | 'comedy'
  | 'romcom'
  | 'mind_bend'
  | 'wholesome'

export interface MoodDefinition {
  id: MoodId
  label: string
  description: string
  emoji: string
  includeTags: string[]
  excludeTags?: string[]
  minScore?: number
  sortBy?: 'score' | 'popularity' | 'trending'
  maxEpisodesHint?: number
}

export interface MoodRecommendation {
  mood: MoodDefinition
  anime: Anime[]
}

export interface MoodRecommendationOptions {
  limit?: number
  excludeCompleted?: boolean
  excludeDropped?: boolean
}

export const MOODS: MoodDefinition[] = [
  {
    id: 'hype',
    label: 'Hype Mode',
    description: 'High energy, big stakes, pure adrenaline.',
    emoji: 'ğŸ”¥',
    includeTags: ['Shounen', 'Action', 'Battle', 'Super Power', 'Tournament'],
    excludeTags: [],
    minScore: 70,
    sortBy: 'trending',
  },
  {
    id: 'chill',
    label: 'Chill',
    description: 'Cozy slice-of-life and iyashikei vibes.',
    emoji: 'ğŸ˜Œ',
    includeTags: ['Slice of Life', 'Iyashikei', 'Relaxing', 'Healing', 'CGDCT'],
    excludeTags: ['Horror', 'Gore'],
    sortBy: 'score',
    maxEpisodesHint: 26,
  },
  {
    id: 'emotional',
    label: 'Emotional',
    description: 'Heartfelt drama and romance that hit hard.',
    emoji: 'ğŸ˜­',
    includeTags: ['Drama', 'Romance', 'Tragedy', 'Sad'],
    excludeTags: ['Parody'],
    minScore: 72,
    sortBy: 'score',
  },
  {
    id: 'dark',
    label: 'Dark',
    description: 'Psychological, horror, and thriller twists.',
    emoji: 'ğŸ–¤',
    includeTags: ['Psychological', 'Horror', 'Thriller', 'Seinen', 'Dark Fantasy'],
    excludeTags: ['Iyashikei', 'CGDCT'],
    minScore: 70,
    sortBy: 'score',
  },
  {
    id: 'comedy',
    label: 'Comedy',
    description: 'Parody, gags, and laugh-out-loud moments.',
    emoji: 'ğŸ˜‚',
    includeTags: ['Comedy', 'Parody', 'Gag Humor', 'Slapstick'],
    excludeTags: ['Horror'],
    sortBy: 'popularity',
  },
  {
    id: 'romcom',
    label: 'Rom-Com',
    description: 'Romance with a side of comedy.',
    emoji: 'ğŸ’•',
    includeTags: ['Romance', 'Comedy', 'Romantic Comedy', 'School'],
    excludeTags: ['Horror'],
    sortBy: 'score',
  },
  {
    id: 'mind_bend',
    label: 'Mind-Bend',
    description: 'Psychological, mystery, time-twisting stories.',
    emoji: 'ğŸŒ€',
    includeTags: ['Psychological', 'Mystery', 'Supernatural', 'Time Travel'],
    excludeTags: ['Parody'],
    minScore: 72,
    sortBy: 'score',
  },
  {
    id: 'wholesome',
    label: 'Wholesome',
    description: 'Family-friendly, cute, heartwarming shows.',
    emoji: 'ğŸŒ¸',
    includeTags: ['Slice of Life', 'Family', 'CGDCT', 'Iyashikei', 'Friendship'],
    excludeTags: ['Horror', 'Ecchi', 'Gore'],
    sortBy: 'score',
    maxEpisodesHint: 24,
  },
]

export const AVAILABLE_MOODS = MOODS

export function getMoodById(id: MoodId): MoodDefinition | undefined {
  return MOODS.find((m) => m.id === id)
}

/**
 * Compute mood-based recommendations using only client-side data and AniList API.
 * Steps:
 * 1) Pull a diversified candidate pool (trending/popular/score).
 * 2) Score candidates against the chosen mood using tags/genres/score/length.
 * 3) Filter out completed/dropped entries from the user's library.
 * 4) Sort by moodScore and the mood's preferred tie-breaker.
 */
export async function getMoodRecommendations(
  moodId: MoodId,
  library: Anime[],
  options: MoodRecommendationOptions = {}
): Promise<MoodRecommendation> {
  const mood = getMoodById(moodId)
  if (!mood) {
    throw new Error(`Mood not found: ${moodId}`)
  }

  const { limit = 12, excludeCompleted = true, excludeDropped = true } = options

  // Build quick lookup for library statuses to filter out completed/dropped entries.
  const libraryStatusById = new Map<string, string>()
  for (const item of library || []) {
    if (item?.id) {
      libraryStatusById.set(item.id, (item as any).status || '')
    }
  }

  const pool = await anilistService.getRecommendationPool()

  const scored = pool
    .map((anime) => {
      const tags = ((anime as any).tags as string[] | undefined) || []
      const genres = ((anime as any).genres as string[] | undefined) || anime.genres || []
      const avgScore = (anime as any).averageScore as number | undefined
      const episodes = (anime as any).episodes as number | undefined
      const status = (anime as any).status as string | undefined
      const popularity = (anime as any).popularity as number | undefined
      const trending = (anime as any).trending as number | undefined

      // Library-based filters
      const libraryStatus = libraryStatusById.get(anime.id)
      if (excludeCompleted && libraryStatus === 'completed') return null
      if (excludeDropped && libraryStatus === 'dropped') return null

      let moodScore = 0

      // Matching tags/keywords (AniList tags)
      const tagMatches = tags.filter((t) => mood.includeTags.includes(t))
      moodScore += tagMatches.length * 15

      // Matching genres (weaker weight)
      const genreMatches = genres.filter((g) => mood.includeTags.includes(g))
      moodScore += genreMatches.length * 8

      // Apply minimum score preference
      if (mood.minScore && typeof avgScore === 'number' && avgScore >= mood.minScore) {
        moodScore += 10
      }

      // Exclusions hard-block
      const exclusions = mood.excludeTags || []
      const hasExcluded = exclusions.some((ex) => tags.includes(ex) || genres.includes(ex))
      if (hasExcluded) {
        moodScore = Number.NEGATIVE_INFINITY
      }

      // Prefer shorter runs for certain moods
      if (mood.maxEpisodesHint && episodes && episodes <= mood.maxEpisodesHint) {
        moodScore += 5
      }

      // Slight bonus for finished shows (better binge) for certain moods
      if (status === 'FINISHED' && (mood.id === 'emotional' || mood.id === 'mind_bend' || mood.id === 'chill')) {
        moodScore += 3
      }

      return {
        anime,
        moodScore,
        avgScore: typeof avgScore === 'number' ? avgScore : -1,
        popularity: typeof popularity === 'number' ? popularity : -1,
        trending: typeof trending === 'number' ? trending : -1,
      }
    })
    .filter((entry): entry is NonNullable<typeof entry> => Boolean(entry) && entry.moodScore !== Number.NEGATIVE_INFINITY)

  // Sort by moodScore first, then tie-breaker
  scored.sort((a, b) => {
    if (b.moodScore !== a.moodScore) return b.moodScore - a.moodScore

    switch (mood.sortBy) {
      case 'score':
        return (b.avgScore ?? -1) - (a.avgScore ?? -1)
      case 'popularity':
        return (b.popularity ?? -1) - (a.popularity ?? -1)
      case 'trending':
      default:
        return (b.trending ?? -1) - (a.trending ?? -1)
    }
  })

  const top = scored
    .filter((entry) => Number.isFinite(entry.moodScore))
    .slice(0, limit)
    .map((entry) => entry.anime)

  return {
    mood,
    anime: top,
  }
}



========================================

=== apps\desktop\src\renderer\services\stats.service.ts ===

import type { Anime } from '@anivault/shared'

export const EPISODE_MINUTES = 24

export type WatchSource = 'desktop' | 'extension' | 'manual'

export interface WatchEvent {
  animeId: number
  episode: number
  at: string // ISO timestamp
  source: WatchSource
}

export interface LibraryStats {
  totalEpisodes: number
  totalMinutes: number
  totalHours: number
  totalAnime: number
  genreBreakdown: Array<{ name: string; count: number }>
  scoreDistribution: Array<{ score: number; count: number }>
}

// Heatmap over days (GitHub-style)
export interface HeatmapCell {
  date: string // 'YYYY-MM-DD'
  count: number // episodes watched that day
}

export interface HeatmapData {
  cells: HeatmapCell[]
  maxCount: number // maximum episodes in a single day, used for intensity scaling
}

// Binge sessions and profile
export interface BingeSession {
  date: string // 'YYYY-MM-DD'
  start: string // ISO timestamp of first episode in session
  end: string // ISO timestamp of last episode in session
  episodes: number // episodes in this session
  animeIds: number[] // unique anime IDs in this session
}

export type WatcherArchetype =
  | 'night-owl'
  | 'weekend-marathoner'
  | 'daily-sipper'
  | 'casual'
  | 'unknown'

export interface BingeProfile {
  totalSessions: number
  longestSession: BingeSession | null
  averageEpisodesPerSession: number
  mostEpisodesInADay: number
  archetype: WatcherArchetype
}

// Milestones / achievements
export interface MilestoneProgress {
  id: string
  title: string
  description: string
  current: number
  target: number
  achievedAt?: string // ISO timestamp if completed
}

// Yearly summary / â€œWrappedâ€-style metrics
export interface TopGenreSummary {
  genre: string
  count: number
}

export interface TopAnimeSummary {
  animeId: number
  title: string
  episodes: number
}

export interface YearlySummary {
  year: number
  totalEpisodes: number
  totalHours: number
  animeStarted: number
  animeCompleted: number
  topGenres: TopGenreSummary[]
  topAnime: TopAnimeSummary[]
}

export interface StatsSnapshot {
  libraryStats: LibraryStats
  heatmap: HeatmapData
  bingeProfile: BingeProfile
  milestones: MilestoneProgress[]
  yearlySummary: YearlySummary | null
}

/**
 * Calculate summary statistics for a library.
 * Gracefully handles missing data:
 * - progress falls back to episodes, then 12 if both are missing.
 * - score is clamped to 1â€“100; missing scores are skipped.
 */
export function calculateLibraryStats(library: Anime[]): LibraryStats {
  let totalEpisodes = 0
  let totalAnime = 0

  const genreCounts = new Map<string, number>()
  const scoreBuckets = new Map<number, number>() // key = bucket start (1, 11, 21, ...)

  for (const anime of library) {
    // Episodes/progress handling
    const progress = safeNumber(anime.progress)
    const episodes = safeNumber((anime as any).episodes) // episodes may not exist on some shapes
    const effectiveEpisodes = progress ?? episodes ?? 12
    totalEpisodes += effectiveEpisodes

    // Completed or watching count
    if (anime.status === 'completed' || anime.status === 'watching') {
      totalAnime += 1
    }

    // Genre aggregation
    const genres = (anime as any).genres as string[] | undefined
    if (Array.isArray(genres)) {
      for (const genre of genres) {
        const name = String(genre)
        genreCounts.set(name, (genreCounts.get(name) ?? 0) + 1)
      }
    }

    // Score distribution (bucketed by 10s: 1â€“10, 11â€“20, ..., 91â€“100)
    // Anime.rating is 0â€“10; convert to 1â€“100 scale
    const rating = safeNumber((anime as any).rating)
    if (rating !== null) {
      const normalized = Math.round(rating * 10) // 0â€“10 -> 0â€“100
      const clamped = Math.min(Math.max(normalized, 1), 100)
      const bucketStart = Math.floor((clamped - 1) / 10) * 10 + 1 // 1,11,21...
      scoreBuckets.set(bucketStart, (scoreBuckets.get(bucketStart) ?? 0) + 1)
    }
  }

  // Top 5 genres
  const genreBreakdown = Array.from(genreCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([name, count]) => ({ name, count }))

  // Score distribution sorted by bucket start
  const scoreDistribution = Array.from(scoreBuckets.entries())
    .sort((a, b) => a[0] - b[0])
    .map(([score, count]) => ({ score, count }))

  const totalMinutes = totalEpisodes * EPISODE_MINUTES

  return {
    totalEpisodes,
    totalMinutes,
    totalHours: totalMinutes / 60, // derived hours (24 min per ep -> hours)
    totalAnime,
    genreBreakdown,
    scoreDistribution,
  }
}

// --- Analytics helpers ---

export function buildHeatmapData(events: WatchEvent[]): HeatmapData {
  if (!events.length) return { cells: [], maxCount: 0 }
  const grouped = new Map<string, number>()
  for (const ev of events) {
    const date = formatDate(ev.at)
    grouped.set(date, (grouped.get(date) ?? 0) + 1)
  }
  const cells: HeatmapCell[] = Array.from(grouped.entries())
    .map(([date, count]) => ({ date, count }))
    .sort((a, b) => a.date.localeCompare(b.date))
  const maxCount = cells.reduce((max, cell) => Math.max(max, cell.count), 0)
  return { cells, maxCount }
}

export function buildBingeProfile(events: WatchEvent[]): BingeProfile {
  if (!events.length) {
    return {
      totalSessions: 0,
      longestSession: null,
      averageEpisodesPerSession: 0,
      mostEpisodesInADay: 0,
      archetype: 'unknown',
    }
  }

  const sorted = [...events].sort((a, b) => a.at.localeCompare(b.at))
  const sessions: BingeSession[] = []
  const gapMinutes = 45

  let current: BingeSession | null = null

  const pushCurrent = () => {
    if (current) {
      current.animeIds = Array.from(new Set(current.animeIds))
      sessions.push(current)
    }
  }

  for (const ev of sorted) {
    if (!current) {
      current = {
        date: formatDate(ev.at),
        start: ev.at,
        end: ev.at,
        episodes: 1,
        animeIds: [ev.animeId],
      }
      continue
    }

    const gap = minutesBetween(current.end, ev.at)
    if (gap <= gapMinutes) {
      current.end = ev.at
      current.episodes += 1
      current.animeIds.push(ev.animeId)
    } else {
      pushCurrent()
      current = {
        date: formatDate(ev.at),
        start: ev.at,
        end: ev.at,
        episodes: 1,
        animeIds: [ev.animeId],
      }
    }
  }
  pushCurrent()

  const totalSessions = sessions.length
  const longestSession =
    sessions.reduce<BingeSession | null>((acc, s) => (acc && acc.episodes >= s.episodes ? acc : s), null) || null
  const totalEpisodesInSessions = sessions.reduce((sum, s) => sum + s.episodes, 0)
  const averageEpisodesPerSession = totalSessions > 0 ? totalEpisodesInSessions / totalSessions : 0

  const episodesPerDay = new Map<string, number>()
  for (const s of sessions) {
    episodesPerDay.set(s.date, (episodesPerDay.get(s.date) ?? 0) + s.episodes)
  }
  const mostEpisodesInADay = Array.from(episodesPerDay.values()).reduce((m, v) => Math.max(m, v), 0)

  const archetype = inferArchetypeSimple(sessions, episodesPerDay, mostEpisodesInADay)

  return {
    totalSessions,
    longestSession,
    averageEpisodesPerSession,
    mostEpisodesInADay,
    archetype,
  }
}

export function buildMilestones(library: Anime[], events: WatchEvent[]): MilestoneProgress[] {
  const totalEpisodes = events.length
  const completedCount = library.filter((a) => a.status === 'completed').length

  // TODO: when rewatch tracking is available, replace current with actual rewatch counts
  const rewatchCount = 0

  const lateNightCount = events.filter((ev) => {
    const hour = new Date(ev.at).getHours()
    return hour >= 0 && hour < 3
  }).length

  const milestones: MilestoneProgress[] = [
    {
      id: 'episodes_100',
      title: '100 Episodes Watched',
      description: 'Reach 100 watched episodes',
      target: 100,
      current: Math.min(totalEpisodes, 100),
      achievedAt: undefined, // could compute exact timestamp later
    },
    {
      id: 'anime_completed_10',
      title: '10 Anime Completed',
      description: 'Complete 10 anime',
      target: 10,
      current: Math.min(completedCount, 10),
      achievedAt: undefined,
    },
    {
      id: 'rewatches_3',
      title: '3 Anime Rewatched',
      description: 'Rewatch 3 anime',
      target: 3,
      current: Math.min(rewatchCount, 3),
      achievedAt: undefined,
    },
    {
      id: 'late_night_50',
      title: '50 Late Night Episodes',
      description: 'Watch 50 episodes between 00:00â€“03:00',
      target: 50,
      current: Math.min(lateNightCount, 50),
      achievedAt: undefined,
    },
  ]

  // If we want to compute achievedAt for episodes_100 now:
  const epMilestone = milestones.find((m) => m.id === 'episodes_100')
  if (epMilestone && totalEpisodes >= epMilestone.target) {
    epMilestone.achievedAt = findAchievementDate(events, epMilestone.target)
  }

  return milestones
}

export function buildYearlySummary(
  library: Anime[],
  events: WatchEvent[],
  year: number = new Date().getFullYear()
): YearlySummary | null {
  const filtered = events.filter((ev) => ev.at.startsWith(`${year}-`))
  if (filtered.length === 0) return null

  const totalEpisodes = filtered.length
  const totalHours = (totalEpisodes * EPISODE_MINUTES) / 60

  // animeStarted: first event in that year
  const firstEventByAnime = new Map<number, string>()
  for (const ev of filtered) {
    if (!firstEventByAnime.has(ev.animeId)) {
      firstEventByAnime.set(ev.animeId, ev.at)
    }
  }
  const animeStarted = firstEventByAnime.size

  // animeCompleted approximation
  const animeCompleted = library.filter((a) => {
    if (a.status !== 'completed') return false
    // If completedAt exists, use it; else approximate using progress == episodes and at least one event in the year
    const completedAt = (a as any).completedAt as string | undefined
    if (completedAt) {
      return completedAt.startsWith(`${year}-`)
    }
    const episodes = safeNumber((a as any).episodes)
    const progress = safeNumber((a as any).progress)
    const hasEventInYear = filtered.some((ev) => ev.animeId === Number(a.id) || ev.animeId === (a as any).id)
    if (!hasEventInYear) return false
    if (episodes !== null && progress !== null) {
      return progress >= episodes
    }
    return false
  }).length

  // Top genres based on events' anime
  const animeById = new Map<number | string, Anime>()
  for (const a of library) {
    animeById.set(a.id as any, a)
    animeById.set(Number(a.id), a)
  }

  const genreCounts = new Map<string, number>()
  const eventsPerAnime = new Map<number, number>()

  for (const ev of filtered) {
    const anime = animeById.get(ev.animeId) || animeById.get(String(ev.animeId))
    if (anime) {
      const genres = (anime as any).genres as string[] | undefined
      if (Array.isArray(genres)) {
        for (const g of genres) {
          genreCounts.set(g, (genreCounts.get(g) ?? 0) + 1)
        }
      }
    }
    eventsPerAnime.set(ev.animeId, (eventsPerAnime.get(ev.animeId) ?? 0) + 1)
  }

  const topGenres: TopGenreSummary[] = Array.from(genreCounts.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([genre, count]) => ({ genre, count }))

  const topAnime: TopAnimeSummary[] = Array.from(eventsPerAnime.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([animeId, episodes]) => {
      const anime = animeById.get(animeId) || animeById.get(String(animeId))
      return {
        animeId,
        title: anime?.title ?? 'Unknown',
        episodes,
      }
    })

  return {
    year,
    totalEpisodes,
    totalHours,
    animeStarted,
    animeCompleted,
    topGenres,
    topAnime,
  }
}

export function buildStatsSnapshot(library: Anime[], events: WatchEvent[]): StatsSnapshot {
  const libraryStats = calculateLibraryStats(library)
  const heatmap = buildHeatmapData(events)
  const bingeProfile = buildBingeProfile(events)
  const milestones = buildMilestones(library, events)
  const currentYear = new Date().getFullYear()
  const yearlySummary = buildYearlySummary(library, events, currentYear)

  return {
    libraryStats,
    heatmap,
    bingeProfile,
    milestones,
    yearlySummary,
  }
}

function safeNumber(value: unknown): number | null {
  if (typeof value === 'number' && !Number.isNaN(value)) return value
  return null
}

function formatDate(value: string | Date): string {
  const date = value instanceof Date ? value : new Date(value)
  return date.toISOString().slice(0, 10) // YYYY-MM-DD
}

function minutesBetween(startIso: string, endIso: string): number {
  const start = new Date(startIso).getTime()
  const end = new Date(endIso).getTime()
  return Math.max(0, (end - start) / (1000 * 60))
}

function inferArchetype(sessions: BingeSession[], avgEpisodes: number, mostInDay: number): WatcherArchetype {
  if (!sessions.length) return 'unknown'

  const eveningSessions = sessions.filter((s) => {
    const hour = new Date(s.start).getHours()
    return hour >= 21 || hour < 3
  }).length

  const weekendSessions = sessions.filter((s) => {
    const d = new Date(s.start).getDay()
    return d === 0 || d === 6
  }).length

  const total = sessions.length
  const eveningShare = eveningSessions / total
  const weekendShare = weekendSessions / total

  if (eveningShare >= 0.6 && mostInDay >= 3) return 'night-owl'
  if (weekendShare >= 0.6 && mostInDay >= 4) return 'weekend-marathoner'
  if (avgEpisodes <= 2 && total >= 5) return 'daily-sipper'
  if (avgEpisodes <= 2 && total < 5) return 'casual'

  return 'unknown'
}

// Simple archetype using sessions + episodes-per-day map
function inferArchetypeSimple(
  sessions: BingeSession[],
  episodesPerDay: Map<string, number>,
  mostEpisodesInADay: number
): WatcherArchetype {
  const totalSessions = sessions.length
  if (totalSessions === 0) return 'unknown'

  const eveningSessions = sessions.filter((s) => {
    const hour = new Date(s.start).getHours()
    return hour >= 21 || hour < 3
  }).length

  const weekendSessions = sessions.filter((s) => {
    const d = new Date(s.start).getDay()
    return d === 0 || d === 6
  }).length

  const eveningShare = eveningSessions / totalSessions
  const weekendShare = weekendSessions / totalSessions

  const totalEpisodes = Array.from(episodesPerDay.values()).reduce((sum, n) => sum + n, 0)
  const avgPerSession = totalEpisodes > 0 ? totalEpisodes / totalSessions : 0

  if (eveningShare >= 0.6 && mostEpisodesInADay >= 3) return 'night-owl'
  if (weekendShare >= 0.6 && mostEpisodesInADay >= 4) return 'weekend-marathoner'
  if (avgPerSession <= 2 && totalSessions >= 5) return 'daily-sipper'
  if (avgPerSession <= 2 && totalSessions < 5) return 'casual'

  return 'unknown'
}

function findAchievementDate(events: WatchEvent[], target: number): string | undefined {
  if (target <= 0) return undefined
  let count = 0
  const sorted = [...events].sort((a, b) => a.at.localeCompare(b.at))
  for (const ev of sorted) {
    count += 1
    if (count >= target) return ev.at
  }
  return undefined
}



========================================

=== apps\desktop\src\renderer\services\tracking.service.ts ===

import type { Anime } from '@anivault/shared'

/**
 * Resolves an absolute episode number to the correct season and relative episode
 * 
 * @param timeline - Array of anime seasons in order [Season 1, Season 2, ...]
 * @param absoluteEpisode - The global episode number (e.g., 14 across all seasons)
 * @returns Object with the matched anime ID, relative episode, and title
 * 
 * Example:
 * - Timeline: [Kaiju S1: 12 eps, Kaiju S2: 11 eps]
 * - Absolute Episode: 14
 * - Returns: { animeId: "S2_ID", episode: 2, title: "Kaiju No. 8 Season 2" }
 */
export function resolveFranchiseEpisode(
  timeline: Anime[],
  absoluteEpisode: number
): { animeId: string; episode: number; title: string } | null {
  console.log('[AniVault] Resolving franchise episode:', {
    absoluteEpisode,
    timelineLength: timeline.length
  })

  if (timeline.length === 0) {
    console.warn('[AniVault] Empty timeline provided')
    return null
  }

  let cumulativeOffset = 0

  // Iterate through timeline (S1 -> S2 -> S3...)
  for (let i = 0; i < timeline.length; i++) {
    const anime = timeline[i]
    const maxEpisodes = (anime as any).episodes as number | undefined || 25 // Fallback for airing shows

    console.log(`[AniVault] Checking ${anime.title}: ${maxEpisodes} episodes, offset: ${cumulativeOffset}`)

    // Check if absoluteEpisode falls within this season's range
    if (absoluteEpisode <= cumulativeOffset + maxEpisodes) {
      const relativeEpisode = absoluteEpisode - cumulativeOffset

      console.log(`[AniVault] âœ… Match found in ${anime.title}:`, {
        absoluteEpisode,
        relativeEpisode,
        seasonIndex: i + 1,
        offset: cumulativeOffset
      })

      return {
        animeId: anime.id,
        episode: relativeEpisode,
        title: anime.title,
      }
    }

    // Not in this season, move to next
    cumulativeOffset += maxEpisodes
  }

  // Fallback: absoluteEpisode exceeds all known seasons
  // Return the last season with the calculated episode
  const lastAnime = timeline[timeline.length - 1]
  const fallbackEpisode = absoluteEpisode - cumulativeOffset + ((lastAnime as any).episodes as number || 0)
  
  console.log(`[AniVault] âš ï¸ Episode exceeds timeline, using last season:`, {
    absoluteEpisode,
    fallbackEpisode,
    lastAnime: lastAnime.title
  })

  return {
    animeId: lastAnime.id,
    episode: fallbackEpisode,
    title: lastAnime.title,
  }
}

/**
 * Calculate episode counts for each season in a franchise timeline
 * Returns array of episode counts: [12, 11, 13, ...] for [S1, S2, S3, ...]
 */
export function getEpisodeCountsFromTimeline(timeline: Anime[]): number[] {
  return timeline.map(anime => (anime as any).episodes as number || 25)
}



========================================

=== apps\desktop\src\renderer\store\useStore.ts ===

import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import type { User, Anime } from '@anivault/shared'
import type { WatchEvent, WatchSource } from '../services/stats.service'
import { anilistService } from '../services/anilist.service'
import { loginWithAnilist, getStoredToken, logout as authLogout } from '../services/auth.service'
import { validateLicenseKey, getStoredLicenseKey, storeLicenseKey } from '../services/licensing.service'

interface AppState {
  // User state
  user: User | null
  isAuthenticated: boolean
  isGuest: boolean
  accessToken: string | null

  // License state
  isPro: boolean
  licenseKey: string | null

  // Library state
  library: Anime[]

  // Watch events log
  watchEvents: WatchEvent[]

  // Theme state
  theme: string

  // Discord presence preferences
  discordPresenceEnabled: boolean
  discordPresenceMode: 'minimal' | 'stats' | 'weeb'
  discordPresenceUseMood: boolean
  discordPresenceShowButtons: boolean
  lastPresenceContext?: { title: string; episode: number; totalEpisodes?: number }
  // Auto Organizer
  organizerSourceDir: string | null
  organizerTargetRoot: string | null

  // Title mappings: Map "Filename Title" -> "AniList ID"
  // Example: { "Kimetsu no Yaiba": "101922" }
  titleMappings: Record<string, string>

  // Actions
  login: () => Promise<void>
  logout: () => Promise<void>
  enableGuestMode: () => void
  checkAuth: () => Promise<void>
  validateLicense: (key: string) => Promise<boolean>
  checkLicense: () => Promise<void>
  activatePro: (key: string) => Promise<boolean>
  deactivatePro: () => Promise<void>
  setUser: (user: User | null) => void
  setAccessToken: (token: string | null) => void
  addToLibrary: (anime: Anime, status: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch') => Promise<void>
  removeFromLibrary: (animeId: string) => void
  updateStatus: (animeId: string, status: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch') => Promise<void>
  updateProgress: (animeId: string, updates: { status?: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch'; progress?: number }, source?: WatchSource) => Promise<void>
  updateEntry: (animeId: string, updates: { status?: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch'; progress?: number }) => Promise<void>
  logWatchEvents: (animeId: string, fromEpisode: number, toEpisode: number, source: WatchSource) => void
  addMapping: (filenameTitle: string, anilistId: string) => void
  findAnimeByTitle: (filenameTitle: string) => Anime | null
  devTogglePro: () => void
  setTheme: (themeId: string) => void
  setDiscordPresenceEnabled: (value: boolean) => void
  setDiscordPresenceMode: (mode: 'minimal' | 'stats' | 'weeb') => void
  setDiscordPresenceUseMood: (value: boolean) => void
  setDiscordPresenceShowButtons: (value: boolean) => void
  setLastPresenceContext: (ctx: { title: string; episode: number; totalEpisodes?: number } | undefined) => void
  setOrganizerSourceDir: (dir: string | null) => void
  setOrganizerTargetRoot: (dir: string | null) => void
}

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      // Initial state
      user: null,
      isAuthenticated: false,
      isGuest: false,
      accessToken: null,
      isPro: false,
      licenseKey: null,
      library: [],
      watchEvents: [],
      theme: 'default',
      discordPresenceEnabled: true,
      discordPresenceMode: 'minimal',
      discordPresenceUseMood: true,
      discordPresenceShowButtons: true,
      lastPresenceContext: undefined,
      organizerSourceDir: null,
      organizerTargetRoot: null,
      titleMappings: {},

  // Login action
  login: async () => {
    try {
      const token = await loginWithAnilist()
      
      // 1. Set Token
      anilistService.setAccessToken(token)
      
      // 2. Fetch User Profile
      const anilistUser = await anilistService.getCurrentUser()
      
      const user: User = {
        id: anilistUser.id.toString(),
        username: anilistUser.name,
        avatar: anilistUser.avatar?.large,
        preferences: {
          theme: 'dark',
          autoTrack: true,
          syncEnabled: true,
          notifications: true,
          language: 'en',
        },
        createdAt: new Date(),
        updatedAt: new Date(),
      }

      // 3. Fetch Cloud Library
      console.log('Fetching library for user:', anilistUser.id)
      const cloudLibrary = await anilistService.getUserLibrary(anilistUser.id)
      console.log('Library fetched from cloud:', cloudLibrary.length, 'items')
      
      // 4. TRUE MERGE STRATEGY
      // Start with a copy of your CURRENT local library.
      // This ensures local-only items are PRESERVED.
      const currentLibrary = get().library
      const mergedLibrary = [...currentLibrary]
      console.log('Current local library:', currentLibrary.length, 'items')

      cloudLibrary.forEach((cloudAnime) => {
        const localIndex = mergedLibrary.findIndex((local) => local.id === cloudAnime.id)

        if (localIndex >= 0) {
          // CONFLICT: Item exists in both places.
          // We update the local copy with cloud details (syncing progress/score).
          mergedLibrary[localIndex] = {
            ...mergedLibrary[localIndex],
            ...cloudAnime, 
            updatedAt: new Date(),
          }
        } else {
          // NEW: Item exists on AniList but not locally.
          // We add it to the library.
          mergedLibrary.push(cloudAnime)
        }
      })

      // The result: mergedLibrary contains (Local Only) + (Cloud Only) + (Synced Shared)
      console.log('Merged library:', mergedLibrary.length, 'items')

      set({
        accessToken: token,
        user,
        isAuthenticated: true,
        library: mergedLibrary, // Save the merged list
      })
    } catch (error) {
      console.error('Login failed:', error)
      throw error
    }
  },

  // Logout action
  logout: async () => {
    await authLogout()
    anilistService.setAccessToken(null)
    set({
      user: null,
      isAuthenticated: false,
      isGuest: false,
      accessToken: null,
    })
  },

  // Enable guest mode
  enableGuestMode: () => {
    set({
      isGuest: true,
      isAuthenticated: false,
      user: null,
      accessToken: null,
    })
  },

  // Check authentication on app start
  checkAuth: async () => {
    try {
      const token = await getStoredToken()
      if (token) {
        anilistService.setAccessToken(token)
        
        // Try to fetch user to verify token is still valid
        const anilistUser = await anilistService.getCurrentUser()
        
        const user: User = {
          id: anilistUser.id.toString(),
          username: anilistUser.name,
          avatar: anilistUser.avatar?.large,
          preferences: {
            theme: 'dark',
            autoTrack: true,
            syncEnabled: true,
            notifications: true,
            language: 'en',
          },
          createdAt: new Date(),
          updatedAt: new Date(),
        }

        set({
          accessToken: token,
          user,
          isAuthenticated: true,
        })
      }
    } catch (error) {
      console.error('Auth check failed:', error)
      // Token is invalid, clear it
      set({
        accessToken: null,
        user: null,
        isAuthenticated: false,
      })
    }
  },

  // Validate license key
  validateLicense: async (key: string) => {
    try {
      const isValid = await validateLicenseKey(key)
      if (isValid) {
        set({
          isPro: true,
          licenseKey: key,
        })
        try {
          await storeLicenseKey(key)
        } catch (error) {
          console.error('Failed to store license key locally:', error)
        }
      } else {
        set({
          isPro: false,
          licenseKey: null,
        })
      }
      return isValid
    } catch (error) {
      console.error('License validation failed:', error)
      return false
    }
  },

  // Check stored license
  checkLicense: async () => {
    try {
      const key = await getStoredLicenseKey()
      if (key) {
        const isValid = await validateLicenseKey(key)
        set({
          isPro: isValid,
          licenseKey: isValid ? key : null,
        })
      }
    } catch (error) {
      console.error('License check failed:', error)
    }
  },

  // Activate Pro with a license key
  activatePro: async (key: string) => {
    const trimmedKey = key.trim()
    if (!trimmedKey) {
      return false
    }

    // Dev Bypass
    if (trimmedKey === 'DEV-PRO-TEST') {
      set({ isPro: true, licenseKey: trimmedKey })
      try {
        await storeLicenseKey(trimmedKey)
      } catch (error) {
        console.error('Failed to store license key locally:', error)
      }
      return true
    }

    try {
      // Use the new IPC handler
      const result = await window.electron.license.validate(trimmedKey)

      if (result.success) {
        set({ isPro: true, licenseKey: trimmedKey })
        try {
          await storeLicenseKey(trimmedKey)
        } catch (error) {
          console.error('Failed to store license key locally:', error)
        }
        return true
      }

      set({
        isPro: false,
        licenseKey: null,
      })
      return false
    } catch (error) {
      console.error('Activation error:', error)
      set({
        isPro: false,
        licenseKey: null,
      })
      return false
    }
  },

  // Deactivate Pro and remove stored key
  deactivatePro: async () => {
    set({
      isPro: false,
      licenseKey: null,
      theme: 'default',
    })
    try {
      await storeLicenseKey('')
    } catch (error) {
      console.error('Failed to clear license key:', error)
    }
  },

      // Dev helper: toggle Pro locally
      devTogglePro: () => {
        const wasPro = get().isPro
        const nextPro = !wasPro
        set({
          isPro: nextPro,
          ...(wasPro ? { theme: 'default' } : {}),
        })
      },

      setTheme: (themeId: string) => {
        const nextTheme = themeId && themeId.trim().length > 0 ? themeId : 'default'
        set({ theme: nextTheme })
      },

      setDiscordPresenceEnabled: (value: boolean) => set({ discordPresenceEnabled: value }),
      setDiscordPresenceMode: (mode: 'minimal' | 'stats' | 'weeb') => set({ discordPresenceMode: mode }),
      setDiscordPresenceUseMood: (value: boolean) => set({ discordPresenceUseMood: value }),
      setDiscordPresenceShowButtons: (value: boolean) => set({ discordPresenceShowButtons: value }),
      setLastPresenceContext: (ctx) => set({ lastPresenceContext: ctx }),
      setOrganizerSourceDir: (dir: string | null) => set({ organizerSourceDir: dir }),
      setOrganizerTargetRoot: (dir: string | null) => set({ organizerTargetRoot: dir }),

      // Setters
      setUser: (user: User | null) => set({ user }),
      setAccessToken: (token: string | null) => {
        anilistService.setAccessToken(token)
        set({ accessToken: token })
      },

      // Add to library
      addToLibrary: async (anime: Anime, status: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch') => {
        const { library, accessToken, isGuest } = get()
        
        // Check if anime already exists in library
        const existingIndex = library.findIndex(a => a.id === anime.id)
        
        const updatedAnime: Anime = {
          ...anime,
          status,
          updatedAt: new Date(),
        }

        let updatedLibrary: Anime[]
        if (existingIndex >= 0) {
          // Update existing entry
          updatedLibrary = [...library]
          updatedLibrary[existingIndex] = updatedAnime
        } else {
          // Add new entry
          updatedLibrary = [...library, updatedAnime]
        }

        set({ library: updatedLibrary })

        // Sync with AniList ONLY if authenticated (not guest mode)
        if (accessToken && !isGuest) {
          try {
            const mediaId = parseInt(anime.id)
            const progress = anime.progress || 0
            
            // Map our status to AniList status
            const anilistStatus = status === 'plan-to-watch' ? 'PLANNING' :
                                 status === 'watching' ? 'CURRENT' :
                                 status === 'completed' ? 'COMPLETED' :
                                 status === 'on-hold' ? 'PAUSED' : 'DROPPED'
            
            await anilistService.updateProgress(mediaId, progress, anilistStatus)
          } catch (error) {
            console.error('Failed to sync with AniList:', error)
            // Don't throw - library update succeeded locally
          }
        }
      },

      // Remove from library
      removeFromLibrary: (animeId: string) => {
        const { library } = get()
        const updatedLibrary = library.filter((a) => a.id !== animeId)
        set({ library: updatedLibrary })
      },

      // Update status
      updateStatus: async (animeId: string, status: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch') => {
        const { library, accessToken } = get()
        const existingIndex = library.findIndex((a) => a.id === animeId)
        
        if (existingIndex === -1) {
          console.warn('Anime not found in library')
          return
        }

        const anime = library[existingIndex]
        const updatedAnime: Anime = {
          ...anime,
          status,
          updatedAt: new Date(),
        }

        const updatedLibrary = [...library]
        updatedLibrary[existingIndex] = updatedAnime
        set({ library: updatedLibrary })

        // Sync with AniList if authenticated (not guest mode)
        if (accessToken && !get().isGuest) {
          try {
            const mediaId = parseInt(animeId)
            const progress = anime.progress || 0
            
            // Map our status to AniList status
            const anilistStatus = status === 'plan-to-watch' ? 'PLANNING' :
                                 status === 'watching' ? 'CURRENT' :
                                 status === 'completed' ? 'COMPLETED' :
                                 status === 'on-hold' ? 'PAUSED' : 'DROPPED'
            
            await anilistService.updateProgress(mediaId, progress, anilistStatus)
          } catch (error) {
            console.error('Failed to sync with AniList:', error)
            // Don't throw - library update succeeded locally
          }
        }
      },

      // Log watch events for a range of episodes
      logWatchEvents: (animeId, fromEpisode, toEpisode, source) => {
        const animeIdNum = Number(animeId)
        if (!Number.isFinite(animeIdNum)) return

        const now = Date.now()

        set((state) => {
          const events: WatchEvent[] = []
          const start = Math.min(fromEpisode, toEpisode)
          const end = Math.max(fromEpisode, toEpisode)

          for (let ep = start; ep <= end; ep++) {
            events.push({
              animeId: animeIdNum,
              episode: ep,
              at: new Date(now + (ep - start) * 1000).toISOString(), // slight offset just to keep order
              source,
            })
          }

          return {
            watchEvents: [...state.watchEvents, ...events],
          }
        })
      },

      // Update progress
      updateProgress: async (
        animeId: string,
        updates: { status?: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch'; progress?: number },
        source: WatchSource = 'manual'
      ) => {
        const { library, accessToken } = get()
        const existingIndex = library.findIndex((a) => a.id === animeId)

        if (existingIndex === -1) {
          console.warn('Anime not found in library')
          return
        }

        const anime = library[existingIndex]

        const currentProgress = typeof anime.progress === 'number' ? anime.progress : 0
        const episodesRaw = (anime as any).episodes
        const totalEpisodes =
          typeof episodesRaw === 'number'
            ? episodesRaw
            : Number.isFinite(Number(episodesRaw))
            ? Number(episodesRaw)
            : null

        let nextProgress = updates.progress ?? currentProgress

        // Never go backwards
        if (nextProgress < currentProgress) {
          nextProgress = currentProgress
        }

        // Never exceed total episodes if known
        if (totalEpisodes !== null && nextProgress > totalEpisodes) {
          nextProgress = totalEpisodes
        }

        // If anime is in "plan-to-watch" or "dropped" status, automatically change to "watching"
        // when an episode is detected (user is actively watching)
        const nextStatus =
          updates.status ??
          (anime.status === 'plan-to-watch' || anime.status === 'dropped'
            ? 'watching'
            : totalEpisodes !== null && nextProgress >= totalEpisodes
            ? 'completed'
            : anime.status)

        const updatedAnime: Anime = {
          ...anime,
          ...(nextStatus && { status: nextStatus }),
          ...(Number.isFinite(nextProgress) && { progress: nextProgress }),
          updatedAt: new Date(),
        }

        const updatedLibrary = [...library]
        updatedLibrary[existingIndex] = updatedAnime
        set({ library: updatedLibrary })

        // Log watch events for newly watched episodes
        if (
          nextProgress > currentProgress &&
          Number.isFinite(nextProgress) &&
          source
        ) {
          get().logWatchEvents(
            animeId,
            currentProgress + 1,
            nextProgress,
            source
          )
        }

        // Sync with AniList if authenticated (not guest mode)
        if (accessToken && !get().isGuest) {
          try {
            const mediaId = parseInt(animeId)
            const progress = updatedAnime.progress || 0
            const status = updatedAnime.status

            const anilistStatus =
              status === 'plan-to-watch'
                ? 'PLANNING'
                : status === 'watching'
                ? 'CURRENT'
                : status === 'completed'
                ? 'COMPLETED'
                : status === 'on-hold'
                ? 'PAUSED'
                : 'DROPPED'

            await anilistService.updateProgress(
              mediaId,
              progress,
              anilistStatus,
              updates.progress
            )
          } catch (error) {
            console.error('Failed to sync with AniList:', error)
            // Don't throw - library update succeeded locally
          }
        }
      },

      // Update entry (status and/or progress)
      updateEntry: async (animeId: string, updates: { status?: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch'; progress?: number }) => {
        const { library, accessToken } = get()
        const existingIndex = library.findIndex((a) => a.id === animeId)
        
        if (existingIndex === -1) {
          console.warn('Anime not found in library')
          return
        }

        const anime = library[existingIndex]
        const updatedAnime: Anime = {
          ...anime,
          ...(updates.status && { status: updates.status }),
          ...(updates.progress !== undefined && { progress: updates.progress }),
          updatedAt: new Date(),
        }

        const updatedLibrary = [...library]
        updatedLibrary[existingIndex] = updatedAnime
        set({ library: updatedLibrary })

        // Sync with AniList if authenticated (not guest mode)
        if (accessToken && !get().isGuest) {
          try {
            const mediaId = parseInt(animeId)
            const progress = updatedAnime.progress || 0
            const status = updatedAnime.status
            
            // Map our status to AniList status
            const anilistStatus = status === 'plan-to-watch' ? 'PLANNING' :
                                 status === 'watching' ? 'CURRENT' :
                                 status === 'completed' ? 'COMPLETED' :
                                 status === 'on-hold' ? 'PAUSED' : 'DROPPED'
            
            await anilistService.updateProgress(mediaId, progress, anilistStatus, updates.progress)
          } catch (error) {
            console.error('Failed to sync with AniList:', error)
            // Don't throw - library update succeeded locally
          }
        }
      },

      // Add title mapping
      addMapping: (filenameTitle: string, anilistId: string) => {
        const { titleMappings } = get()
        set({
          titleMappings: {
            ...titleMappings,
            [filenameTitle.toLowerCase()]: anilistId,
          },
        })
      },

      // Find anime by title (checks library and mappings)
      findAnimeByTitle: (filenameTitle: string) => {
        const { library, titleMappings } = get()
        const normalizedTitle = filenameTitle.toLowerCase().trim()

        // Helper: Extract season number from title
        const getSeasonNumber = (title: string): number | null => {
          const lower = title.toLowerCase()
          
          // "Season 2", "2nd Season", "Part 2"
          const seasonMatch = lower.match(/season\s+(\d+)/i) || 
                            lower.match(/(\d+)(?:st|nd|rd|th)\s+season/i) ||
                            lower.match(/part\s+(\d+)/i)
          if (seasonMatch?.[1]) return parseInt(seasonMatch[1], 10)
          
          // "S2"
          const shortMatch = lower.match(/\bs(\d+)\b/i)
          if (shortMatch?.[1]) return parseInt(shortMatch[1], 10)
          
          // Roman numerals: II, III, IV, V
          const romanMatch = lower.match(/\s+(ii|iii|iv|v|vi|vii|viii|ix|x)$/i)
          if (romanMatch) {
            const romanMap: Record<string, number> = {
              'ii': 2, 'iii': 3, 'iv': 4, 'v': 5,
              'vi': 6, 'vii': 7, 'viii': 8, 'ix': 9, 'x': 10
            }
            return romanMap[romanMatch[1].toLowerCase()] || null
          }
          
          return null // No season = Season 1
        }

        const searchSeasonNum = getSeasonNumber(normalizedTitle) || 1

        // First, check if we have a mapping for this title
        const mappedId = titleMappings[normalizedTitle]
        if (mappedId) {
          const mappedAnime = library.find((a) => a.id === mappedId)
          if (mappedAnime) {
            return mappedAnime
          }
        }

        // Try exact title match
        const exactMatch = library.find(
          (anime) =>
            anime.title.toLowerCase() === normalizedTitle ||
            anime.titleEnglish?.toLowerCase() === normalizedTitle ||
            anime.titleJapanese?.toLowerCase() === normalizedTitle
        )
        if (exactMatch) {
          return exactMatch
        }

        // Fuzzy match with strict season filtering
        const candidates = library.filter((anime) => {
          const animeTitle = anime.title.toLowerCase()
          const animeEnglish = anime.titleEnglish?.toLowerCase() || ''
          const animeJapanese = anime.titleJapanese?.toLowerCase() || ''
          
          // Check if titles overlap
          const titleMatches = normalizedTitle.includes(animeTitle) ||
                              animeTitle.includes(normalizedTitle) ||
                              (animeEnglish && (normalizedTitle.includes(animeEnglish) || animeEnglish.includes(normalizedTitle))) ||
                              (animeJapanese && (normalizedTitle.includes(animeJapanese) || animeJapanese.includes(normalizedTitle)))
          
          if (!titleMatches) return false
          
          // Strict season filtering
          const animeSeasonNum = getSeasonNumber(anime.title) || 1
          
          if (searchSeasonNum !== animeSeasonNum) {
            // Reject wrong season
            return false
          }
          
          return true
        })

        if (candidates.length === 0) {
          return null
        }

        // Sort by string length similarity (prefer exact length matches)
        candidates.sort((a, b) => {
          const aDiff = Math.abs(a.title.length - filenameTitle.length)
          const bDiff = Math.abs(b.title.length - filenameTitle.length)
          return aDiff - bDiff
        })

        return candidates[0]
      },
    }),
    {
      name: 'anivault-storage', // localStorage key
      partialize: (state) => ({ 
        library: state.library,
        user: state.user,
        isAuthenticated: state.isAuthenticated,
        isGuest: state.isGuest,
        accessToken: state.accessToken,
        isPro: state.isPro,
        licenseKey: state.licenseKey,
        theme: state.theme,
        discordPresenceEnabled: state.discordPresenceEnabled,
        discordPresenceMode: state.discordPresenceMode,
        discordPresenceUseMood: state.discordPresenceUseMood,
        discordPresenceShowButtons: state.discordPresenceShowButtons,
        lastPresenceContext: state.lastPresenceContext,
        organizerSourceDir: state.organizerSourceDir,
        organizerTargetRoot: state.organizerTargetRoot,
        titleMappings: state.titleMappings,
        watchEvents: state.watchEvents,
      }), // Persist library, user, auth state, guest mode, title mappings, and watch events
    }
  )
)



========================================

=== apps\desktop\src\renderer\vite-env.d.ts ===

/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_ANILIST_CLIENT_ID?: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

interface Window {
  electron: {
    minimize: () => Promise<void>
    maximize: () => Promise<void>
    close: () => Promise<void>
    isMaximized: () => Promise<boolean>
    onMaximize: (callback: (isMaximized: boolean) => void) => void
    onUnmaximize: (callback: (isMaximized: boolean) => void) => void
    // Auth IPC
    auth: {
      openExternal: (url: string) => Promise<void>
      onTokenReceived: (callback: (token: string) => void) => void
      removeTokenListener: () => void
      getToken: () => Promise<string | null>
      logout: () => Promise<void>
      // Legacy method (kept for backward compatibility)
      openOAuthWindow: (url: string) => Promise<string | null>
    }
    // License IPC
    license: {
      getKey: () => Promise<string | null>
      storeKey: (key: string) => Promise<void>
    }
    // Tracking IPC
    tracking: {
      onUpdate: (callback: (data: { title: string; episode: number }) => void) => void
      removeListener: () => void
    }
  }
}



========================================

=== apps\desktop\tailwind.config.js ===

import baseConfig from '@anivault/ui/tailwind'

/** @type {import('tailwindcss').Config} */
export default {
  ...baseConfig,
  content: [
    './src/renderer/**/*.{js,ts,jsx,tsx}',
    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    ...(baseConfig.theme || {}),
    extend: {
      ...(baseConfig.theme?.extend || {}),
      colors: {
        ...(baseConfig.theme?.extend?.colors || {}),
        background: 'var(--bg-main)',
        card: 'var(--bg-card)',
        foreground: 'var(--text-main)',
        muted: 'var(--bg-card)',
        'muted-foreground': 'var(--text-muted)',
        primary: 'var(--primary)',
        border: 'var(--border)',
      },
    },
  },
}



========================================

=== apps\desktop\tsconfig.json ===

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/renderer/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist-electron", "release"]
}



========================================

=== apps\extension\.gitkeep ===

# Placeholder for extension icons
# Add icon-16.png, icon-32.png, icon-48.png, icon-128.png here



========================================

=== apps\extension\manifest.json ===

{
  "manifest_version": 3,
  "name": "AniVault",
  "version": "0.1.0",
  "description": "Track anime on streaming sites and sync to AniVault Desktop",
  "permissions": [
    "storage",
    "tabs",
    "scripting",
    "alarms"
  ],
  "host_permissions": [
    "https://*.crunchyroll.com/*",
    "https://*.netflix.com/*",
    "https://zoro.to/*",
    "https://*.zoro.to/*",
    "https://aniwatch.to/*",
    "https://*.aniwatch.to/*",
    "https://hianime.to/*",
    "https://*.hianime.to/*",
    "https://zorox.to/*",
    "https://*.zorox.to/*",
    "https://9anime.to/*",
    "https://*.9anime.to/*",
    "https://aniwave.to/*",
    "https://*.aniwave.to/*",
    "https://gogoanime.io/*",
    "https://*.gogoanime.io/*",
    "https://animepahe.com/*",
    "https://*.animepahe.com/*",
    "https://animepahe.ru/*",
    "https://*.animepahe.ru/*"
  ],
  "background": {
    "service_worker": "src/background/background.ts",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": [
        "https://*.crunchyroll.com/*",
        "https://*.netflix.com/*",
        "https://zoro.to/*",
        "https://*.zoro.to/*",
        "https://aniwatch.to/*",
        "https://*.aniwatch.to/*",
        "https://hianime.to/*",
        "https://*.hianime.to/*",
        "https://zorox.to/*",
        "https://*.zorox.to/*",
        "https://9anime.to/*",
        "https://*.9anime.to/*",
        "https://aniwave.to/*",
        "https://*.aniwave.to/*",
        "https://gogoanime.io/*",
        "https://*.gogoanime.io/*",
        "https://animepahe.com/*",
        "https://*.animepahe.com/*",
        "https://animepahe.ru/*",
        "https://*.animepahe.ru/*"
      ],
      "js": ["src/content/content.ts"],
      "run_at": "document_idle",
      "all_frames": true
    }
  ],
  "action": {
    "default_popup": "src/popup/index.html",
    "default_icon": {
      "16": "icons/icon-16.png",
      "32": "icons/icon-32.png",
      "48": "icons/icon-48.png",
      "128": "icons/icon-128.png"
    }
  },
  "icons": {
    "16": "icons/icon-16.png",
    "32": "icons/icon-32.png",
    "48": "icons/icon-48.png",
    "128": "icons/icon-128.png"
  }
}



========================================

=== apps\extension\package.json ===

{
  "name": "extension",
  "version": "0.1.0",
  "description": "AniVault Chrome Extension",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "generate-icons": "node scripts/generate-icons.js",
    "prebuild": "npm run generate-icons"
  },
  "dependencies": {
    "@anivault/shared": "workspace:*",
    "@anivault/ui": "workspace:*",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@crxjs/vite-plugin": "^2.0.0-beta.21",
    "@types/chrome": "^0.0.251",
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3",
    "vite": "^5.0.8"
  }
}



========================================

=== apps\extension\postcss.config.js ===

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



========================================

=== apps\extension\README.md ===

# AniVault Chrome Extension

Auto-track anime episodes on streaming sites and sync with AniVault Desktop.

## Supported Sites

### First-Class Support
- **Crunchyroll** - Official streaming platform
- **Netflix** - Official streaming platform
- **Zoro / AniWatch / HiAnime / ZoroX / AniWave** - Popular anime streaming clones
- **9anime / AniWave** - 9anime and reskins

### Generic Fallback
The extension includes a generic adapter that works on **any anime streaming site** that:
- Has a `<video>` element
- Shows episode information in the page title or headings

This means the extension will work on most anime sites out of the box, even if they're not explicitly listed!

## Development

### Prerequisites

- Node.js 18+
- pnpm 8+

### Running in Development

```bash
# From repo root
pnpm dev:extension
```

This will:
1. Build the extension with Vite + crxjs
2. Watch for changes and rebuild automatically
3. Output to `apps/extension/dist/`

### Loading in Chrome

1. Open Chrome and navigate to `chrome://extensions/`
2. Enable "Developer mode" (toggle in top-right)
3. Click "Load unpacked"
4. Select the `apps/extension/dist/` directory

The extension will reload automatically when you rebuild.

## Features

- **Auto-detection**: Automatically detects anime episodes on Crunchyroll and Netflix
- **Video tracking**: Tracks video playback and sends completion events at 80% watched
- **Desktop sync**: Sends events to AniVault Desktop app via localhost HTTP endpoint
- **Offline queue**: Queues events if desktop app is not running, syncs when available
- **Beautiful popup**: Shows current status, recent activity, and settings

## Architecture

- **Site Adapters** (`src/content/adapters.ts`): Modular system for detecting episodes on different sites
  - Each adapter handles URL matching, episode detection, and video element finding
  - Adapters are prioritized: specific ones (Crunchyroll, Netflix) come first, generic fallback last
- **Content Scripts** (`src/content/`): Run on streaming sites, use adapters to detect episodes, track video playback
- **Background Service Worker** (`src/background/`): Handles events, stores history, syncs with desktop
- **Popup UI** (`src/popup/`): React-based UI showing status and recent activity

### Site Adapter System

The extension uses a modular adapter system that makes it easy to support new sites:

```typescript
interface SiteAdapter {
  id: Platform
  match: (url: string) => boolean
  detectEpisode: () => EpisodeDetection | null
  findVideoElement: () => HTMLVideoElement | null
}
```

This allows one adapter to cover multiple clones (e.g., Zoro adapter works on zoro.to, zoro.sx, aniwatch.to, etc.)

## Configuration

The extension stores settings in `chrome.storage.local`:
- `settings.autoTrack`: Enable/disable auto-tracking (default: true)
- `lastWatched`: Array of recently tracked episodes (last 20)
- `pendingSync`: Events queued for sync when desktop app is offline

## Desktop Integration

The extension communicates with AniVault Desktop via HTTP:
- Endpoint: `http://127.0.0.1:4156/extension/episode-complete`
- Method: POST
- Body: JSON with episode completion data

The desktop app must be running for events to sync in real-time. Events are queued if the desktop app is offline.



========================================

=== apps\extension\scripts\generate-icons.js ===

// Simple script to generate placeholder extension icons
// Run with: node scripts/generate-icons.js

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Create a simple 1x1 pixel PNG as placeholder
// This is a minimal valid PNG file (1x1 red pixel)
const minimalPNG = Buffer.from(
  'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==',
  'base64'
)

const iconsDir = path.join(__dirname, '..', 'icons')
const sizes = [16, 32, 48, 128]

// Ensure icons directory exists
if (!fs.existsSync(iconsDir)) {
  fs.mkdirSync(iconsDir, { recursive: true })
}

// Generate placeholder icons
sizes.forEach((size) => {
  const filePath = path.join(iconsDir, `icon-${size}.png`)
  fs.writeFileSync(filePath, minimalPNG)
  console.log(`Created ${filePath}`)
})

console.log('Placeholder icons generated!')
console.log('Replace these with actual AniVault icons later.')



========================================

=== apps\extension\src\background\background.ts ===

// Background service worker for AniVault Extension
import type {
  ExtensionEpisodeEvent,
  EpisodeCompleteEvent,
  LastWatchedEntry,
  ExtensionSettings,
  ExtensionStorage,
} from '../types'
import { DESKTOP_APP_URL, DESKTOP_APP_CLEAR_URL } from '../types'

const STORAGE_KEYS = {
  SETTINGS: 'settings',
  LAST_WATCHED: 'lastWatched',
  PENDING_SYNC: 'pendingSync',
} as const

const MAX_LAST_WATCHED = 20

/**
 * Initialize default settings on install
 */
chrome.runtime.onInstalled.addListener(async (details) => {
  console.log('[AniVault] Extension installed/updated:', details.reason)

  // Initialize default settings
  const result = await chrome.storage.local.get(STORAGE_KEYS.SETTINGS)
  if (!result.settings) {
    const defaultSettings: ExtensionSettings = {
      autoTrack: true,
      lastSeenVersion: chrome.runtime.getManifest().version,
    }
    await chrome.storage.local.set({ [STORAGE_KEYS.SETTINGS]: defaultSettings })
  }

  // Initialize lastWatched if it doesn't exist
  const watchedResult = await chrome.storage.local.get(STORAGE_KEYS.LAST_WATCHED)
  if (!watchedResult.lastWatched) {
    await chrome.storage.local.set({ [STORAGE_KEYS.LAST_WATCHED]: [] })
  }
})

/**
 * Send episode completion event to Desktop app
 */
async function sendToDesktop(event: ExtensionEpisodeEvent): Promise<boolean> {
  try {
    const response = await fetch(DESKTOP_APP_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(event),
    })

    if (response.ok) {
      console.log('[AniVault] Successfully sent event to desktop app')
      return true
    }
  } catch (error) {
    // Silently ignore - desktop app might not be running
  }

  return false
}

/**
 * Notify desktop app that detection was cleared
 */
async function notifyDesktopClear(): Promise<void> {
  try {
    await fetch(DESKTOP_APP_CLEAR_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    })
  } catch (error) {
    // Silently ignore - desktop app might not be running
  }
}

/**
 * Handle episode completion event
 */
async function handleEpisodeCompleted(event: ExtensionEpisodeEvent): Promise<void> {
  // Update recentActivity (dedup by platform+title+episode)
  const result = await chrome.storage.local.get(['recentActivity'])
  const current: ExtensionEpisodeEvent[] = result.recentActivity || []

  const key = `${event.platform}::${event.title}::${event.overallEpisode ?? event.seasonEpisode ?? 'na'}`

  const filtered = current.filter((entry) => {
    const entryKey = `${entry.platform}::${entry.title}::${entry.overallEpisode ?? entry.seasonEpisode ?? 'na'}`
    return entryKey !== key
  })

  const updated = [event, ...filtered].slice(0, 10)
  await chrome.storage.local.set({ recentActivity: updated })

  // Send to desktop
  await sendToDesktop(event)
}

/**
 * Store episode completion event
 */
async function storeLastWatched(entry: LastWatchedEntry): Promise<void> {
  const result = await chrome.storage.local.get(STORAGE_KEYS.LAST_WATCHED)
  const lastWatched: LastWatchedEntry[] = result.lastWatched || []

  // Add to beginning
  lastWatched.unshift(entry)

  // Keep only last MAX_LAST_WATCHED entries
  if (lastWatched.length > MAX_LAST_WATCHED) {
    lastWatched.splice(MAX_LAST_WATCHED)
  }

  await chrome.storage.local.set({ [STORAGE_KEYS.LAST_WATCHED]: lastWatched })
}

/**
 * Add event to pending sync queue
 */
async function addToPendingSync(event: EpisodeCompleteEvent['data']): Promise<void> {
  const result = await chrome.storage.local.get(STORAGE_KEYS.PENDING_SYNC)
  const pendingSync: EpisodeCompleteEvent['data'][] = result.pendingSync || []

  // Check if already in queue (deduplicate by title + episode + season)
  const episodeNum = event.overallEpisode ?? event.seasonEpisode ?? 'na'
  const seasonNum = event.seasonNumber ?? 'na'
  const key = `${event.title}-${episodeNum}-${seasonNum}`
  const exists = pendingSync.some((e) => {
    const eEpisodeNum = e.overallEpisode ?? e.seasonEpisode ?? 'na'
    const eSeasonNum = e.seasonNumber ?? 'na'
    return `${e.title}-${eEpisodeNum}-${eSeasonNum}` === key
  })

  if (!exists) {
    pendingSync.push(event)
    await chrome.storage.local.set({ [STORAGE_KEYS.PENDING_SYNC]: pendingSync })
  }
}

/**
 * Remove event from pending sync queue
 */
async function removeFromPendingSync(event: EpisodeCompleteEvent['data']): Promise<void> {
  const result = await chrome.storage.local.get(STORAGE_KEYS.PENDING_SYNC)
  const pendingSync: EpisodeCompleteEvent['data'][] = result.pendingSync || []

  const episodeNum = event.overallEpisode ?? event.seasonEpisode ?? 'na'
  const seasonNum = event.seasonNumber ?? 'na'
  const key = `${event.title}-${episodeNum}-${seasonNum}`
  const filtered = pendingSync.filter((e) => {
    const eEpisodeNum = e.overallEpisode ?? e.seasonEpisode ?? 'na'
    const eSeasonNum = e.seasonNumber ?? 'na'
    return `${e.title}-${eEpisodeNum}-${eSeasonNum}` !== key
  })

  await chrome.storage.local.set({ [STORAGE_KEYS.PENDING_SYNC]: filtered })
}

/**
 * Process pending sync queue
 */
async function processPendingSync(): Promise<void> {
  const result = await chrome.storage.local.get(STORAGE_KEYS.PENDING_SYNC)
  const pendingSync: EpisodeCompleteEvent['data'][] = result.pendingSync || []

  if (pendingSync.length === 0) {
    return
  }

  const successful: EpisodeCompleteEvent['data'][] = []

  for (const event of pendingSync) {
    const success = await sendToDesktop(event)
    if (success) {
      successful.push(event)
    }
  }

  // Remove successfully synced events
  if (successful.length > 0) {
    const remaining = pendingSync.filter((e) => {
      const eEpisodeNum = e.overallEpisode ?? e.seasonEpisode ?? 'na'
      const eSeasonNum = e.seasonNumber ?? 'na'
      return !successful.some((s) => {
        const sEpisodeNum = s.overallEpisode ?? s.seasonEpisode ?? 'na'
        const sSeasonNum = s.seasonNumber ?? 'na'
        return `${s.title}-${sEpisodeNum}-${sSeasonNum}` === `${e.title}-${eEpisodeNum}-${eSeasonNum}`
      })
    })
    await chrome.storage.local.set({ [STORAGE_KEYS.PENDING_SYNC]: remaining })
  }
}

/**
 * Normalize title by removing site clutter
 */
function normalizeTitle(title: string): string {
  return title
    .split('|')[0]
    .split('-')[0]
    .replace(/episode.*$/i, '')
    .replace(/ep\s*\d+.*$/i, '')
    .trim()
}

/**
 * Generate a unique key for an episode detection (for deduplication)
 */
function getEpisodeKey(episode: {
  platform: string
  title: string
  overallEpisode: number | null
  seasonEpisode: number | null
}): string {
  const episodeNum = episode.overallEpisode ?? episode.seasonEpisode ?? 'na'
  return `${episode.platform}::${episode.title}::${episodeNum}`
}

/**
 * Handle anime detection messages from content scripts
 */
chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
  // Handle ANIVAULT_ANIME_DETECTED (detection, not completion)
  if (message.type === 'ANIVAULT_ANIME_DETECTED') {
    const detection = message.data as Omit<ExtensionEpisodeEvent, 'watchedSeconds' | 'durationSeconds' | 'progress' | 'completedAt'>

    // Process asynchronously
    ;(async () => {
      try {
        // Save lastDetected
        await chrome.storage.local.set({ lastDetected: detection })
        console.debug('[AniVault] BG: detection stored', detection)

        sendResponse({ ok: true })
      } catch (error) {
        console.error('[AniVault] Error processing anime detection:', error)
        sendResponse({ ok: false, error: String(error) })
      }
    })()

    return true // Keep message channel open for async response
  }

  // Handle ANIVAULT_CLEAR_DETECTION (clear status when not watching)
  if (message.type === 'ANIVAULT_CLEAR_DETECTION') {
    // Process asynchronously
    ;(async () => {
      try {
        // Clear lastDetected
        await chrome.storage.local.set({ lastDetected: null })

        // Notify desktop app to clear Discord presence
        await notifyDesktopClear()

        sendResponse({ ok: true })
      } catch (error) {
        console.error('[AniVault] Error clearing detection:', error)
        sendResponse({ ok: false, error: String(error) })
      }
    })()

    return true // Keep message channel open for async response
  }

  // Handle ANIVAULT_EPISODE_COMPLETED
  if (message.type === 'ANIVAULT_EPISODE_COMPLETED') {
    const event = message.data as ExtensionEpisodeEvent

    // Process asynchronously
    ;(async () => {
      try {
        await handleEpisodeCompleted(event)
        sendResponse({ ok: true })
      } catch (error) {
        console.error('[AniVault] Error processing episode completion:', error)
        sendResponse({ ok: false, error: String(error) })
      }
    })()

    return true // Keep message channel open for async response
  }

  // Legacy handler for ANIME_DETECTED (backward compatibility)
  if (message.type === 'ANIME_DETECTED') {
    const episodeInfo = {
      ...message.data,
      detectedAt: Date.now(),
      timestamp: new Date().toISOString(),
    }

    // Normalize title
    const normalizedTitle = normalizeTitle(episodeInfo.title)
    const normalizedData = {
      ...episodeInfo,
      title: normalizedTitle,
    }

    // Process asynchronously
    ;(async () => {
      try {
        // Save lastDetected
        await chrome.storage.local.set({ lastDetected: normalizedData })

        // Update recentActivity with deduplication
        const result = await chrome.storage.local.get(['recentActivity'])
        const current: typeof normalizedData[] = result.recentActivity || []

        // Generate key for this episode
        const key = getEpisodeKey(normalizedData)

        // Remove existing items with same key
        const filtered = current.filter((entry) => {
          const entryKey = getEpisodeKey(entry)
          return entryKey !== key
        })

        // Add new entry at the top and keep max 10
        const updated = [normalizedData, ...filtered].slice(0, 10)
        await chrome.storage.local.set({ recentActivity: updated })
    
        // Send to desktop (ignore failures)
        fetch('http://localhost:35847/extension-event', {
          method: 'POST',
          body: JSON.stringify(normalizedData),
          headers: { 'Content-Type': 'application/json' },
        }).catch(() => {
          // Silently ignore failures
        })

        sendResponse({ ok: true })
      } catch (error) {
        console.error('[AniVault] Error processing anime detection:', error)
        sendResponse({ ok: false, error: String(error) })
      }
    })()

    return true // Keep message channel open for async response
  }

  // Handle ANIVault_EPISODE_COMPLETE (episode completion)
  if (message.type === 'ANIVault_EPISODE_COMPLETE') {
    const event = message.data

    // Process asynchronously
    ;(async () => {
      try {
        // Store in last watched
        const lastWatchedEntry: LastWatchedEntry = {
          platform: event.platform,
          title: event.title,
          episode: event.overallEpisode ?? event.seasonEpisode ?? null,
          season: event.seasonNumber ?? undefined,
          url: event.url,
          completedAt: event.completedAt,
        }

        await storeLastWatched(lastWatchedEntry)

        // Send to desktop (already handled by handleEpisodeCompleted)
    
    sendResponse({ success: true })
      } catch (error) {
        console.error('[AniVault] Error processing episode completion:', error)
        sendResponse({ success: false, error: String(error) })
  }
    })()
  
  return true // Keep message channel open for async response
  }

  return false
})

/**
 * Periodically try to sync pending events
 */
chrome.alarms.create('syncPendingEvents', { periodInMinutes: 5 })
chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === 'syncPendingEvents') {
    processPendingSync()
  }
})

/**
 * Track tab updates to detect streaming sites
 */
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === 'complete' && tab.url) {
    if (tab.url.includes('crunchyroll.com') || tab.url.includes('netflix.com')) {
      console.log('[AniVault] Streaming site detected:', tab.url)
    }
  }
})

/**
 * Clear detection when tab is closed
 */
chrome.tabs.onRemoved.addListener(async (tabId) => {
  // Check if any tabs with streaming sites are still open
  const tabs = await chrome.tabs.query({})
  const hasStreamingTab = tabs.some((tab) => {
    const url = tab.url || ''
    return (
      url.includes('crunchyroll.com') ||
      url.includes('netflix.com') ||
      url.includes('zoro') ||
      url.includes('animepahe') ||
      url.includes('9anime')
    )
  })

  // If no streaming tabs remain, clear detection
  if (!hasStreamingTab) {
    await chrome.storage.local.set({ lastDetected: null })
  }
})


========================================

=== apps\extension\src\content\adapters.ts ===

import type { EpisodeInfo, Platform } from '../types'

/**
 * Site Adapter interface for modular site detection
 */
export interface SiteAdapter {
  id: Platform
  match: (url: string) => boolean
  detectEpisode: () => EpisodeInfo | null
  findVideoElement: () => HTMLVideoElement | null
}

// Universal findVideoElement helper (normal DOM + shadow DOM)
export function findVideoElement(): HTMLVideoElement | null {
  const direct = document.querySelector('video')
  if (direct) return direct as HTMLVideoElement
  const all = Array.from(document.querySelectorAll('*'))
  for (const el of all) {
    const shadow = (el as HTMLElement).shadowRoot
    if (!shadow) continue
    const v = shadow.querySelector('video')
    if (v) return v as HTMLVideoElement
  }
  return null
}

/**
 * Crunchyroll adapter with improved detection
 */
export const crunchyrollAdapter: SiteAdapter = {
  id: 'crunchyroll',
  match: (url) => /crunchyroll\.com/.test(url),
  detectEpisode: () => {
    try {
      console.log('[AniVault] Crunchyroll detectEpisode running...')
      const url = window.location.href

      // 1. Get show title (the h4 with anime name)
      const showTitleSelectors = [
        'h4.text--gq6o-',
        '[data-testid="content-title"]',
        '[data-testid="hero-title-block-title"]',
        '[data-testid="show-title"]',
      ]

      let showTitle = ''
      for (const sel of showTitleSelectors) {
        const el = document.querySelector(sel)
        const text = el?.textContent?.trim()
        console.log(`[AniVault CR] Checking "${sel}":`, text || 'not found')
        if (text && text.length > 2 && !/^E\d+$/i.test(text)) {
          showTitle = text
          break
        }
      }

      console.log('[AniVault CR] Show title result:', showTitle)

      // Fallback to og:title or document.title
      if (!showTitle) {
        const og = document.querySelector('meta[property="og:title"]')?.getAttribute('content')?.trim() || ''
        let cleaned = og || document.title || ''
        console.log('[AniVault CR] Fallback title:', cleaned)

        cleaned = cleaned
          .replace(/Episode\s+\d+.*$/i, '')
          .replace(/-\s*Watch on Crunchyroll.*/i, '')
          .replace(/-\s*Crunchyroll.*/i, '')
          .replace(/Crunchyroll.*/i, '')
          .trim()

        showTitle = cleaned
        console.log('[AniVault CR] Cleaned fallback:', showTitle)
      }

      // Ignore generic/empty titles
      if (!showTitle || showTitle === 'Crunchyroll' || /Watch Popular Anime/i.test(showTitle)) {
        console.log('[AniVault CR] âŒ Invalid/generic title, returning null')
        return null
      }

      // 2. Get episode number from the episode heading (h1.title)
      // Example: "E2 - The Assassin Takes Care of the Wounded"
      const episodeHeading = document.querySelector('h1.title')?.textContent?.trim() || ''
      console.log('[AniVault CR] Episode heading:', episodeHeading)

      let overallEpisode: number | null = null
      let seasonNumber: number | null = null
      let seasonEpisode: number | null = null

      // Parse episode from heading like "E39 - ..." or "Episode 39 - ..."
      const epMatch = episodeHeading.match(/^E(\d{1,4})\b/i) || episodeHeading.match(/Episode\s+(\d{1,4})/i)
      if (epMatch?.[1]) {
        const n = parseInt(epMatch[1], 10)
        if (!isNaN(n)) {
          overallEpisode = n
          console.log('[AniVault CR] Parsed episode number:', overallEpisode)
        }
      }

      // Also check for season info in context
      const metaTextPieces: string[] = [document.title, episodeHeading]
      document.querySelectorAll('[data-testid*="episode"], [class*="season"]').forEach((el) => {
        const text = el.textContent?.trim()
        if (text) metaTextPieces.push(text)
      })

      const context = metaTextPieces.filter(Boolean).join(' â€¢ ')
      console.log('[AniVault CR] Context for parsing:', context)

      const seasonMatch = context.match(/Season\s+(\d{1,2})/i) || context.match(/\bS(\d{1,2})\b/i)
      if (seasonMatch?.[1]) {
        const s = parseInt(seasonMatch[1], 10)
        if (!isNaN(s)) {
          seasonNumber = s
          console.log('[AniVault CR] Found season:', seasonNumber)
        }
      }

      console.log('[AniVault CR] âœ… Returning detection:', {
        platform: 'crunchyroll',
        title: showTitle,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url
      })

      return {
        platform: 'crunchyroll',
        title: showTitle,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url,
      }
    } catch (error) {
      console.error('[AniVault CR] âŒ Detection error:', error)
      return null
    }
  },
  findVideoElement,
}

/**
 * Netflix adapter with improved detection
 * Prioritizes the video-title UI element structure
 */
export const netflixAdapter: SiteAdapter = {
  id: 'netflix',
  match: (url) => /netflix\.com/.test(url),
  detectEpisode: () => {
    try {
      console.log('[AniVault] Netflix detectEpisode running...')
      const url = window.location.href

      let rawTitle = ''
      let overallEpisode: number | null = null
      let seasonNumber: number | null = null
      let seasonEpisode: number | null = null

      // Priority 1: Try the video-title UI element
      // Structure: <div data-uia="video-title"><h4>TITLE</h4><span>E30</span><span>Episode Name</span></div>
      const videoTitleEl = document.querySelector('[data-uia="video-title"]')
      if (videoTitleEl) {
        const h4 = videoTitleEl.querySelector('h4')
        const spans = videoTitleEl.querySelectorAll('span')
        
        if (h4) {
          rawTitle = h4.textContent?.trim() || ''
          console.log('[AniVault NF] Found title from video-title:', rawTitle)
        }

        // First span usually contains episode number (e.g., "E30")
        if (spans[0]) {
          const episodeText = spans[0].textContent?.trim() || ''
          const eMatch = episodeText.match(/E(\d{1,4})/i)
          if (eMatch?.[1]) {
            overallEpisode = parseInt(eMatch[1], 10)
            console.log('[AniVault NF] Found episode from span:', overallEpisode)
          }
        }
      }

      // Fallback to og:title / document.title if video-title element not found
      if (!rawTitle || !overallEpisode) {
        console.log('[AniVault NF] Falling back to og:title / document.title')
        const og = document.querySelector('meta[property="og:title"]')?.getAttribute('content')?.trim() || ''
        let base = og || document.title || ''
        console.log('[AniVault NF] og:title / document.title:', base)

        const eMatch = base.match(/\bE(\d{1,4})\b/i)
        if (eMatch?.[1] && !overallEpisode) {
          overallEpisode = parseInt(eMatch[1], 10)
          console.log('[AniVault NF] Parsed episode from fallback:', overallEpisode)
        }

        if (!rawTitle) {
          rawTitle = base
            .replace(/-?\s*Netflix.*/i, '')
            .replace(/:\s*E\d{1,4}.*/i, '')
            .replace(/Episode\s+\d+.*/i, '')
            .trim()
          console.log('[AniVault NF] Cleaned title from fallback:', rawTitle)
        }
      }

      // Validate title
      if (!rawTitle || rawTitle.length < 2) {
        console.log('[AniVault NF] âŒ No valid title')
        return null
      }

      // Try to extract season number from title or context
      const titleLower = rawTitle.toLowerCase()
      const seasonMatch = titleLower.match(/season\s+(\d{1,2})/i) || 
                          titleLower.match(/\bs(\d{1,2})\b/i) ||
                          titleLower.match(/part\s+(\d{1,2})/i)
      
      if (seasonMatch?.[1]) {
        seasonNumber = parseInt(seasonMatch[1], 10)
        console.log('[AniVault NF] Detected season from title:', seasonNumber)
      }

      // If we have a season number, assume overallEpisode is actually the season episode
      if (seasonNumber !== null && overallEpisode !== null) {
        seasonEpisode = overallEpisode
        console.log('[AniVault NF] Setting seasonEpisode =', seasonEpisode, 'for Season', seasonNumber)
      }

      console.log('[AniVault NF] âœ… Returning detection:', {
        platform: 'netflix',
        title: rawTitle,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url
      })

      return {
        platform: 'netflix',
        title: rawTitle,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url,
      }
    } catch (error) {
      console.error('[AniVault NF] âŒ Detection error:', error)
      return null
    }
  },
  findVideoElement,
}

/**
 * Zoro / HiAnime / AniWatch / ZoroX / AniWave adapter
 */
export const zoroAdapter: SiteAdapter = {
  id: 'zoro',
  match: (url) => /zoro|aniwatch|hianime|zorox|aniwave|gogoanime/i.test(url),
  detectEpisode: () => {
    try {
      const url = window.location.href
      let rawTitle = document.title || ''
      rawTitle = rawTitle.split('|')[0].split('-')[0].trim()

      const epCandidates: string[] = []
      document
        .querySelectorAll('h1, h2, .ep-title, .active-ep, .current-episode, [class*="episode"]')
        .forEach((el) => {
          const text = el.textContent || ''
          if (/episode/i.test(text) || /ep\s*\d+/i.test(text)) {
            epCandidates.push(text)
          }
        })

      const context = [rawTitle, ...epCandidates, document.title].filter(Boolean).join(' â€¢ ')

      let overallEpisode: number | null = null
      let seasonNumber: number | null = null
      let seasonEpisode: number | null = null

      const epMatch =
        context.match(/Episode\s+(\d{1,4})/i) ||
        context.match(/\bEp\.?\s*(\d{1,4})/i) ||
        context.match(/\bE(\d{1,4})\b/i)

      if (epMatch && epMatch[1]) {
        const e = parseInt(epMatch[1], 10)
        if (!isNaN(e)) overallEpisode = e
      }

      const seasonMatch = context.match(/Season\s+(\d{1,2})/i) || context.match(/\bS(\d{1,2})\b/i)
      if (seasonMatch && seasonMatch[1]) {
        const s = parseInt(seasonMatch[1], 10)
        if (!isNaN(s)) seasonNumber = s
      }

      const seMatch = context.match(/S(\d{1,2})\s*E(\d{1,3})/i)
      if (seMatch) {
        seasonNumber = parseInt(seMatch[1], 10)
        seasonEpisode = parseInt(seMatch[2], 10)
        overallEpisode = null
      }

      if (!rawTitle) return null

      return {
        platform: 'zoro',
        title: rawTitle,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url,
      }
    } catch (error) {
      console.error('[AniVault] Zoro detection error:', error)
      return null
    }
  },
  findVideoElement,
}

/**
 * 9anime and reskins adapter
 */
export const nineAnimeAdapter: SiteAdapter = {
  id: 'nineanime',
  match: (url) => /9anime|aniwave/i.test(url),
  detectEpisode: () => {
    try {
      const url = window.location.href
      let rawTitle = document.title || ''
      rawTitle = rawTitle.split('|')[0].split('-')[0].trim()

      const titleCandidates: string[] = []
      document.querySelectorAll('.ep-title, .title, h1, h2').forEach((el) => {
        const text = el.textContent?.trim()
        if (text) titleCandidates.push(text)
      })

      const context = [rawTitle, ...titleCandidates, document.title].filter(Boolean).join(' â€¢ ')

      let overallEpisode: number | null = null
      let seasonNumber: number | null = null
      let seasonEpisode: number | null = null

      const epMatch =
        context.match(/Episode\s+(\d{1,4})/i) ||
        context.match(/\bEp\.?\s*(\d{1,4})/i) ||
        context.match(/\bE(\d{1,4})\b/i)

      if (epMatch && epMatch[1]) {
        const e = parseInt(epMatch[1], 10)
        if (!isNaN(e)) overallEpisode = e
      }

      const seasonMatch = context.match(/Season\s+(\d{1,2})/i) || context.match(/\bS(\d{1,2})\b/i)
      if (seasonMatch && seasonMatch[1]) {
        const s = parseInt(seasonMatch[1], 10)
        if (!isNaN(s)) seasonNumber = s
      }

      if (!rawTitle) return null

      return {
        platform: 'nineanime',
        title: rawTitle,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url,
      }
    } catch (error) {
      console.error('[AniVault] 9anime detection error:', error)
      return null
    }
  },
  findVideoElement,
}

/**
 * AnimePahe adapter
 */
export const animepaheAdapter: SiteAdapter = {
  id: 'animepahe',
  match: (url) => /animepahe\.(com|ru)/i.test(url),
  detectEpisode: () => {
    try {
      const url = window.location.href

      const ogTitle =
        document.querySelector('meta[property="og:title"]')?.getAttribute('content')?.trim() || ''

      const titleCandidates: string[] = []
      document.querySelectorAll('h1, h2, .title, .anime-title').forEach((el) => {
        const text = el.textContent?.trim()
        if (text) titleCandidates.push(text)
      })

      let rawTitle = ogTitle || titleCandidates[0] || document.title || ''
      rawTitle = rawTitle.split('|')[0].split('-').slice(0, 2).join('-').trim()

      const context = [document.title, ogTitle, ...titleCandidates].filter(Boolean).join(' â€¢ ')

      let overallEpisode: number | null = null
      let seasonNumber: number | null = null
      let seasonEpisode: number | null = null

      const epMatch =
        context.match(/Episode\s+(\d{1,4})/i) ||
        context.match(/\bEp\.?\s*(\d{1,4})/i) ||
        context.match(/\bE(\d{1,4})\b/i)

      if (epMatch && epMatch[1]) {
        const e = parseInt(epMatch[1], 10)
        if (!isNaN(e)) overallEpisode = e
      }

      const seasonMatch = context.match(/Season\s+(\d{1,2})/i) || context.match(/\bS(\d{1,2})\b/i)
      if (seasonMatch && seasonMatch[1]) {
        const s = parseInt(seasonMatch[1], 10)
        if (!isNaN(s)) seasonNumber = s
      }

      if (!rawTitle) return null

      return {
        platform: 'animepahe',
        title: rawTitle,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url,
      }
    } catch (error) {
      console.error('[AniVault] AnimePahe detection error:', error)
      return null
    }
  },
  findVideoElement,
}

/**
 * Generic fallback adapter for unknown anime sites
 */
export const genericAnimeAdapter: SiteAdapter = {
  id: 'generic',
  match: () => true,
  detectEpisode: () => {
    try {
      const url = window.location.href
      let rawTitle = document.title || ''
      rawTitle = rawTitle.split('|')[0].split('-')[0].trim()

      const heading =
        document.querySelector('h1')?.textContent?.trim() ||
        document.querySelector('.title')?.textContent?.trim() ||
        ''

      const context = [document.title, heading, rawTitle].filter(Boolean).join(' â€¢ ')

      let overallEpisode: number | null = null
      let seasonNumber: number | null = null
      let seasonEpisode: number | null = null

      const epMatch =
        context.match(/Episode\s+(\d{1,4})/i) ||
        context.match(/\bEp\.?\s*(\d{1,4})/i) ||
        context.match(/\bE(\d{1,4})\b/i)

      if (epMatch && epMatch[1]) {
        const e = parseInt(epMatch[1], 10)
        if (!isNaN(e)) overallEpisode = e
      }

      const seasonMatch = context.match(/Season\s+(\d{1,2})/i) || context.match(/\bS(\d{1,2})\b/i)
      if (seasonMatch && seasonMatch[1]) {
        const s = parseInt(seasonMatch[1], 10)
        if (!isNaN(s)) seasonNumber = s
      }

      if (!rawTitle && !heading) return null

      const title = rawTitle || heading

      return {
        platform: 'generic',
        title,
        overallEpisode,
        seasonNumber,
        seasonEpisode,
        url,
      }
    } catch (error) {
      console.error('[AniVault] Generic detection error:', error)
      return null
    }
  },
  findVideoElement,
}

/**
 * Array of all adapters in priority order
 */
export const adapters: SiteAdapter[] = [
  crunchyrollAdapter,
  netflixAdapter,
  zoroAdapter,
  nineAnimeAdapter,
  animepaheAdapter,
  genericAnimeAdapter,
]

/**
 * Get the active adapter for a given URL
 */
export function getActiveAdapter(url: string): SiteAdapter {
  const found = adapters.find((adapter) => adapter.match(url))
  return found ?? genericAnimeAdapter
}


========================================

=== apps\extension\src\content\content.ts ===

// Content script for AniVault Extension
import { getActiveAdapter, findVideoElement } from './adapters'
import type { SiteAdapter } from './adapters'
import type { EpisodeInfo, ExtensionEpisodeEvent } from '../types'

console.log('[AniVault] ========== Content script loaded ==========')

let currentTracker: EpisodeTracker | null = null
let lastUrl = location.href
let lastDetectionKey: string | null = null

/**
 * Episode tracker that monitors video playback
 */
class EpisodeTracker {
  private video: HTMLVideoElement
  private detection: EpisodeInfo
  private hasSentComplete = false
  private timeUpdateHandler: (() => void) | null = null
  private endedHandler: (() => void) | null = null

  constructor(video: HTMLVideoElement, detection: EpisodeInfo) {
    this.video = video
    this.detection = detection
    console.log('[AniVault] EpisodeTracker created for:', detection.title, 'Ep', detection.overallEpisode)
  }

  start(): void {
    if (this.timeUpdateHandler || this.endedHandler) {
      console.log('[AniVault] Tracker already started, skipping')
      return
    }

    console.log('[AniVault] Starting tracker...')

    this.timeUpdateHandler = () => {
      const watchedSeconds = this.video.currentTime
      const durationSeconds = this.video.duration || 0
      const progress = durationSeconds > 0 ? watchedSeconds / durationSeconds : 0

      if (!this.hasSentComplete && progress >= 0.8) {
        this.hasSentComplete = true
        console.log('[AniVault] âœ… Progress >= 80%! Sending completion:', {
          title: this.detection.title,
          episode: this.detection.overallEpisode,
          progress: (progress * 100).toFixed(1) + '%',
          watchedSeconds,
          durationSeconds
        })
        this.sendEpisodeCompleted(watchedSeconds, durationSeconds)
      }
    }

    this.endedHandler = () => {
      if (!this.hasSentComplete) {
        const watchedSeconds = this.video.currentTime
        const durationSeconds = this.video.duration || 0
        console.log('[AniVault] âœ… Video ended! Sending completion:', {
          title: this.detection.title,
          episode: this.detection.overallEpisode,
          watchedSeconds,
          durationSeconds
        })
        this.sendEpisodeCompleted(watchedSeconds, durationSeconds)
        this.hasSentComplete = true
      }
    }

    this.video.addEventListener('timeupdate', this.timeUpdateHandler, { passive: true })
    this.video.addEventListener('ended', this.endedHandler, { passive: true })
    console.log('[AniVault] Tracker started, listeners attached')
  }

  stop(): void {
    console.log('[AniVault] Stopping tracker...')
    if (this.timeUpdateHandler) {
      this.video.removeEventListener('timeupdate', this.timeUpdateHandler)
      this.timeUpdateHandler = null
    }
    if (this.endedHandler) {
      this.video.removeEventListener('ended', this.endedHandler)
      this.endedHandler = null
    }
  }

  private sendEpisodeCompleted(watchedSeconds: number, durationSeconds: number): void {
    const event: ExtensionEpisodeEvent = {
      ...this.detection,
      watchedSeconds,
      durationSeconds,
      progress: durationSeconds > 0 ? watchedSeconds / durationSeconds : 0,
      completedAt: new Date().toISOString(),
    }

    console.log('[AniVault] ğŸ“¤ Sending EPISODE_COMPLETED to background:', event)

    chrome.runtime.sendMessage({
      type: 'ANIVAULT_EPISODE_COMPLETED',
      data: event,
    }).catch((error) => {
      console.error('[AniVault] âŒ Failed to send completion event:', error)
    })
  }

  updateDetection(detection: EpisodeInfo): void {
    const currentKey = `${this.detection.title}-${this.detection.overallEpisode ?? this.detection.seasonEpisode ?? 'na'}`
    const newKey = `${detection.title}-${detection.overallEpisode ?? detection.seasonEpisode ?? 'na'}`
    
    if (currentKey !== newKey) {
      console.log('[AniVault] Episode changed, resetting tracker:', currentKey, 'â†’', newKey)
      this.stop()
      this.detection = detection
      this.hasSentComplete = false
      this.start()
      }
    }
  }

/**
 * Main detection function - runs periodically
 */
async function runDetection(): Promise<void> {
  try {
    const isTopFrame = window.self === window.top
    console.log('[AniVault] ğŸ” Running detection on:', window.location.href, isTopFrame ? '(main frame)' : '(iframe)')

    const adapter = getActiveAdapter(window.location.href)
    console.log('[AniVault] Adapter selected:', adapter.id)

    const detection = adapter.detectEpisode()
    console.log('[AniVault] Detection result:', detection)

    // Main frame: detect and store
    if (isTopFrame && detection) {
      // Generate detection key for deduplication
      const detectionKey = `${detection.title}-${detection.overallEpisode ?? detection.seasonEpisode ?? 'na'}`
      
      // Store detection in chrome.storage for iframe to use
      await chrome.storage.local.set({ currentDetection: detection })
      console.log('[AniVault] ğŸ’¾ Stored detection for iframe:', detection)
      
      // Always send detection to background (for popup status)
      console.log('[AniVault] ğŸ“¤ Sending ANIME_DETECTED to background:', detection)
      chrome.runtime
        .sendMessage({
          type: 'ANIVAULT_ANIME_DETECTED',
          data: detection,
        })
        .catch((error) => {
          console.error('[AniVault] âŒ Failed to send detection message:', error)
        })

      // If this is a different episode than last time, stop old tracker
      if (lastDetectionKey && lastDetectionKey !== detectionKey) {
        console.log('[AniVault] Episode changed, stopping old tracker')
        if (currentTracker) {
          currentTracker.stop()
          currentTracker = null
        }
      }
      lastDetectionKey = detectionKey
}

    // Both frames: try to find video and start tracker
    const video = findVideoElement()
    console.log('[AniVault] Video element:', video ? 'found' : 'not found', video ? `(duration: ${video.duration})` : '')

    if (video) {
      // Check if video has duration
      let hasDuration = false
      try {
        hasDuration = !!(video.duration && video.duration > 0 && !isNaN(video.duration))
      } catch {
        hasDuration = false
      }

      if (hasDuration) {
        // Get detection - always prefer storage for iframes or if detection is invalid
        let trackingDetection = detection
        
        // If we're in an iframe OR detection is invalid (like "Vilos"), read from storage
        const isInvalidDetection = !detection || 
          !detection.overallEpisode || 
          detection.title === 'Vilos' ||
          detection.title.length < 3
        
        if (!isTopFrame || isInvalidDetection) {
          console.log('[AniVault] Reading detection from storage (iframe or invalid detection)...')
          const stored = await chrome.storage.local.get('currentDetection')
          trackingDetection = stored.currentDetection
          console.log('[AniVault] Retrieved detection from storage:', trackingDetection)
        }

        if (trackingDetection && trackingDetection.overallEpisode) {
          // Create or update tracker
          if (!currentTracker) {
            console.log('[AniVault] âœ… Creating new tracker with:', trackingDetection.title, 'Ep', trackingDetection.overallEpisode)
            currentTracker = new EpisodeTracker(video, trackingDetection)
            currentTracker.start()
          } else {
            console.log('[AniVault] âœ… Updating existing tracker with:', trackingDetection.title, 'Ep', trackingDetection.overallEpisode)
            currentTracker.updateDetection(trackingDetection)
          }
        } else {
          console.log('[AniVault] âš ï¸ No valid detection available to start tracker')
        }
      } else {
        console.log('[AniVault] Video found but duration not ready yet, will retry...')
      }
    } else {
      if (!isTopFrame) {
        console.log('[AniVault] (iframe) No video element found yet, will retry...')
}
    }
  } catch (error) {
    console.error('[AniVault] âŒ Error in runDetection:', error)
  }
}

/**
 * Clear detection (only on navigation away or tab close)
 */
function clearDetection(): void {
  console.log('[AniVault] ğŸ§¹ Clearing detection')
  if (currentTracker) {
    currentTracker.stop()
    currentTracker = null
  }
  lastDetectionKey = null
  chrome.runtime
    .sendMessage({ type: 'ANIVAULT_CLEAR_DETECTION' })
    .catch(() => {})
}

// Run detection on page load
console.log('[AniVault] Initial detection run...')
setTimeout(() => runDetection(), 500)

// Re-run detection every 2 seconds to handle dynamic content
setInterval(() => {
  const currentUrl = location.href
  
  // If URL changed, clear old detection and run new
  if (currentUrl !== lastUrl) {
    console.log('[AniVault] URL changed:', lastUrl, 'â†’', currentUrl)
    clearDetection()
    lastUrl = currentUrl
    setTimeout(() => runDetection(), 500)
  } else {
    // Same URL, just re-run detection (will handle video loading, etc.)
    runDetection()
  }
}, 2000)

// Clear detection only when tab is closed or navigated away
window.addEventListener('beforeunload', () => {
  console.log('[AniVault] Page unloading, clearing detection')
  clearDetection()
})

console.log('[AniVault] ========== Setup complete ==========')


========================================

=== apps\extension\src\content\video-tracker.ts ===

import type { EpisodeInfo, EpisodeCompleteEvent, PlaybackState } from '../types'

/**
 * Track video playback and send completion events
 */
export class VideoTracker {
  private video: HTMLVideoElement | null = null
  private detection: EpisodeInfo | null = null
  private state: PlaybackState = {
    lastProgress: 0,
    hasSentComplete: false,
    lastEpisodeKey: null,
  }
  private timeUpdateHandler: (() => void) | null = null
  private endedHandler: (() => void) | null = null
  private isTracking = false

  constructor(detection: EpisodeInfo) {
    this.detection = detection
    this.state.lastEpisodeKey = this.getEpisodeKey(detection)
  }

  private getEpisodeKey(detection: EpisodeInfo): string {
    const episode = detection.overallEpisode ?? detection.seasonEpisode ?? 'null'
    const season = detection.seasonNumber ?? 'null'
    return `${detection.title}-${episode}-${season}`
  }

  /**
   * Start tracking video playback
   */
  public start(): void {
    if (this.isTracking) {
      return
    }

    // Find video element
    this.video = document.querySelector('video')

    if (!this.video) {
      // Video might not be loaded yet, try again after a delay
      setTimeout(() => {
        this.video = document.querySelector('video')
        if (this.video) {
          this.attachListeners()
        }
      }, 1000)
      return
    }

    this.attachListeners()
  }

  /**
   * Stop tracking and cleanup
   */
  public stop(): void {
    if (!this.video || !this.isTracking) {
      return
    }

    if (this.timeUpdateHandler) {
      this.video.removeEventListener('timeupdate', this.timeUpdateHandler)
    }

    if (this.endedHandler) {
      this.video.removeEventListener('ended', this.endedHandler)
    }

    this.isTracking = false
    this.video = null
  }

  private attachListeners(): void {
    if (!this.video || !this.detection) {
      return
    }

    this.isTracking = true

    // Time update handler - check progress
    this.timeUpdateHandler = () => {
      if (!this.video || !this.detection) {
        return
      }

      const watchedSeconds = this.video.currentTime
      const durationSeconds = this.video.duration || 0

      if (durationSeconds === 0) {
        return
      }

      const progress = watchedSeconds / durationSeconds
      this.state.lastProgress = progress

      // Send completion event if >= 80% watched and not already sent
      if (progress >= 0.8 && !this.state.hasSentComplete) {
        this.sendCompletionEvent(watchedSeconds, durationSeconds, progress)
      }
    }

    // Ended handler - video finished
    this.endedHandler = () => {
      if (!this.video || !this.detection || this.state.hasSentComplete) {
        return
      }

      const watchedSeconds = this.video.currentTime
      const durationSeconds = this.video.duration || 0
      const progress = durationSeconds > 0 ? watchedSeconds / durationSeconds : 1

      this.sendCompletionEvent(watchedSeconds, durationSeconds, progress)
    }

    this.video.addEventListener('timeupdate', this.timeUpdateHandler, { passive: true })
    this.video.addEventListener('ended', this.endedHandler, { passive: true })
  }

  private sendCompletionEvent(
    watchedSeconds: number,
    durationSeconds: number,
    progress: number
  ): void {
    if (!this.detection || this.state.hasSentComplete) {
      return
    }

    // Mark as sent to prevent duplicates
    this.state.hasSentComplete = true

    // Create completion event with proper structure
    const event: EpisodeCompleteEvent = {
      type: 'ANIVault_EPISODE_COMPLETE',
      data: {
        platform: this.detection.platform,
        title: this.detection.title,
        overallEpisode: this.detection.overallEpisode,
        seasonNumber: this.detection.seasonNumber,
        seasonEpisode: this.detection.seasonEpisode,
        url: this.detection.url,
        watchedSeconds,
        durationSeconds,
        progress,
        completedAt: new Date().toISOString(),
      },
    }

    // Send to background script
    chrome.runtime.sendMessage(event).catch((error) => {
      console.error('[AniVault] Failed to send completion event:', error)
    })
  }

  /**
   * Update detection (e.g., when navigating to a new episode)
   */
  public updateDetection(detection: EpisodeInfo): void {
    const newKey = this.getEpisodeKey(detection)

    // If it's a different episode, reset state
    if (newKey !== this.state.lastEpisodeKey) {
      this.stop()
      this.detection = detection
      this.state = {
        lastProgress: 0,
        hasSentComplete: false,
        lastEpisodeKey: newKey,
      }
      this.start()
    }
  }
}



========================================

=== apps\extension\src\popup\App.tsx ===

import { useState, useEffect } from 'react'
import type { ExtensionSettings, Platform, EpisodeInfo } from '../types'

interface DetectedAnime extends EpisodeInfo {
  detectedAt: number
  timestamp: string
}

interface PopupState {
  settings: ExtensionSettings | null
  lastDetected: DetectedAnime | null
  recentActivity: DetectedAnime[]
  currentTab: { url?: string; title?: string } | null
  isSupportedSite: boolean
  isLoading: boolean
}

function App() {
  const [state, setState] = useState<PopupState>({
    settings: null,
    lastDetected: null,
    recentActivity: [],
    currentTab: null,
    isSupportedSite: false,
    isLoading: true,
  })

  // Load data from storage
  useEffect(() => {
    const loadData = async () => {
      try {
        // Get current tab
        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true })
        const currentTab = tab ? { url: tab.url, title: tab.title } : null
        const isSupportedSite =
          currentTab?.url?.includes('crunchyroll.com') ||
          currentTab?.url?.includes('netflix.com') ||
          /zoro|aniwatch|hianime|zorox|9anime|aniwave|gogoanime|animepahe/i.test(currentTab?.url || '') ||
          false

        // Get settings, lastDetected, and recentActivity
        const storage = await chrome.storage.local.get([
          'settings',
          'lastDetected',
          'recentActivity',
        ])
        const settings: ExtensionSettings = storage.settings || {
          autoTrack: true,
          lastSeenVersion: '0.1.0',
        }
        const lastDetected: DetectedAnime | null = storage.lastDetected || null
        const recentActivity: DetectedAnime[] = storage.recentActivity || []

        setState({
          settings,
          lastDetected,
          recentActivity,
          currentTab,
          isSupportedSite,
          isLoading: false,
        })
      } catch (error) {
        console.error('[AniVault] Error loading popup data:', error)
        setState((prev) => ({ ...prev, isLoading: false }))
      }
    }

    loadData()

    // Listen for storage changes
    const handleStorageChange = (changes: {
      [key: string]: chrome.storage.StorageChange
    }) => {
      if (changes.lastDetected) {
        const lastDetected = changes.lastDetected.newValue as DetectedAnime | null
        setState((prev) => ({ ...prev, lastDetected }))
      }
      if (changes.recentActivity) {
        const recentActivity = (changes.recentActivity.newValue as DetectedAnime[]) || []
        setState((prev) => ({ ...prev, recentActivity }))
      }
      if (changes.settings) {
        const settings = changes.settings.newValue as ExtensionSettings
        setState((prev) => ({ ...prev, settings }))
      }
    }

    chrome.storage.onChanged.addListener(handleStorageChange)

    return () => {
      chrome.storage.onChanged.removeListener(handleStorageChange)
    }
  }, [])

  const toggleAutoTrack = async () => {
    if (!state.settings) return

    const newSettings: ExtensionSettings = {
      ...state.settings,
      autoTrack: !state.settings.autoTrack,
    }

    await chrome.storage.local.set({ settings: newSettings })
    setState((prev) => ({ ...prev, settings: newSettings }))
  }

  const formatTimeAgo = (timestamp: number | string): string => {
    const date = typeof timestamp === 'number' ? new Date(timestamp) : new Date(timestamp)
    const now = new Date()
    const diffMs = now.getTime() - date.getTime()
    const diffMins = Math.floor(diffMs / 60000)
    const diffHours = Math.floor(diffMs / 3600000)
    const diffDays = Math.floor(diffMs / 86400000)

    if (diffMins < 1) return 'just now'
    if (diffMins < 60) return `${diffMins} min ago`
    if (diffHours < 24) return `${diffHours} hr ago`
    if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`
    return date.toLocaleDateString()
  }

  const formatStatus = (episode: DetectedAnime | null): string => {
    if (!episode) return 'No anime detected on this tab'

    const parts: string[] = [episode.title]

    if (episode.overallEpisode != null) {
      parts.push(`Episode ${episode.overallEpisode}`)
    } else if (episode.seasonNumber != null && episode.seasonEpisode != null) {
      parts.push(`Season ${episode.seasonNumber} Â· Ep ${episode.seasonEpisode}`)
    }

    return parts.join(' â€” ')
  }

  const formatEpisodeInfo = (entry: DetectedAnime): string => {
    if (entry.overallEpisode != null) {
      return `Episode ${entry.overallEpisode}`
    } else if (entry.seasonNumber != null && entry.seasonEpisode != null) {
      return `Season ${entry.seasonNumber} Â· Ep ${entry.seasonEpisode}`
    }
    return 'Episode unknown'
  }

  const getPlatformName = (platform: Platform): string => {
    switch (platform) {
      case 'crunchyroll':
        return 'Crunchyroll'
      case 'netflix':
        return 'Netflix'
      case 'zoro':
        return 'Zoro/AniWatch'
      case 'nineanime':
        return '9anime'
      case 'animepahe':
        return 'AnimePahe'
      case 'generic':
        return 'anime site'
      default:
        return platform
    }
  }

  const getPlatformIcon = (platform: string): string => {
    switch (platform) {
      case 'crunchyroll':
        return 'ğŸŒ'
      case 'netflix':
        return 'ğŸ¬'
      case 'zoro':
        return 'âš”ï¸'
      case 'nineanime':
        return '9ï¸âƒ£'
      case 'animepahe':
        return 'ğŸ“º'
      case 'generic':
        return 'ğŸ“º'
      default:
        return 'ğŸ“º'
    }
  }

  if (state.isLoading) {
    return (
      <div className="w-[380px] min-h-[400px] bg-gradient-to-br from-slate-950 via-purple-950/20 to-slate-950 p-6 flex items-center justify-center">
        <div className="text-gray-400 text-sm">Loading...</div>
      </div>
    )
  }

  return (
    <div className="w-[380px] min-h-[400px] bg-gradient-to-br from-slate-950 via-purple-950/20 to-slate-950 text-white">
      {/* Header */}
      <div className="relative p-6 bg-gradient-to-r from-purple-600/20 to-pink-600/20 border-b border-white/10">
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
            <span className="text-white font-bold text-sm">AV</span>
          </div>
          <div>
            <h1 className="text-lg font-display font-bold">AniVault Extension</h1>
            <p className="text-xs text-gray-400">Auto-track your anime</p>
          </div>
        </div>
      </div>

      {/* Status Section */}
      <div className="p-6 space-y-4">
        <div className="glass-card p-4 space-y-3">
          <div className="flex items-center justify-between">
            <h2 className="text-sm font-semibold text-gray-300">Status</h2>
            <div
              className={`w-2 h-2 rounded-full ${
                state.lastDetected ? 'bg-green-400 animate-pulse' : 'bg-gray-500'
              }`}
            />
          </div>
          <div className="text-sm text-gray-400">
            {state.lastDetected ? (
              <div>
                <div className="text-white font-medium mb-1">
                  Watching on {getPlatformName(state.lastDetected.platform)}
                </div>
                <div className="text-xs text-white font-semibold">
                  {formatStatus(state.lastDetected)}
                </div>
                <div className="text-xs mt-1">
                  {state.settings?.autoTrack
                    ? 'Auto-tracking is active'
                    : 'Auto-tracking is disabled'}
                </div>
              </div>
            ) : (
              <div>
                <div className="text-gray-500">No anime detected</div>
                <div className="text-xs mt-1">
                  Visit a supported anime streaming site to start tracking
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Settings Toggle */}
        <div className="glass-card p-4">
          <div className="flex items-center justify-between">
            <div>
              <div className="text-sm font-medium text-white">Auto-track streaming sites</div>
              <div className="text-xs text-gray-400 mt-0.5">
                Automatically detect and track episodes
              </div>
            </div>
            <button
              onClick={toggleAutoTrack}
              className={`relative w-12 h-6 rounded-full transition-colors ${
                state.settings?.autoTrack ? 'bg-purple-600' : 'bg-gray-600'
              }`}
            >
              <div
                className={`absolute top-0.5 left-0.5 w-5 h-5 rounded-full bg-white transition-transform ${
                  state.settings?.autoTrack ? 'translate-x-6' : 'translate-x-0'
                }`}
              />
            </button>
          </div>
        </div>

        {/* Recent Activity */}
        <div className="glass-card p-4 space-y-3">
          <h2 className="text-sm font-semibold text-gray-300">Recent Activity</h2>
          {state.recentActivity.length === 0 ? (
            <div className="text-sm text-gray-500 text-center py-4">
              No activity yet
            </div>
          ) : (
            <div className="space-y-2 max-h-[200px] overflow-y-auto">
              {state.recentActivity.map((entry, index) => (
                <div
                  key={`${entry.title}-${entry.overallEpisode ?? entry.seasonEpisode}-${entry.detectedAt}-${index}`}
                  className="flex flex-col gap-0.5 p-2 rounded-lg hover:bg-white/5 transition-colors"
                >
                  <div className="flex justify-between items-center">
                    <span className="text-xs font-medium text-white truncate flex-1">
                      {entry.title}
                    </span>
                    <span className="text-[10px] uppercase text-gray-500 ml-2 shrink-0">
                      {entry.platform}
                    </span>
                  </div>
                  <div className="flex justify-between items-center text-[11px] text-gray-400">
                    <span>{formatEpisodeInfo(entry)}</span>
                    <span>{formatTimeAgo(entry.detectedAt)}</span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Footer Link */}
        <div className="text-center pt-2">
          <a
            href="#"
            onClick={(e) => {
              e.preventDefault()
              chrome.tabs.create({ url: 'https://anivault.app' })
            }}
            className="text-xs text-purple-400 hover:text-purple-300 transition-colors"
          >
            Open AniVault Desktop to see full stats & library â†’
          </a>
        </div>
      </div>
    </div>
  )
}

export default App


========================================

=== apps\extension\src\popup\index.css ===

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-slate-950 text-white;
    width: 380px;
    min-height: 400px;
    margin: 0;
    padding: 0;
    font-family: 'Inter', system-ui, sans-serif;
  }
}

@layer components {
  .glass-card {
    @apply bg-white/5 backdrop-blur-xl border border-white/10 rounded-xl;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
  }
}



========================================

=== apps\extension\src\popup\index.html ===

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AniVault</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>



========================================

=== apps\extension\src\popup\main.tsx ===

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)



========================================

=== apps\extension\src\popup\vite-env.d.ts ===

/// <reference types="vite/client" />



========================================

=== apps\extension\src\types.ts ===

// Extension-specific types

export type Platform = 'crunchyroll' | 'netflix' | 'zoro' | 'nineanime' | 'animepahe' | 'generic'

export interface EpisodeInfo {
  platform: Platform
  title: string // e.g. "SPYÃ—FAMILY Season 2"
  overallEpisode: number | null // e.g. 38 (if known)
  seasonNumber: number | null // e.g. 2 (if known)
  seasonEpisode: number | null // e.g. 23 (if known)
  url: string
}

// Legacy type for backward compatibility
export interface EpisodeDetection extends EpisodeInfo {
  episode: number | null // Maps to overallEpisode or seasonEpisode
  season?: number | null // Maps to seasonNumber
}

export interface ExtensionEpisodeEvent {
  platform: Platform
  title: string // e.g. "SPYÃ—FAMILY Season 2"
  overallEpisode: number | null // e.g. 38 (if known)
  seasonNumber: number | null // e.g. 2 (if known)
  seasonEpisode: number | null // e.g. 23 (if known)
  url: string
  watchedSeconds: number
  durationSeconds: number
  progress: number // 0-1
  completedAt: string // ISO timestamp
}

export interface EpisodeCompleteEvent {
  type: 'ANIVault_EPISODE_COMPLETE'
  data: ExtensionEpisodeEvent
}

export interface LastWatchedEntry {
  platform: Platform
  title: string
  episode: number | null
  season?: number | null
  url: string
  completedAt: string
}

export interface ExtensionSettings {
  autoTrack: boolean
  lastSeenVersion: string
}

export interface ExtensionStorage {
  settings: ExtensionSettings
  lastWatched: LastWatchedEntry[]
  pendingSync?: EpisodeCompleteEvent['data'][]
}

export interface PlaybackState {
  lastProgress: number
  hasSentComplete: boolean
  lastEpisodeKey: string | null // "title-episode-season" for deduplication
}

// Desktop app communication
export const DESKTOP_APP_PORT = 35847
export const DESKTOP_APP_ENDPOINT = `/extension-event`
export const DESKTOP_APP_URL = `http://127.0.0.1:${DESKTOP_APP_PORT}${DESKTOP_APP_ENDPOINT}`
export const DESKTOP_APP_CLEAR_URL = `http://127.0.0.1:${DESKTOP_APP_PORT}${DESKTOP_APP_ENDPOINT}/clear`



========================================

=== apps\extension\tailwind.config.js ===

import baseConfig from '@anivault/ui/tailwind'

/** @type {import('tailwindcss').Config} */
export default {
  ...baseConfig,
  content: [
    './src/**/*.{js,ts,jsx,tsx}',
    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}',
  ],
}



========================================

=== apps\extension\tsconfig.json ===

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "types": ["chrome", "vite/client"]
  },
  "include": ["src/**/*", "manifest.json"],
  "exclude": ["node_modules", "dist"]
}



========================================

=== apps\extension\vite.config.ts ===

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { crx } from '@crxjs/vite-plugin'
import manifest from './manifest.json'
import path from 'path'
import tailwindcss from 'tailwindcss'
import autoprefixer from 'autoprefixer'

export default defineConfig({
  plugins: [
    react(),
    crx({ manifest }),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  css: {
    postcss: {
      plugins: [
        tailwindcss,
        autoprefixer,
      ],
    },
  },
})



========================================

=== apps\web\.astro\settings.json ===

{
	"_variables": {
		"lastUpdateCheck": 1765385107052
	}
}

========================================

=== apps\web\.astro\types.d.ts ===

/// <reference types="astro/client" />


========================================

=== apps\web\astro.config.mjs ===

import { defineConfig } from 'astro/config'
import react from '@astrojs/react'
import tailwind from '@astrojs/tailwind'

// https://astro.build/config
export default defineConfig({
  integrations: [
    react(),
    tailwind({
      applyBaseStyles: false,
    }),
  ],
})



========================================

=== apps\web\package.json ===

{
  "name": "web",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "astro dev",
    "start": "astro dev",
    "build": "astro build",
    "preview": "astro preview",
    "astro": "astro"
  },
  "dependencies": {
    "@anivault/shared": "workspace:*",
    "@anivault/ui": "workspace:*",
    "@astrojs/react": "^3.2.1",
    "@astrojs/tailwind": "^5.1.0",
    "astro": "^4.0.7",
    "framer-motion": "^10.16.16",
    "lucide-react": "^0.303.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "typescript": "^5.3.3"
  }
}



========================================

=== apps\web\public\favicon.svg ===

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <rect width="100" height="100" fill="#050505"/>
  <text x="50" y="70" font-size="60" font-weight="bold" fill="#8b5cf6" text-anchor="middle">A</text>
</svg>



========================================

=== apps\web\src\components\Hero.tsx ===

import { Download, Sparkles } from 'lucide-react'
import { Button } from '@anivault/ui'

export default function Hero() {
  return (
    <section className="relative min-h-screen flex items-center justify-center overflow-hidden">
      {/* Animated Background */}
      <div className="absolute inset-0 bg-gradient-to-br from-violet-900/20 via-transparent to-blue-900/20" />
      <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,rgba(139,92,246,0.1),transparent_50%)]" />
      
      {/* Glassmorphism Overlay */}
      <div className="absolute inset-0 backdrop-blur-3xl" />
      
      {/* Content */}
      <div className="relative z-10 max-w-5xl mx-auto px-6 text-center">
        <div className="mb-8">
          <h1 className="text-7xl md:text-8xl font-bold mb-6 bg-gradient-to-r from-violet-400 via-blue-400 to-violet-600 bg-clip-text text-transparent animate-glow">
            AniVault
          </h1>
          <p className="text-2xl md:text-3xl text-gray-300 mb-4">
            The Ultimate Anime Ecosystem
          </p>
          <p className="text-lg text-gray-400 max-w-2xl mx-auto mb-12">
            Track, discover, and sync your anime across desktop, browser, and streaming platforms.
            Built for the modern anime enthusiast.
          </p>
        </div>

        {/* CTA Buttons */}
        <div className="flex flex-col sm:flex-row gap-4 justify-center items-center mb-16">
          <a
            href="#download"
            className="group relative inline-flex items-center gap-2 px-8 py-4 bg-gradient-to-r from-violet-500 to-blue-500 rounded-lg font-semibold text-white hover:from-violet-600 hover:to-blue-600 transition-all duration-300 shadow-lg shadow-violet-500/50 hover:shadow-violet-500/80 hover:scale-105"
          >
            <Download size={20} className="group-hover:translate-y-1 transition-transform" />
            Download for Windows
          </a>
          <a
            href="#features"
            className="px-8 py-4 border border-white/20 rounded-lg font-semibold text-white hover:bg-white/5 hover:border-white/40 transition-all duration-300 backdrop-blur-sm"
          >
            Learn More
          </a>
        </div>

        {/* Features Grid */}
        <div className="grid md:grid-cols-3 gap-6 mt-20">
          <div className="p-6 rounded-xl bg-black/20 backdrop-blur-xl border border-white/10 hover:border-violet-500/50 transition-all">
            <div className="w-12 h-12 rounded-lg bg-violet-500/20 flex items-center justify-center mb-4">
              <Sparkles className="text-violet-400" size={24} />
            </div>
            <h3 className="text-xl font-semibold mb-2">Desktop App</h3>
            <p className="text-gray-400 text-sm">
              Netflix-style media center with automatic tracking from local players
            </p>
          </div>
          
          <div className="p-6 rounded-xl bg-black/20 backdrop-blur-xl border border-white/10 hover:border-violet-500/50 transition-all">
            <div className="w-12 h-12 rounded-lg bg-blue-500/20 flex items-center justify-center mb-4">
              <Sparkles className="text-blue-400" size={24} />
            </div>
            <h3 className="text-xl font-semibold mb-2">Browser Extension</h3>
            <p className="text-gray-400 text-sm">
              Seamlessly track anime on Crunchyroll, Netflix, and more
            </p>
          </div>
          
          <div className="p-6 rounded-xl bg-black/20 backdrop-blur-xl border border-white/10 hover:border-violet-500/50 transition-all">
            <div className="w-12 h-12 rounded-lg bg-violet-500/20 flex items-center justify-center mb-4">
              <Sparkles className="text-violet-400" size={24} />
            </div>
            <h3 className="text-xl font-semibold mb-2">Sync Everywhere</h3>
            <p className="text-gray-400 text-sm">
              Your progress syncs across all devices in real-time
            </p>
          </div>
        </div>
      </div>
    </section>
  )
}



========================================

=== apps\web\src\env.d.ts ===

/// <reference path="../.astro/types.d.ts" />

========================================

=== apps\web\src\layouts\Layout.astro ===

---
import '../styles/global.css'

interface Props {
  title: string
}

const { title } = Astro.props
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="AniVault - The Ultimate Anime Ecosystem" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body class="bg-[#050505] text-white antialiased">
    <slot />
  </body>
</html>

<style is:global>
  html {
    font-family: system-ui, sans-serif;
  }
  
  @keyframes glow {
    0%, 100% {
      filter: drop-shadow(0 0 10px rgba(139, 92, 246, 0.5));
    }
    50% {
      filter: drop-shadow(0 0 20px rgba(139, 92, 246, 0.8));
    }
  }
  
  .animate-glow {
    animation: glow 3s ease-in-out infinite;
  }
</style>



========================================

=== apps\web\src\pages\index.astro ===

---
import Layout from '../layouts/Layout.astro'
import Hero from '../components/Hero'
---

<Layout title="AniVault - The Ultimate Anime Ecosystem">
  <Hero client:load />
</Layout>



========================================

=== apps\web\src\styles\global.css ===

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}



========================================

=== apps\web\tailwind.config.mjs ===

import baseConfig from '@anivault/ui/tailwind'

/** @type {import('tailwindcss').Config} */
export default {
  ...baseConfig,
  content: [
    './src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}',
    '../../packages/ui/src/**/*.{js,ts,jsx,tsx}',
  ],
}



========================================

=== apps\web\tsconfig.json ===

{
  "extends": "astro/tsconfigs/strict",
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}



========================================

=== apps\website\.gitignore ===

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts



========================================

=== apps\website\app\globals.css ===

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Space+Grotesk:wght@400;500;600;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 255, 255, 255;
  --background-start-rgb: 5, 5, 5;
  --background-end-rgb: 10, 10, 15;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html {
  scroll-behavior: smooth;
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-start-rgb));
  font-family: 'Inter', system-ui, sans-serif;
  overflow-x: hidden;
}

/* Noise overlay */
.noise-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  opacity: 0.03;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  z-index: 1;
}

/* Glass card base */
@layer components {
  .glass-card {
    @apply bg-white/5 backdrop-blur-xl border border-white/10 rounded-2xl;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
  }

  .glass-card-hover {
    @apply transition-all duration-300 hover:bg-white/10 hover:border-white/20 hover:scale-105;
    box-shadow: 0 8px 32px 0 rgba(168, 85, 247, 0.2);
  }
}



========================================

=== apps\website\app\layout.tsx ===

import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'AniVault â€” Automatic Anime Tracker & Media Center',
  description:
    'AniVault automatically tracks your anime, syncs with AniList, shows beautiful stats, and can even organize your local library. Free tier + Pro features for power users.',
  openGraph: {
    title: 'AniVault â€” Automatic Anime Tracker & Media Center',
    description:
      'AniVault automatically tracks your anime, syncs with AniList, shows beautiful stats, and can even organize your local library.',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'AniVault â€” Automatic Anime Tracker & Media Center',
    description:
      'AniVault automatically tracks your anime, syncs with AniList, shows beautiful stats, and can even organize your local library.',
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className="dark">
      <body className="antialiased">
        <div className="noise-overlay" />
        <div className="fixed inset-0 -z-10">
          {/* Aurora gradient backgrounds */}
          <div className="absolute inset-0 bg-gradient-to-br from-slate-950 via-purple-950/20 to-slate-950" />
          <div className="absolute top-0 left-1/4 w-96 h-96 bg-purple-500/20 rounded-full blur-3xl opacity-40 animate-float" />
          <div className="absolute top-1/4 right-1/4 w-96 h-96 bg-pink-500/20 rounded-full blur-3xl opacity-40 animate-float" style={{ animationDelay: '2s' }} />
          <div className="absolute bottom-1/4 left-1/3 w-96 h-96 bg-blue-500/20 rounded-full blur-3xl opacity-40 animate-float" style={{ animationDelay: '4s' }} />
        </div>
        {children}
      </body>
    </html>
  )
}



========================================

=== apps\website\app\page.tsx ===

import NavBar from '@/components/NavBar'
import Hero from '@/components/Hero'
import HowItWorks from '@/components/HowItWorks'
import FeatureGrid from '@/components/FeatureGrid'
import Pricing from '@/components/Pricing'
import Screenshots from '@/components/Screenshots'
import FAQ from '@/components/FAQ'
import Footer from '@/components/Footer'

export default function Home() {
  return (
    <main className="relative z-10">
      <NavBar />
      <Hero />
      <HowItWorks />
      <FeatureGrid />
      <Pricing />
      <Screenshots />
      <FAQ />
      <Footer />
    </main>
  )
}



========================================

=== apps\website\components\FAQ.tsx ===

'use client'

import { motion } from 'framer-motion'
import { useState } from 'react'
import { ChevronDown } from 'lucide-react'
import GlowCard from './GlowCard'

const faqs = [
  {
    question: 'Is AniVault free?',
    answer:
      'AniVault has a generous free tier with auto-tracking, library, and basic stats. AniVault Pro adds Organizer, advanced stats, Discord Presence Pro+, mood-based recommendations, and more.',
  },
  {
    question: 'Do I need an AniList account?',
    answer:
      'No. You can use AniVault in Guest mode without any account. AniList is only required if you want to sync your online list.',
  },
  {
    question: 'Does AniVault work with streaming sites?',
    answer:
      'Yes. The AniVault Chrome Extension can detect episodes on popular streaming sites (like Crunchyroll, Zoro, Netflix and others) and send that progress into the AniVault desktop app. During testing, it is available as a developer install.',
  },
  {
    question: 'What platforms does AniVault support?',
    answer: 'Right now AniVault is built for Windows desktop. Mac and Linux support are planned.',
  },
  {
    question: 'Is my data private?',
    answer:
      'Guest mode is local-only. Your library and watch history stay on your PC. If you connect AniList, we only talk to their official API to sync your list.',
  },
  {
    question: 'How do I get Pro?',
    answer:
      'We\'re currently testing AniVault Pro with a small group of users using Lemon Squeezy in test mode. Public Pro access is coming soon.',
  },
]

const FAQ = () => {
  const [openIndex, setOpenIndex] = useState<number | null>(null)

  return (
    <section id="faq" className="py-24 px-4 sm:px-6 lg:px-8">
      <div className="max-w-4xl mx-auto">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6 }}
          className="text-center mb-16"
        >
          <h2 className="text-4xl sm:text-5xl font-display font-bold mb-4">FAQ</h2>
        </motion.div>

        <div className="space-y-4">
          {faqs.map((faq, index) => (
            <motion.div
              key={faq.question}
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
              transition={{ duration: 0.6, delay: index * 0.1 }}
            >
              <GlowCard className="overflow-hidden">
                <button
                  onClick={() => setOpenIndex(openIndex === index ? null : index)}
                  className="w-full p-6 flex items-center justify-between text-left hover:bg-white/5 transition-colors"
                >
                  <h3 className="text-lg font-semibold pr-4">{faq.question}</h3>
                  <ChevronDown
                    className={`w-5 h-5 text-gray-400 transition-transform flex-shrink-0 ${
                      openIndex === index ? 'rotate-180' : ''
                    }`}
                  />
                </button>
                <motion.div
                  initial={false}
                  animate={{
                    height: openIndex === index ? 'auto' : 0,
                    opacity: openIndex === index ? 1 : 0,
                  }}
                  transition={{ duration: 0.3 }}
                  className="overflow-hidden"
                >
                  <div className="px-6 pb-6 text-gray-400 leading-relaxed">{faq.answer}</div>
                </motion.div>
              </GlowCard>
            </motion.div>
          ))}
        </div>
      </div>
    </section>
  )
}

export default FAQ



========================================

=== apps\website\components\FeatureGrid.tsx ===

'use client'

import { motion } from 'framer-motion'
import { useState } from 'react'
import {
  PlayCircle,
  Library,
  Link2,
  User,
  BarChart3,
  FolderTree,
  Sparkles,
  MessageSquare,
  TrendingUp,
  Palette,
  MonitorPlay,
} from 'lucide-react'
import GlowCard from './GlowCard'

const features = [
  {
    category: 'free',
    icon: PlayCircle,
    title: 'Auto-tracking',
    description: 'Watches your local media players and detects what you\'re watching automatically.',
  },
  {
    category: 'free',
    icon: MonitorPlay,
    title: 'Browser Auto-Tracking',
    description:
      'AniVault Chrome Extension watches your anime on streaming sites and forwards episodes to the desktop app â€” no more manually updating progress.',
  },
  {
    category: 'free',
    icon: Library,
    title: 'AniVault Library',
    description: 'Beautiful media center UI to browse and manage your anime collection.',
  },
  {
    category: 'free',
    icon: Link2,
    title: 'AniList Sync',
    description: 'Connect your AniList account to sync your library and progress online.',
  },
  {
    category: 'free',
    icon: User,
    title: 'Guest Mode',
    description: 'Use AniVault completely offline. No account required.',
  },
  {
    category: 'free',
    icon: BarChart3,
    title: 'Basic Stats',
    description: 'Track episodes watched, hours, and genre breakdowns.',
  },
  {
    category: 'pro',
    icon: FolderTree,
    title: 'Auto Organizer',
    description:
      'One click to turn messy downloads into organized folders. [SubsPlease] Jujutsu Kaisen - 05.mkv â†’ D:\\Anime\\Jujutsu Kaisen\\Season 1\\Jujutsu Kaisen - Episode 05.mkv',
  },
  {
    category: 'pro',
    icon: Sparkles,
    title: 'Mood-Based Recommendations',
    description: 'Pick a mood â€” hype, cozy, emotional, mind-bending â€” and AniVault finds the perfect show.',
  },
  {
    category: 'pro',
    icon: MessageSquare,
    title: 'Discord Presence Pro+',
    description: 'Show what you\'re watching, binge stats, and your current vibe directly on Discord.',
  },
  {
    category: 'pro',
    icon: TrendingUp,
    title: 'Advanced Stats & Heatmaps',
    description: 'See your watch history as a contribution graph, binge sessions, and yearly Wrapped-style summaries.',
  },
  {
    category: 'pro',
    icon: Palette,
    title: 'Premium Themes',
    description: 'Neon, midnight, vaporwave â€” customize AniVault to match your setup.',
  },
]

const FeatureGrid = () => {
  const [filter, setFilter] = useState<'all' | 'free' | 'pro'>('all')

  const filteredFeatures =
    filter === 'all' ? features : features.filter((f) => f.category === filter)

  return (
    <section id="features" className="py-24 px-4 sm:px-6 lg:px-8">
      <div className="max-w-7xl mx-auto">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6 }}
          className="text-center mb-12"
        >
          <h2 className="text-4xl sm:text-5xl font-display font-bold mb-4">Features</h2>
        </motion.div>

        {/* Filter Pills */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6, delay: 0.1 }}
          className="flex justify-center gap-3 mb-12"
        >
          {(['all', 'free', 'pro'] as const).map((f) => (
            <button
              key={f}
              onClick={() => setFilter(f)}
              className={`px-6 py-2 rounded-full text-sm font-semibold transition-all ${
                filter === f
                  ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white shadow-lg shadow-purple-500/50'
                  : 'glass-card text-gray-400 hover:text-white hover:bg-white/10'
              }`}
            >
              {f.charAt(0).toUpperCase() + f.slice(1)}
            </button>
          ))}
        </motion.div>

        {/* Feature Grid */}
        <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
          {filteredFeatures.map((feature, index) => {
            const Icon = feature.icon
            return (
              <GlowCard key={feature.title} delay={index * 0.1} className="p-6 relative">
                {feature.category === 'pro' && (
                  <div className="absolute top-4 right-4 px-2 py-1 rounded-full bg-gradient-to-r from-purple-600 to-pink-600 text-xs font-semibold text-white">
                    PRO
                  </div>
                )}
                <div className="space-y-4">
                  <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-purple-500/20 to-pink-500/20 border border-purple-500/30 flex items-center justify-center">
                    <Icon className="w-6 h-6 text-purple-400" />
                  </div>
                  <div className="space-y-2">
                    <h3 className="text-xl font-display font-bold">{feature.title}</h3>
                    <p className="text-sm text-gray-400 leading-relaxed">{feature.description}</p>
                  </div>
                </div>
              </GlowCard>
            )
          })}
        </div>
      </div>
    </section>
  )
}

export default FeatureGrid



========================================

=== apps\website\components\Footer.tsx ===

'use client'

import { motion } from 'framer-motion'

const Footer = () => {
  const scrollTo = (href: string) => {
    // Extract hash from href (e.g., '#features' from '#features')
    const hash = href.startsWith('#') ? href : `#${href.replace(/^#/, '')}`
    const element = document.querySelector(hash)
    if (element) {
      const yOffset = -80 // Account for fixed navbar
      const y = element.getBoundingClientRect().top + window.pageYOffset + yOffset
      window.scrollTo({ top: y, behavior: 'smooth' })
    }
  }

  return (
    <footer className="border-t border-white/5 mt-24">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div className="grid md:grid-cols-4 gap-8 mb-8">
          {/* Logo */}
          <div className="space-y-4">
            <button
              onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
              className="flex items-center gap-2 hover:opacity-80 transition-opacity"
            >
              <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
                <span className="text-white font-bold text-sm">AV</span>
              </div>
              <span className="text-xl font-display font-bold">AniVault</span>
            </button>
            <p className="text-sm text-gray-400">
              Automatic anime tracker & media center for Windows.
            </p>
          </div>

          {/* Links */}
          <div>
            <h4 className="font-semibold mb-4">Legal</h4>
            <ul className="space-y-2 text-sm text-gray-400">
              <li>
                <button
                  onClick={() => {
                    // Placeholder - can be replaced with actual route later
                    alert('Privacy Policy page coming soon')
                  }}
                  className="hover:text-white transition-colors text-left"
                >
                  Privacy Policy
                </button>
              </li>
              <li>
                <button
                  onClick={() => {
                    // Placeholder - can be replaced with actual route later
                    alert('Terms of Use page coming soon')
                  }}
                  className="hover:text-white transition-colors text-left"
                >
                  Terms of Use
                </button>
              </li>
            </ul>
          </div>

          <div>
            <h4 className="font-semibold mb-4">Support</h4>
            <ul className="space-y-2 text-sm text-gray-400">
              <li>
                <a
                  href="mailto:support@anivault.app"
                  className="hover:text-white transition-colors"
                >
                  support@anivault.app
                </a>
              </li>
            </ul>
          </div>

          <div>
            <h4 className="font-semibold mb-4">Download</h4>
            <ul className="space-y-2 text-sm text-gray-400">
              <li>
                <button
                  type="button"
                  onClick={(e) => {
                    e.preventDefault()
                    e.stopPropagation()
                    scrollTo('#features')
                  }}
                  className="hover:text-white transition-colors text-left"
                >
                  Windows App
                </button>
              </li>
              <li>
                <button
                  type="button"
                  onClick={(e) => {
                    e.preventDefault()
                    e.stopPropagation()
                    scrollTo('#features')
                  }}
                  className="hover:text-white transition-colors text-left"
                >
                  Chrome Extension <span className="text-xs text-gray-500">(Developer Preview)</span>
                </button>
              </li>
            </ul>
          </div>
        </div>

        <div className="pt-8 border-t border-white/5 text-center">
          <p className="text-xs text-gray-500">
            Not affiliated with AniList, MyAnimeList, Crunchyroll, or any streaming platform.
          </p>
        </div>
      </div>
    </footer>
  )
}

export default Footer



========================================

=== apps\website\components\GlowCard.tsx ===

'use client'

import { motion } from 'framer-motion'
import { ReactNode } from 'react'

interface GlowCardProps {
  children: ReactNode
  className?: string
  delay?: number
  hover?: boolean
}

const GlowCard = ({ children, className = '', delay = 0, hover = true }: GlowCardProps) => {
  return (
    <motion.div
      initial={{ opacity: 0, y: 40 }}
      whileInView={{ opacity: 1, y: 0 }}
      viewport={{ once: true, margin: '-100px' }}
      transition={{ duration: 0.6, delay }}
      className={`glass-card ${hover ? 'glass-card-hover' : ''} ${className}`}
    >
      {children}
    </motion.div>
  )
}

export default GlowCard



========================================

=== apps\website\components\Hero.tsx ===

'use client'

import { motion } from 'framer-motion'
import { Download, Play, Github } from 'lucide-react'

const Hero = () => {
  const scrollTo = (href: string) => {
    // Extract hash from href (e.g., '#features' from '#features')
    const hash = href.startsWith('#') ? href : `#${href.replace(/^#/, '')}`
    const element = document.querySelector(hash)
    if (element) {
      const yOffset = -80 // Account for fixed navbar
      const y = element.getBoundingClientRect().top + window.pageYOffset + yOffset
      window.scrollTo({ top: y, behavior: 'smooth' })
    }
  }

  return (
    <section id="home" className="relative min-h-screen flex items-center justify-center pt-20 px-4 sm:px-6 lg:px-8 overflow-hidden">
      <div className="max-w-7xl mx-auto grid lg:grid-cols-2 gap-12 items-center">
        {/* Left Column - Text */}
        <motion.div
          initial={{ opacity: 0, x: -50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.8 }}
          className="space-y-8"
        >
          {/* Badge */}
          <motion.div
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ delay: 0.2, duration: 0.5 }}
            className="inline-flex items-center gap-2 px-4 py-1.5 rounded-full bg-purple-500/10 border border-purple-500/30 text-sm text-purple-300"
          >
            <span className="w-2 h-2 rounded-full bg-purple-500 animate-pulse" />
            New â€¢ Automatic anime tracker
          </motion.div>

          {/* Heading */}
          <motion.h1
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3, duration: 0.6 }}
            className="text-5xl sm:text-6xl lg:text-7xl font-display font-bold leading-tight"
          >
            Your anime.
            <br />
            <span className="bg-gradient-to-r from-purple-400 via-pink-400 to-purple-400 bg-clip-text text-transparent">
              Tracked automatically.
            </span>
          </motion.h1>

          {/* Subheading */}
          <motion.p
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4, duration: 0.6 }}
            className="text-lg sm:text-xl text-gray-400 max-w-xl leading-relaxed"
          >
            AniVault watches what you watch and updates your lists, stats, and Discord â€” no more
            manual episode updates.
          </motion.p>

          {/* Buttons */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.5, duration: 0.6 }}
            className="flex flex-wrap gap-4"
          >
            <button
              type="button"
              onClick={(e) => {
                e.preventDefault()
                e.stopPropagation()
                scrollTo('#features')
              }}
              className="group px-8 py-4 rounded-full bg-gradient-to-r from-purple-600 to-pink-600 text-white font-semibold hover:from-purple-500 hover:to-pink-500 transition-all shadow-lg shadow-purple-500/50 hover:shadow-purple-500/70 hover:scale-105 flex items-center gap-2"
            >
              <Download size={20} />
              Download for Windows
            </button>
            <button
              type="button"
              onClick={(e) => {
                e.preventDefault()
                e.stopPropagation()
                scrollTo('#how-it-works')
              }}
              className="px-8 py-4 rounded-full glass-card text-white font-semibold hover:bg-white/10 transition-all flex items-center gap-2"
            >
              <Play size={20} />
              Learn More
            </button>
          </motion.div>

          {/* Tiny text */}
          <motion.p
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.6, duration: 0.6 }}
            className="text-xs text-gray-500"
          >
            No account required. AniList login optional.
          </motion.p>

          {/* Ecosystem Tiles */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.7, duration: 0.6 }}
            className="grid md:grid-cols-3 gap-6 mt-12"
          >
            <div className="glass-card p-6 space-y-2">
              <h3 className="font-semibold text-white">Desktop App</h3>
              <p className="text-sm text-gray-400">
                Netflix-style media center with auto-tracking from local players like VLC, MPV, and more.
              </p>
            </div>
            <div className="glass-card p-6 space-y-2">
              <h3 className="font-semibold text-white">Browser Extension</h3>
              <p className="text-sm text-gray-400">
                Chrome extension that detects anime on streaming sites (Crunchyroll, Zoro, Netflix, etc.) and sends progress directly into AniVault.
              </p>
            </div>
            <div className="glass-card p-6 space-y-2">
              <h3 className="font-semibold text-white">Website</h3>
              <p className="text-sm text-gray-400">
                Clean landing page and docs hub â€” download AniVault, learn features, and stay updated.
              </p>
            </div>
          </motion.div>
        </motion.div>

        {/* Right Column - Floating Cards */}
        <motion.div
          initial={{ opacity: 0, x: 50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ duration: 0.8, delay: 0.3 }}
          className="relative h-[600px] flex items-center justify-center"
        >
          {/* Halo gradient */}
          <div className="absolute inset-0 bg-gradient-radial from-purple-500/30 via-pink-500/20 to-transparent rounded-full blur-3xl" />

          {/* Large Library Card */}
          <motion.div
            animate={{ y: [0, -20, 0] }}
            transition={{ duration: 6, repeat: Infinity, ease: 'easeInOut' }}
            className="absolute z-10 w-80 h-96 glass-card p-6 rotate-[-3deg] shadow-2xl"
          >
            <div className="h-full rounded-lg bg-gradient-to-br from-slate-900 to-slate-800 border border-white/10 p-4 space-y-3">
              <div className="flex items-center justify-between">
                <h3 className="font-semibold text-white">My Library</h3>
                <div className="w-2 h-2 rounded-full bg-green-500" />
              </div>
              <div className="space-y-2">
                {[1, 2, 3].map((i) => (
                  <div key={i} className="h-16 rounded-lg bg-white/5 border border-white/10 flex items-center gap-3 p-3">
                    <div className="w-12 h-12 rounded bg-gradient-to-br from-purple-500/20 to-pink-500/20" />
                    <div className="flex-1 space-y-1">
                      <div className="h-2 w-24 bg-white/20 rounded" />
                      <div className="h-2 w-16 bg-white/10 rounded" />
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </motion.div>

          {/* Detection Card */}
          <motion.div
            animate={{ y: [0, 15, 0] }}
            transition={{ duration: 5, repeat: Infinity, ease: 'easeInOut', delay: 1 }}
            className="absolute top-20 right-0 z-20 w-64 glass-card p-4 rotate-[2deg] shadow-xl"
          >
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <div className="w-2 h-2 rounded-full bg-green-400 animate-pulse" />
                <span className="text-xs text-gray-400">Detected</span>
              </div>
              <p className="text-sm font-semibold text-white">Jujutsu Kaisen</p>
              <p className="text-xs text-gray-400">Episode 5</p>
            </div>
          </motion.div>

          {/* Discord Presence Card */}
          <motion.div
            animate={{ y: [0, -15, 0] }}
            transition={{ duration: 4, repeat: Infinity, ease: 'easeInOut', delay: 2 }}
            className="absolute bottom-20 left-0 z-20 w-56 glass-card p-3 rotate-[-2deg] shadow-xl"
          >
            <div className="space-y-1.5">
              <div className="flex items-center gap-2">
                <div className="w-6 h-6 rounded bg-gradient-to-br from-indigo-500 to-purple-500" />
                <span className="text-xs text-gray-400">Discord</span>
              </div>
              <p className="text-xs text-white">Watching: One Piece</p>
              <p className="text-xs text-gray-500">Ep 1070 / 1100</p>
            </div>
          </motion.div>
        </motion.div>
      </div>
    </section>
  )
}

export default Hero



========================================

=== apps\website\components\HowItWorks.tsx ===

'use client'

import { motion } from 'framer-motion'
import { Search, Brain, RefreshCw, MonitorPlay } from 'lucide-react'
import GlowCard from './GlowCard'

const steps = [
  {
    icon: Search,
    title: 'Detect',
    description:
      'AniVault looks at your open windows and media players. When it sees something like "One Piece â€“ 1070.mkv" or "Naruto S02E10" it knows exactly what you\'re watching.',
  },
  {
    icon: Brain,
    title: 'Understand',
    description:
      'A filename parser and AniList\'s database work together to detect the title and episode, even through messy fansub filenames.',
  },
  {
    icon: MonitorPlay,
    title: 'Stream',
    description:
      'If you\'re watching on Crunchyroll, Zoro, Netflix or other streaming sites, the AniVault Chrome Extension detects episodes in your browser and relays them to the desktop app.',
  },
  {
    icon: RefreshCw,
    title: 'Sync',
    description:
      'Your library updates automatically. If you connect AniList, your online profile syncs too â€” without you opening a browser.',
  },
]

const HowItWorks = () => {
  return (
    <section id="how-it-works" className="py-24 px-4 sm:px-6 lg:px-8 border-t border-white/5">
      <div className="max-w-7xl mx-auto">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6 }}
          className="text-center mb-16"
        >
          <h2 className="text-4xl sm:text-5xl font-display font-bold mb-4">How AniVault Works</h2>
          <p className="text-lg text-gray-400 max-w-2xl mx-auto">
            AniVault isn't another list website. It's a local app that watches your players and browser,
            then updates everything for you â€” on your PC and on AniList.
          </p>
        </motion.div>

        <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-8">
          {steps.map((step, index) => {
            const Icon = step.icon
            return (
              <GlowCard key={step.title} delay={index * 0.2} className="p-8">
                <div className="flex flex-col items-center text-center space-y-4">
                  <div className="w-16 h-16 rounded-2xl bg-gradient-to-br from-purple-500/20 to-pink-500/20 border border-purple-500/30 flex items-center justify-center">
                    <Icon className="w-8 h-8 text-purple-400" />
                  </div>
                  <div className="space-y-2">
                    <h3 className="text-2xl font-display font-bold">{step.title}</h3>
                    <p className="text-gray-400 leading-relaxed">{step.description}</p>
                  </div>
                </div>
              </GlowCard>
            )
          })}
        </div>
      </div>
    </section>
  )
}

export default HowItWorks



========================================

=== apps\website\components\NavBar.tsx ===

'use client'

import { motion } from 'framer-motion'
import { useState, useEffect } from 'react'

const NavBar = () => {
  const [scrolled, setScrolled] = useState(false)

  useEffect(() => {
    const handleScroll = () => {
      setScrolled(window.scrollY > 20)
    }
    window.addEventListener('scroll', handleScroll)
    return () => window.removeEventListener('scroll', handleScroll)
  }, [])

  const navItems = [
    { label: 'Features', href: '#features' },
    { label: 'Pro', href: '#pro' },
    { label: 'Screenshots', href: '#screenshots' },
    { label: 'FAQ', href: '#faq' },
  ]

  const scrollTo = (href: string) => {
    // Extract hash from href (e.g., '#features' from '#features')
    const hash = href.startsWith('#') ? href : `#${href.replace(/^#/, '')}`
    const element = document.querySelector(hash)
    if (element) {
      const yOffset = -80 // Account for fixed navbar
      const y = element.getBoundingClientRect().top + window.pageYOffset + yOffset
      window.scrollTo({ top: y, behavior: 'smooth' })
    }
  }

  return (
    <motion.nav
      initial={{ y: -100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      transition={{ duration: 0.6 }}
      className={`fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${
        scrolled
          ? 'backdrop-blur-xl bg-black/60 border-b border-white/10 shadow-lg'
          : 'backdrop-blur-md bg-black/20 border-b border-white/5'
      }`}
    >
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex items-center justify-between h-16">
          {/* Logo */}
          <motion.button
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.2 }}
            onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })}
            className="flex items-center gap-2 hover:opacity-80 transition-opacity"
          >
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
              <span className="text-white font-bold text-sm">AV</span>
            </div>
            <span className="text-xl font-display font-bold tracking-tight">AniVault</span>
          </motion.button>

          {/* Nav Links */}
          <div className="hidden md:flex items-center gap-8">
            {navItems.map((item, index) => (
              <motion.button
                key={item.label}
                type="button"
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.3 + index * 0.1 }}
                onClick={(e) => {
                  e.preventDefault()
                  e.stopPropagation()
                  scrollTo(item.href)
                }}
                className="relative text-sm font-medium text-gray-300 hover:text-white transition-colors group"
              >
                {item.label}
                <motion.span
                  className="absolute bottom-0 left-0 right-0 h-0.5 bg-gradient-to-r from-purple-500 to-pink-500"
                  initial={{ scaleX: 0 }}
                  whileHover={{ scaleX: 1 }}
                  transition={{ duration: 0.3 }}
                />
              </motion.button>
            ))}
          </div>

          {/* Download Button */}
          <motion.button
            type="button"
            initial={{ opacity: 0, x: 20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.5 }}
            onClick={(e) => {
              e.preventDefault()
              e.stopPropagation()
              scrollTo('#features')
            }}
            className="px-6 py-2 rounded-full bg-gradient-to-r from-purple-600 to-pink-600 text-white font-semibold text-sm hover:from-purple-500 hover:to-pink-500 transition-all shadow-lg shadow-purple-500/50 hover:shadow-purple-500/70 hover:scale-105"
          >
            Download
          </motion.button>
        </div>
      </div>
    </motion.nav>
  )
}

export default NavBar



========================================

=== apps\website\components\Pricing.tsx ===

'use client'

import { motion } from 'framer-motion'
import { Check } from 'lucide-react'
import GlowCard from './GlowCard'

const Pricing = () => {
  return (
    <section id="pro" className="py-24 px-4 sm:px-6 lg:px-8 relative">
      <div className="absolute inset-0 bg-gradient-to-r from-purple-500/10 via-pink-500/10 to-purple-500/10" />
      <div className="max-w-7xl mx-auto relative">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6 }}
          className="text-center mb-16"
        >
          <h2 className="text-4xl sm:text-5xl font-display font-bold mb-4">
            AniVault Pro â€” Coming Soon
          </h2>
          <p className="text-sm text-purple-400 mb-2">(Test Mode)</p>
        </motion.div>

        <div className="grid lg:grid-cols-2 gap-12 items-center">
          {/* Left: Pitch */}
          <motion.div
            initial={{ opacity: 0, x: -50 }}
            whileInView={{ opacity: 1, x: 0 }}
            viewport={{ once: true }}
            transition={{ duration: 0.6 }}
            className="space-y-6"
          >
            <p className="text-lg text-gray-300 leading-relaxed">
              AniVault Pro is for power users. Organize your library, flex on Discord, and dive into
              advanced stats. We're currently testing Pro with a small group of users.
            </p>
            <div className="space-y-3">
              <div className="flex items-center gap-3 text-gray-400">
                <Check className="w-5 h-5 text-purple-400" />
                <span>All Pro features listed above</span>
              </div>
              <div className="flex items-center gap-3 text-gray-400">
                <Check className="w-5 h-5 text-purple-400" />
                <span>Future Pro perks & updates</span>
              </div>
              <div className="flex items-center gap-3 text-gray-400">
                <Check className="w-5 h-5 text-purple-400" />
                <span>Early access to new features</span>
              </div>
            </div>
          </motion.div>

          {/* Right: Pricing Card */}
          <motion.div
            initial={{ opacity: 0, x: 50 }}
            whileInView={{ opacity: 1, x: 0 }}
            viewport={{ once: true }}
            transition={{ duration: 0.6 }}
          >
            <GlowCard className="p-8 border-2 border-purple-500/30 relative overflow-hidden">
              <div className="absolute top-0 right-0 w-32 h-32 bg-purple-500/20 rounded-full blur-2xl -mr-16 -mt-16" />
              <div className="relative space-y-6">
                <div>
                  <div className="text-5xl font-display font-bold mb-2">
                    <span className="bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
                      Pricing TBA
                    </span>
                  </div>
                  <p className="text-gray-400">Public Pro access coming soon</p>
                </div>

                <div className="space-y-4 pt-4 border-t border-white/10">
                  <button
                    disabled
                    className="w-full px-6 py-3 rounded-full bg-gradient-to-r from-purple-600 to-pink-600 text-white font-semibold opacity-50 cursor-not-allowed"
                  >
                    Join Pro Test (Soon)
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault()
                      e.stopPropagation()
                      const element = document.querySelector('#features')
                      if (element) {
                        const yOffset = -80 // Account for fixed navbar
                        const y = element.getBoundingClientRect().top + window.pageYOffset + yOffset
                        window.scrollTo({ top: y, behavior: 'smooth' })
                      }
                    }}
                    className="w-full px-6 py-3 rounded-full glass-card text-white font-semibold hover:bg-white/10 transition-all"
                  >
                    Stay on Free
                  </button>
                </div>
              </div>
            </GlowCard>
          </motion.div>
        </div>
      </div>
    </section>
  )
}

export default Pricing



========================================

=== apps\website\components\Screenshots.tsx ===

'use client'

import { motion } from 'framer-motion'
import GlowCard from './GlowCard'

const screenshots = [
  {
    title: 'Library View',
    description: 'Beautiful media center interface',
    gradient: 'from-purple-500/20 to-pink-500/20',
  },
  {
    title: 'Stats Dashboard',
    description: 'Advanced analytics and insights',
    gradient: 'from-blue-500/20 to-purple-500/20',
  },
  {
    title: 'Discord Presence',
    description: 'Show off your anime journey',
    gradient: 'from-indigo-500/20 to-purple-500/20',
  },
  {
    title: 'Auto Organizer',
    description: 'Organize your downloads',
    gradient: 'from-pink-500/20 to-orange-500/20',
  },
]

const Screenshots = () => {
  return (
    <section id="screenshots" className="py-24 px-4 sm:px-6 lg:px-8">
      <div className="max-w-7xl mx-auto">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6 }}
          className="text-center mb-16"
        >
          <h2 className="text-4xl sm:text-5xl font-display font-bold mb-4">
            See AniVault in Action
          </h2>
        </motion.div>

        <div className="grid sm:grid-cols-2 lg:grid-cols-4 gap-6">
          {screenshots.map((screenshot, index) => (
            <motion.div
              key={screenshot.title}
              initial={{ opacity: 0, y: 40 }}
              whileInView={{ opacity: 1, y: 0 }}
              viewport={{ once: true }}
              transition={{ duration: 0.6, delay: index * 0.1 }}
              whileHover={{ y: -10, rotate: 2 }}
              className="cursor-pointer"
            >
              <GlowCard className="p-6 h-full">
                <div className={`aspect-video rounded-lg bg-gradient-to-br ${screenshot.gradient} border border-white/10 flex items-center justify-center mb-4`}>
                  <p className="text-xs text-gray-400 text-center px-4">
                    {screenshot.title}
                    <br />
                    Screenshot Coming Soon
                  </p>
                </div>
                <h3 className="font-semibold mb-1">{screenshot.title}</h3>
                <p className="text-sm text-gray-400">{screenshot.description}</p>
              </GlowCard>
            </motion.div>
          ))}
        </div>
      </div>
    </section>
  )
}

export default Screenshots



========================================

=== apps\website\next-env.d.ts ===

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.


========================================

=== apps\website\next.config.js ===

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  transpilePackages: ['@anivault/shared'],
}

module.exports = nextConfig



========================================

=== apps\website\package.json ===

{
  "name": "website",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start -p 3001",
    "lint": "next lint"
  },
  "dependencies": {
    "@anivault/shared": "workspace:*",
    "framer-motion": "^10.16.16",
    "lucide-react": "^0.303.0",
    "next": "^14.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3"
  }
}



========================================

=== apps\website\postcss.config.js ===

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



========================================

=== apps\website\tailwind.config.js ===

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#faf5ff',
          100: '#f3e8ff',
          200: '#e9d5ff',
          300: '#d8b4fe',
          400: '#c084fc',
          500: '#a855f7',
          600: '#9333ea',
          700: '#7e22ce',
          800: '#6b21a8',
          900: '#581c87',
          950: '#3b0764',
        },
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
        display: ['Space Grotesk', 'system-ui', 'sans-serif'],
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
      animation: {
        'float': 'float 6s ease-in-out infinite',
        'glow': 'glow 2s ease-in-out infinite alternate',
      },
      keyframes: {
        float: {
          '0%, 100%': { transform: 'translateY(0px)' },
          '50%': { transform: 'translateY(-20px)' },
        },
        glow: {
          '0%': { boxShadow: '0 0 20px rgba(168, 85, 247, 0.4)' },
          '100%': { boxShadow: '0 0 40px rgba(168, 85, 247, 0.8)' },
        },
      },
    },
  },
  plugins: [],
}



========================================

=== apps\website\tsconfig.json ===

{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



========================================

=== package.json ===

{
  "name": "anivault",
  "version": "0.1.0",
  "private": true,
  "description": "The Ultimate Anime Ecosystem",
  "scripts": {
    "dev:desktop": "pnpm --filter desktop dev",
    "dev:extension": "pnpm --filter extension dev",
    "dev:web": "pnpm --filter web dev",
    "dev:website": "pnpm --filter website dev",
    "build:desktop": "pnpm --filter desktop build",
    "build:extension": "pnpm --filter extension build",
    "build:web": "pnpm --filter web build",
    "build:website": "pnpm --filter website build",
    "build": "pnpm -r build"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": ">=18.0.0",
    "pnpm": ">=8.0.0"
  },
  "dependencies": {
    "electron-builder": "^24.13.3",
    "electron-log": "^5.4.3",
    "electron-updater": "^6.6.2"
  }
}


========================================

=== packages\shared\package.json ===

{
  "name": "@anivault/shared",
  "version": "0.1.0",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "scripts": {
    "type-check": "tsc --noEmit"
  },
  "devDependencies": {
    "typescript": "^5.3.3"
  }
}



========================================

=== packages\shared\src\extension.ts ===

export interface ExtensionEpisodeEvent {
  platform: string
  title: string
  overallEpisode?: number | null // Crunchyroll global numbering e.g. 14
  seasonNumber?: number | null // 2 (if adapter detected it)
  seasonEpisode?: number | null // may be null if Crunchyroll uses global numbers
  url?: string
  watchedSeconds?: number
  durationSeconds?: number
  progress?: number
  completedAt?: string
}

/**
 * Convert a global/absolute episode number to a season-local episode number
 * using per-season episode counts.
 *
 * @param globalEpisode Global episode number (e.g., 14 for S2E2 when S1 has 12 eps)
 * @param seasonNumber Season index (1-based)
 * @param episodeCountsPerSeason Array of episode counts per season (index 0 = Season 1)
 */
export function convertGlobalToSeasonEpisode(
  globalEpisode: number,
  seasonNumber: number,
  episodeCountsPerSeason: number[]
): number {
  if (!Array.isArray(episodeCountsPerSeason) || episodeCountsPerSeason.length === 0) {
    return Math.max(1, globalEpisode)
  }

  const prevTotal = episodeCountsPerSeason
    .slice(0, Math.max(0, seasonNumber - 1))
    .reduce((a, b) => a + (b || 0), 0)

  let seasonEpisode = globalEpisode - prevTotal
  if (seasonEpisode < 1) seasonEpisode = 1

  const maxInSeason = episodeCountsPerSeason[seasonNumber - 1] ?? seasonEpisode
  if (seasonEpisode > maxInSeason) seasonEpisode = maxInSeason

  return seasonEpisode
}



========================================

=== packages\shared\src\index.ts ===

// Anime Types
export interface Anime {
  id: string;
  title: string;
  titleEnglish?: string;
  titleJapanese?: string;
  description?: string;
  coverImage?: string;
  bannerImage?: string;
  episodes?: number;
  status: 'watching' | 'completed' | 'on-hold' | 'dropped' | 'plan-to-watch';
  progress: number;
  rating?: number;
  genres?: string[];
  year?: number;
  season?: 'winter' | 'spring' | 'summer' | 'fall';
  format?: 'TV' | 'Movie' | 'OVA' | 'ONA' | 'Special';
  source?: string;
  createdAt: Date;
  updatedAt: Date;
}

// User Types
export interface User {
  id: string;
  username: string;
  email?: string;
  avatar?: string;
  preferences: UserPreferences;
  createdAt: Date;
  updatedAt: Date;
}

export interface UserPreferences {
  theme: 'dark' | 'light' | 'auto';
  autoTrack: boolean;
  syncEnabled: boolean;
  notifications: boolean;
  language: string;
}

// Tracking Events
export interface TrackingEvent {
  id: string;
  animeId: string;
  userId: string;
  type: 'episode_start' | 'episode_complete' | 'anime_start' | 'anime_complete' | 'rating_update' | 'status_change';
  episodeNumber?: number;
  timestamp: Date;
  metadata?: Record<string, unknown>;
}

export interface EpisodeProgress {
  animeId: string;
  episodeNumber: number;
  watched: boolean;
  progress: number; // 0-100
  lastWatchedAt?: Date;
}

// Streaming Platform Types
export type StreamingPlatform = 'crunchyroll' | 'netflix' | 'local' | 'other';

export interface StreamingSession {
  id: string;
  platform: StreamingPlatform;
  animeId?: string;
  episodeNumber?: number;
  startTime: Date;
  endTime?: Date;
  metadata?: Record<string, unknown>;
}

export * from './extension';



========================================

=== packages\shared\tsconfig.json ===

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}



========================================

=== packages\ui\package.json ===

{
  "name": "@anivault/ui",
  "version": "0.1.0",
  "type": "module",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "exports": {
    ".": "./src/index.ts",
    "./tailwind": "./tailwind.config.js"
  },
  "scripts": {
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@radix-ui/react-slot": "^1.0.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.2.0",
    "lucide-react": "^0.303.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "react": "^18.2.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3"
  },
  "peerDependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}



========================================

=== packages\ui\postcss.config.js ===

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}



========================================

=== packages\ui\src\components\button.tsx ===

import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from '../lib/utils'

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button'
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = 'Button'

export { Button, buttonVariants }



========================================

=== packages\ui\src\components\card.tsx ===

import * as React from 'react'
import { cn } from '../lib/utils'

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-lg border bg-card text-card-foreground shadow-sm',
      className
    )}
    {...props}
  />
))
Card.displayName = 'Card'

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
))
CardHeader.displayName = 'CardHeader'

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
))
CardTitle.displayName = 'CardTitle'

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
))
CardDescription.displayName = 'CardDescription'

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
))
CardContent.displayName = 'CardContent'

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
))
CardFooter.displayName = 'CardFooter'

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



========================================

=== packages\ui\src\components\input.tsx ===

import * as React from 'react'
import { cn } from '../lib/utils'

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = 'Input'

export { Input }



========================================

=== packages\ui\src\index.ts ===

export { Button, buttonVariants } from './components/button'
export type { ButtonProps } from './components/button'
export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
} from './components/card'
export { Input } from './components/input'
export type { InputProps } from './components/input'
export { cn } from './lib/utils'



========================================

=== packages\ui\src\lib\utils.ts ===

import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



========================================

=== packages\ui\tailwind.config.js ===

/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ['class'],
  content: [
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {
      colors: {
        border: 'hsl(0 0% 14.9%)',
        input: 'hsl(0 0% 14.9%)',
        ring: 'hsl(262.1 83.3% 57.8%)',
        background: '#050505',
        foreground: 'hsl(0 0% 98%)',
        primary: {
          DEFAULT: 'hsl(262.1 83.3% 57.8%)',
          foreground: 'hsl(0 0% 98%)',
        },
        secondary: {
          DEFAULT: 'hsl(0 0% 14.9%)',
          foreground: 'hsl(0 0% 98%)',
        },
        destructive: {
          DEFAULT: 'hsl(0 62.8% 30.6%)',
          foreground: 'hsl(0 0% 98%)',
        },
        muted: {
          DEFAULT: 'hsl(0 0% 14.9%)',
          foreground: 'hsl(0 0% 63.9%)',
        },
        accent: {
          DEFAULT: 'hsl(0 0% 14.9%)',
          foreground: 'hsl(0 0% 98%)',
        },
        popover: {
          DEFAULT: 'hsl(0 0% 3.9%)',
          foreground: 'hsl(0 0% 98%)',
        },
        card: {
          DEFAULT: 'hsl(0 0% 3.9%)',
          foreground: 'hsl(0 0% 98%)',
        },
      },
      borderRadius: {
        lg: '0.5rem',
        md: 'calc(0.5rem - 2px)',
        sm: 'calc(0.5rem - 4px)',
      },
      backdropBlur: {
        xs: '2px',
      },
      animation: {
        'glow': 'glow 2s ease-in-out infinite alternate',
      },
      keyframes: {
        glow: {
          '0%': { boxShadow: '0 0 5px rgba(139, 92, 246, 0.5), 0 0 10px rgba(139, 92, 246, 0.3)' },
          '100%': { boxShadow: '0 0 10px rgba(139, 92, 246, 0.8), 0 0 20px rgba(139, 92, 246, 0.5)' },
        },
      },
    },
  },
  plugins: [],
}



========================================

=== packages\ui\tsconfig.json ===

{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}



========================================

=== pnpm-workspace.yaml ===

packages:
  - apps/*
  - packages/*

onlyBuiltDependencies:
  - electron


========================================

=== README.md ===

# AniVault

The Ultimate Anime Ecosystem

## Project Structure

- `apps/desktop` - Electron desktop application
- `apps/extension` - Chrome extension
- `apps/web` - Landing page (Astro)
- `packages/ui` - Shared UI components
- `packages/shared` - Shared TypeScript types and utilities

## Getting Started

```bash
# Install dependencies
pnpm install

# Run development servers
pnpm dev:desktop
pnpm dev:extension
pnpm dev:web

# Build all projects
pnpm build
```



========================================

=== SETUP.md ===

# AniVault Setup Guide

## Prerequisites

- Node.js >= 18.0.0
- pnpm >= 8.0.0

## Initial Setup

1. Install dependencies:
```bash
pnpm install
```

## Development

### Desktop App
```bash
pnpm dev:desktop
```
Runs the Electron app with hot reload.

### Chrome Extension
```bash
pnpm dev:extension
```
Builds the extension in watch mode. Load the `apps/extension/dist` folder in Chrome as an unpacked extension.

### Web Landing Page
```bash
pnpm dev:web
```
Starts the Astro dev server (usually on http://localhost:4321).

## Building

Build all projects:
```bash
pnpm build
```

Build individual projects:
```bash
pnpm build:desktop
pnpm build:extension
pnpm build:web
```

## Project Structure

```
AniVault/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ desktop/          # Electron desktop app
â”‚   â”œâ”€â”€ extension/        # Chrome extension
â”‚   â””â”€â”€ web/              # Astro landing page
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ shared/           # Shared TypeScript types
â”‚   â””â”€â”€ ui/               # Shared UI components
â””â”€â”€ pnpm-workspace.yaml
```

## Notes

- The extension requires icon files in `apps/extension/icons/` (icon-16.png, icon-32.png, icon-48.png, icon-128.png)
- Desktop app uses frameless transparent windows with custom titlebar
- All projects share the same Tailwind config from `packages/ui`
- TypeScript types are shared via `packages/shared`



========================================

